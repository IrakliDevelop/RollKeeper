{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 4, "column": 0}, "map": {"version":3,"sources":["file:///home/irakli/Projects/RollKeeper/apps/web/src/store/playerStore.ts"],"sourcesContent":["import { create } from 'zustand';\r\nimport { persist, createJSONStorage } from 'zustand/middleware';\r\nimport { CharacterState, CharacterExport } from '@/types/character';\r\nimport { DEFAULT_CHARACTER_STATE, STORAGE_KEY } from '@/utils/constants';\r\n\r\n// Storage configuration\r\nconst PLAYER_STORAGE_KEY = 'rollkeeper-player-data';\r\n\r\n// Player character interface - contains full CharacterState\r\nexport interface PlayerCharacter {\r\n  id: string;\r\n  name: string;\r\n  race: string;\r\n  class: string;\r\n  level: number;\r\n  createdAt: Date;\r\n  updatedAt: Date;\r\n  lastPlayed: Date;\r\n  characterData: CharacterState;\r\n  avatar?: string; // Base64 encoded image from character data\r\n  tags: string[];\r\n  isArchived: boolean;\r\n}\r\n\r\nexport interface PlayerSettings {\r\n  enableDeathAnimation: boolean;\r\n  enableLevelUpAnimation: boolean;\r\n}\r\n\r\nconst DEFAULT_PLAYER_SETTINGS: PlayerSettings = {\r\n  enableDeathAnimation: false,\r\n  enableLevelUpAnimation: false,\r\n};\r\n\r\n// Store state interface\r\ninterface PlayerStoreState {\r\n  // Core data\r\n  characters: PlayerCharacter[];\r\n  activeCharacterId: string | null;\r\n\r\n  // Player settings\r\n  settings: PlayerSettings;\r\n\r\n  // UI state\r\n  lastSelectedCharacterId: string | null;\r\n\r\n  // Computed getters\r\n  getActiveCharacter: () => PlayerCharacter | null;\r\n  getCharacterById: (id: string) => PlayerCharacter | null;\r\n  getActiveCharacters: () => PlayerCharacter[];\r\n  getArchivedCharacters: () => PlayerCharacter[];\r\n\r\n  // Character management\r\n  createCharacter: (\r\n    name: string,\r\n    characterData?: Partial<CharacterState>\r\n  ) => string;\r\n  updateCharacter: (\r\n    characterId: string,\r\n    updates: Partial<PlayerCharacter>\r\n  ) => void;\r\n  updateCharacterData: (\r\n    characterId: string,\r\n    characterData: CharacterState\r\n  ) => void;\r\n  deleteCharacter: (characterId: string) => void;\r\n  archiveCharacter: (characterId: string) => void;\r\n  restoreCharacter: (characterId: string) => void;\r\n  duplicateCharacter: (characterId: string, newName: string) => string;\r\n\r\n  // Character selection\r\n  setActiveCharacter: (characterId: string | null) => void;\r\n\r\n  // Migration and utility\r\n  migrateFromOldStorage: () => boolean;\r\n  exportCharacter: (characterId: string) => PlayerCharacter | null;\r\n  importCharacter: (\r\n    data: CharacterState | CharacterExport,\r\n    name?: string\r\n  ) => string;\r\n\r\n  // Settings management\r\n  updateSettings: (updates: Partial<PlayerSettings>) => void;\r\n  resetSettings: () => void;\r\n\r\n  // Reset and cleanup\r\n  resetStore: () => void;\r\n}\r\n\r\n// Utility functions\r\nconst generateId = (): string => {\r\n  return Date.now().toString(36) + Math.random().toString(36).substr(2);\r\n};\r\n\r\nconst createPlayerCharacter = (\r\n  name: string,\r\n  characterData: CharacterState\r\n): PlayerCharacter => {\r\n  const now = new Date();\r\n  const playerId = generateId();\r\n\r\n  // Ensure characterData has the same ID as the PlayerCharacter\r\n  const characterDataWithId: CharacterState = {\r\n    ...characterData,\r\n    id: playerId,\r\n  };\r\n\r\n  return {\r\n    id: playerId,\r\n    name,\r\n    race: characterData.race || 'Human',\r\n    class: characterData.class?.name || 'Fighter',\r\n    level: characterData.level || 1,\r\n    createdAt: now,\r\n    updatedAt: now,\r\n    lastPlayed: now,\r\n    characterData: characterDataWithId,\r\n    avatar: characterData.avatar, // Extract avatar from character data\r\n    tags: [],\r\n    isArchived: false,\r\n  };\r\n};\r\n\r\n// Migration function\r\nconst migrateOldCharacterData = (): PlayerCharacter | null => {\r\n  try {\r\n    // Check for old character data\r\n    const oldCharacterData = localStorage.getItem(STORAGE_KEY);\r\n    console.log('Checking for old character data with key:', STORAGE_KEY);\r\n    console.log('Found old character data:', oldCharacterData ? 'YES' : 'NO');\r\n\r\n    if (!oldCharacterData) {\r\n      // Also check for any other rollkeeper keys\r\n      const allKeys = Object.keys(localStorage);\r\n      const rollkeeperKeys = allKeys.filter(key => key.includes('rollkeeper'));\r\n      console.log('All rollkeeper keys in localStorage:', rollkeeperKeys);\r\n      return null;\r\n    }\r\n\r\n    const parsedData = JSON.parse(oldCharacterData);\r\n    console.log(\r\n      'Parsed old character data structure:',\r\n      Object.keys(parsedData)\r\n    );\r\n\r\n    // Handle different data structures\r\n    let characterState: CharacterState;\r\n\r\n    if (parsedData.state) {\r\n      // Zustand persist format\r\n      characterState = parsedData.state as CharacterState;\r\n      console.log('Using Zustand persist format');\r\n    } else if (parsedData.character) {\r\n      // Direct character format\r\n      characterState = parsedData.character as CharacterState;\r\n      console.log('Using direct character format');\r\n    } else if (\r\n      parsedData.characterName ||\r\n      parsedData.race ||\r\n      parsedData.classInfo\r\n    ) {\r\n      // Direct character state\r\n      characterState = parsedData as CharacterState;\r\n      console.log('Using direct character state format');\r\n    } else {\r\n      console.log('Unrecognized old character data format');\r\n      return null;\r\n    }\r\n\r\n    // Create new character from old data\r\n    const characterName = characterState.name || 'Migrated Character';\r\n    const playerCharacter = createPlayerCharacter(\r\n      characterName,\r\n      characterState\r\n    );\r\n\r\n    // Mark as migrated\r\n    playerCharacter.tags = ['migrated'];\r\n\r\n    console.log('Successfully migrated character:', characterName);\r\n    return playerCharacter;\r\n  } catch (error) {\r\n    console.error('Failed to migrate old character data:', error);\r\n    console.error('Error details:', error);\r\n    return null;\r\n  }\r\n};\r\n\r\n// Store implementation\r\nexport const usePlayerStore = create<PlayerStoreState>()(\r\n  persist(\r\n    (set, get) => ({\r\n      // Initial state\r\n      characters: [],\r\n      activeCharacterId: null,\r\n      settings: { ...DEFAULT_PLAYER_SETTINGS },\r\n      lastSelectedCharacterId: null,\r\n\r\n      // Computed getters\r\n      getActiveCharacter: () => {\r\n        const { characters, activeCharacterId } = get();\r\n        return activeCharacterId\r\n          ? characters.find(c => c.id === activeCharacterId) || null\r\n          : null;\r\n      },\r\n\r\n      getCharacterById: (id: string) => {\r\n        const character = get().characters.find(c => c.id === id) || null;\r\n\r\n        // Ensure characterData has the correct ID (migration for existing characters)\r\n        if (character && !character.characterData.id) {\r\n          character.characterData.id = character.id;\r\n        }\r\n\r\n        return character;\r\n      },\r\n\r\n      getActiveCharacters: () => {\r\n        return get().characters.filter(c => !c.isArchived);\r\n      },\r\n\r\n      getArchivedCharacters: () => {\r\n        return get().characters.filter(c => c.isArchived);\r\n      },\r\n\r\n      // Character management\r\n      createCharacter: (name, partialCharacterData = {}) => {\r\n        const characterData: CharacterState = {\r\n          ...DEFAULT_CHARACTER_STATE,\r\n          ...partialCharacterData,\r\n          name: name,\r\n          id: generateId(),\r\n        };\r\n\r\n        const playerCharacter = createPlayerCharacter(name, characterData);\r\n\r\n        set(state => ({\r\n          characters: [...state.characters, playerCharacter],\r\n          activeCharacterId: playerCharacter.id,\r\n          lastSelectedCharacterId: playerCharacter.id,\r\n        }));\r\n\r\n        return playerCharacter.id;\r\n      },\r\n\r\n      updateCharacter: (characterId, updates) => {\r\n        set(state => ({\r\n          characters: state.characters.map(char =>\r\n            char.id === characterId\r\n              ? {\r\n                  ...char,\r\n                  ...updates,\r\n                  updatedAt: new Date(),\r\n                  lastPlayed:\r\n                    char.id === state.activeCharacterId\r\n                      ? new Date()\r\n                      : char.lastPlayed,\r\n                }\r\n              : char\r\n          ),\r\n        }));\r\n      },\r\n\r\n      updateCharacterData: (characterId, characterData) => {\r\n        set(state => ({\r\n          characters: state.characters.map(char =>\r\n            char.id === characterId\r\n              ? {\r\n                  ...char,\r\n                  characterData,\r\n                  name: characterData.name || char.name,\r\n                  race: characterData.race || char.race,\r\n                  class: characterData.class?.name || char.class,\r\n                  level:\r\n                    characterData.totalLevel ||\r\n                    characterData.level ||\r\n                    char.level,\r\n                  avatar: characterData.avatar, // Update top-level avatar from characterData\r\n                  updatedAt: new Date(),\r\n                  lastPlayed: new Date(),\r\n                }\r\n              : char\r\n          ),\r\n        }));\r\n      },\r\n\r\n      deleteCharacter: characterId => {\r\n        set(state => ({\r\n          characters: state.characters.filter(c => c.id !== characterId),\r\n          activeCharacterId:\r\n            state.activeCharacterId === characterId\r\n              ? null\r\n              : state.activeCharacterId,\r\n          lastSelectedCharacterId:\r\n            state.lastSelectedCharacterId === characterId\r\n              ? null\r\n              : state.lastSelectedCharacterId,\r\n        }));\r\n      },\r\n\r\n      archiveCharacter: characterId => {\r\n        set(state => ({\r\n          characters: state.characters.map(char =>\r\n            char.id === characterId\r\n              ? { ...char, isArchived: true, updatedAt: new Date() }\r\n              : char\r\n          ),\r\n          activeCharacterId:\r\n            state.activeCharacterId === characterId\r\n              ? null\r\n              : state.activeCharacterId,\r\n        }));\r\n      },\r\n\r\n      restoreCharacter: characterId => {\r\n        set(state => ({\r\n          characters: state.characters.map(char =>\r\n            char.id === characterId\r\n              ? { ...char, isArchived: false, updatedAt: new Date() }\r\n              : char\r\n          ),\r\n        }));\r\n      },\r\n\r\n      duplicateCharacter: (characterId, newName) => {\r\n        const originalCharacter = get().getCharacterById(characterId);\r\n        if (!originalCharacter) return '';\r\n\r\n        const duplicatedCharacterData = {\r\n          ...originalCharacter.characterData,\r\n          id: generateId(),\r\n          name: newName,\r\n        };\r\n\r\n        const newPlayerCharacter = createPlayerCharacter(\r\n          newName,\r\n          duplicatedCharacterData\r\n        );\r\n        newPlayerCharacter.tags = [...originalCharacter.tags, 'duplicate'];\r\n\r\n        set(state => ({\r\n          characters: [...state.characters, newPlayerCharacter],\r\n        }));\r\n\r\n        return newPlayerCharacter.id;\r\n      },\r\n\r\n      // Character selection\r\n      setActiveCharacter: characterId => {\r\n        // Update last played time when setting active\r\n        if (characterId) {\r\n          get().updateCharacter(characterId, { lastPlayed: new Date() });\r\n        }\r\n\r\n        set({\r\n          activeCharacterId: characterId,\r\n          lastSelectedCharacterId: characterId || get().lastSelectedCharacterId,\r\n        });\r\n      },\r\n\r\n      // Migration and utility\r\n      migrateFromOldStorage: () => {\r\n        const migratedCharacter = migrateOldCharacterData();\r\n        if (!migratedCharacter) return false;\r\n\r\n        set(state => ({\r\n          characters: [...state.characters, migratedCharacter],\r\n          activeCharacterId: migratedCharacter.id,\r\n          lastSelectedCharacterId: migratedCharacter.id,\r\n        }));\r\n\r\n        // Clean up old storage after successful migration\r\n        try {\r\n          localStorage.removeItem(STORAGE_KEY);\r\n          console.log('Cleaned up old character storage');\r\n        } catch (error) {\r\n          console.warn('Failed to clean up old storage:', error);\r\n        }\r\n\r\n        return true;\r\n      },\r\n\r\n      exportCharacter: characterId => {\r\n        return get().getCharacterById(characterId);\r\n      },\r\n\r\n      importCharacter: (data, name) => {\r\n        let characterState: CharacterState;\r\n        let playerCharacter: PlayerCharacter | undefined;\r\n\r\n        // Determine if it's CharacterExport or CharacterState\r\n        if ('character' in data && 'version' in data) {\r\n          // It's a CharacterExport\r\n          characterState = data.character;\r\n        } else if ('characterData' in data) {\r\n          // It's already a PlayerCharacter - extract characterData and rebuild\r\n          const existingPC = data as unknown as PlayerCharacter;\r\n          const characterName = name || existingPC.name || 'Imported Character';\r\n          playerCharacter = createPlayerCharacter(\r\n            characterName,\r\n            existingPC.characterData\r\n          );\r\n          playerCharacter.tags = existingPC.tags || ['imported'];\r\n          playerCharacter.isArchived = existingPC.isArchived || false;\r\n        } else {\r\n          // It's raw CharacterState\r\n          characterState = data as CharacterState;\r\n        }\r\n\r\n        // Create PlayerCharacter from CharacterState if needed\r\n        if (!playerCharacter) {\r\n          const characterName =\r\n            name || characterState!.name || 'Imported Character';\r\n          playerCharacter = createPlayerCharacter(\r\n            characterName,\r\n            characterState!\r\n          );\r\n          playerCharacter.tags = ['imported'];\r\n        }\r\n\r\n        set(state => ({\r\n          characters: [...state.characters, playerCharacter],\r\n        }));\r\n\r\n        return playerCharacter.id;\r\n      },\r\n\r\n      // Settings management\r\n      updateSettings: updates => {\r\n        set(state => ({\r\n          settings: { ...state.settings, ...updates },\r\n        }));\r\n      },\r\n\r\n      resetSettings: () => {\r\n        set({ settings: { ...DEFAULT_PLAYER_SETTINGS } });\r\n      },\r\n\r\n      resetStore: () => {\r\n        set({\r\n          characters: [],\r\n          activeCharacterId: null,\r\n          settings: { ...DEFAULT_PLAYER_SETTINGS },\r\n          lastSelectedCharacterId: null,\r\n        });\r\n      },\r\n    }),\r\n    {\r\n      name: PLAYER_STORAGE_KEY,\r\n      storage: createJSONStorage(() => localStorage),\r\n      version: 1,\r\n      // Migration function for future versions\r\n      migrate: (persistedState: unknown) => {\r\n        // Handle data migrations here when we update the schema\r\n        return persistedState;\r\n      },\r\n      onRehydrateStorage: () => {\r\n        return (state: PlayerStoreState | undefined) => {\r\n          // Auto-migrate on store initialization if needed\r\n          if (state && state.characters.length === 0) {\r\n            const migrated = state.migrateFromOldStorage();\r\n            if (migrated) {\r\n              console.log(\r\n                'Auto-migrated character from old storage on initialization'\r\n              );\r\n            }\r\n          }\r\n        };\r\n      },\r\n    }\r\n  )\r\n);\r\n\r\nexport default usePlayerStore;\r\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 349, "column": 0}, "map": {"version":3,"sources":["file:///home/irakli/Projects/RollKeeper/apps/web/src/store/characterStore.ts"],"sourcesContent":["import { create } from 'zustand';\r\nimport { persist, createJSONStorage } from 'zustand/middleware';\r\nimport {\r\n  CharacterState,\r\n  SaveStatus,\r\n  CharacterExport,\r\n  ClassInfo,\r\n  SpellSlots,\r\n  RichTextContent,\r\n  CharacterBackground,\r\n  Weapon,\r\n  TrackableTrait,\r\n  ExtendedFeature,\r\n  HeroicInspiration,\r\n  MagicItem,\r\n  ArmorItem,\r\n  InventoryItem,\r\n  ActiveCondition,\r\n  ActiveDisease,\r\n  ExhaustionVariant,\r\n  WeaponDamage,\r\n  DamageType,\r\n  ToolProficiency,\r\n  Language,\r\n} from '@/types/character';\r\nimport { ProcessedSpell } from '@/types/spells';\r\nimport {\r\n  DEFAULT_CHARACTER_STATE,\r\n  STORAGE_KEY,\r\n  APP_VERSION,\r\n  COMMON_CLASSES,\r\n} from '@/utils/constants';\r\nimport {\r\n  calculateSpellSlots,\r\n  calculatePactMagic,\r\n  calculateCharacterSpellSlots,\r\n  calculateCharacterPactMagic,\r\n  getCharacterTotalLevel,\r\n  updateSpellSlotsPreservingUsed,\r\n  calculateModifier,\r\n  calculateLevelFromXP,\r\n  getXPForLevel,\r\n  calculateTraitMaxUses,\r\n} from '@/utils/calculations';\r\nimport { migrateToMulticlass, calculateHitDicePools } from '@/utils/multiclass';\r\nimport {\r\n  applyDamage,\r\n  applyHealing,\r\n  addTemporaryHP,\r\n  makeDeathSave,\r\n  resetDeathSaves,\r\n  calculateMaxHP,\r\n  getClassHitDie,\r\n  isDead,\r\n} from '@/utils/hpCalculations';\r\nimport { usePlayerStore } from '@/store/playerStore';\r\n\r\n// Function to migrate weapon damage from old format to new array format\r\nfunction migrateWeaponDamage(weapon: Record<string, unknown>): Weapon {\r\n  // If the weapon already has the new damage array format, return as-is\r\n  if (Array.isArray(weapon.damage)) {\r\n    return weapon as unknown as Weapon;\r\n  }\r\n\r\n  // If the weapon has the old damage object format, convert it\r\n  const damage = weapon.damage as Record<string, unknown>;\r\n  if (\r\n    damage &&\r\n    typeof damage === 'object' &&\r\n    typeof damage.dice === 'string' &&\r\n    typeof damage.type === 'string'\r\n  ) {\r\n    const newDamage: WeaponDamage = {\r\n      dice: damage.dice,\r\n      type: damage.type as DamageType,\r\n      versatiledice: damage.versatiledice as string | undefined,\r\n      label: 'Weapon Damage', // Default label for migrated weapons\r\n    };\r\n\r\n    return {\r\n      ...weapon,\r\n      damage: [newDamage],\r\n      legacyDamage: damage, // Keep the old format for reference\r\n    } as unknown as Weapon;\r\n  }\r\n\r\n  // If no damage is defined, create a default empty array\r\n  return {\r\n    ...weapon,\r\n    damage: [],\r\n  } as unknown as Weapon;\r\n}\r\n\r\n// Migration function to handle old character data\r\nfunction migrateCharacterData(character: unknown): CharacterState {\r\n  // Type guard to check if character is an object\r\n  if (!character || typeof character !== 'object') {\r\n    return {\r\n      ...DEFAULT_CHARACTER_STATE,\r\n      id: generateId(),\r\n    };\r\n  }\r\n\r\n  const characterObj = character as Record<string, unknown>;\r\n\r\n  // If it's already a new character with class object, return as-is\r\n  if (characterObj.class && typeof characterObj.class === 'object') {\r\n    const result = character as CharacterState;\r\n    // Ensure spellSlots exist\r\n    if (!result.spellSlots) {\r\n      result.spellSlots = DEFAULT_CHARACTER_STATE.spellSlots;\r\n    }\r\n    // Ensure features and traits are arrays\r\n    if (!Array.isArray(result.features)) {\r\n      result.features = DEFAULT_CHARACTER_STATE.features;\r\n    }\r\n    if (!Array.isArray(result.traits)) {\r\n      result.traits = DEFAULT_CHARACTER_STATE.traits;\r\n    }\r\n    if (!Array.isArray(result.notes)) {\r\n      result.notes = DEFAULT_CHARACTER_STATE.notes;\r\n    }\r\n    // Ensure characterBackground exists\r\n    if (\r\n      !result.characterBackground ||\r\n      typeof result.characterBackground !== 'object' ||\r\n      !('backstory' in result.characterBackground)\r\n    ) {\r\n      result.characterBackground = DEFAULT_CHARACTER_STATE.characterBackground;\r\n    }\r\n    // Ensure weapons array exists\r\n    if (!Array.isArray(result.weapons)) {\r\n      result.weapons = DEFAULT_CHARACTER_STATE.weapons;\r\n    }\r\n    // Ensure weapon proficiencies exist\r\n    if (\r\n      !result.weaponProficiencies ||\r\n      typeof result.weaponProficiencies !== 'object'\r\n    ) {\r\n      result.weaponProficiencies = DEFAULT_CHARACTER_STATE.weaponProficiencies;\r\n    }\r\n    // Ensure spells array exists\r\n    if (!Array.isArray(result.spells)) {\r\n      result.spells = DEFAULT_CHARACTER_STATE.spells;\r\n    }\r\n    // Ensure spellcasting stats exist\r\n    if (\r\n      !result.spellcastingStats ||\r\n      typeof result.spellcastingStats !== 'object'\r\n    ) {\r\n      result.spellcastingStats = DEFAULT_CHARACTER_STATE.spellcastingStats;\r\n    }\r\n    // Ensure class has hitDie\r\n    if (\r\n      result.class &&\r\n      typeof result.class === 'object' &&\r\n      !('hitDie' in result.class)\r\n    ) {\r\n      (result.class as Record<string, unknown>).hitDie = 8; // Default to d8\r\n    }\r\n    // Ensure hitPoints has new properties\r\n    if (result.hitPoints && typeof result.hitPoints === 'object') {\r\n      if (!('calculationMode' in result.hitPoints)) {\r\n        (result.hitPoints as Record<string, unknown>).calculationMode = 'auto';\r\n      }\r\n    }\r\n    // Ensure reaction tracking exists\r\n    if (!result.reaction || typeof result.reaction !== 'object') {\r\n      result.reaction = DEFAULT_CHARACTER_STATE.reaction;\r\n    }\r\n    // Ensure heroic inspiration exists\r\n    if (\r\n      !result.heroicInspiration ||\r\n      typeof result.heroicInspiration !== 'object'\r\n    ) {\r\n      result.heroicInspiration = DEFAULT_CHARACTER_STATE.heroicInspiration;\r\n    }\r\n    // Ensure temporary AC field exists\r\n    if (typeof result.tempArmorClass !== 'number') {\r\n      result.tempArmorClass = DEFAULT_CHARACTER_STATE.tempArmorClass;\r\n    }\r\n    // Ensure shield status exists\r\n    if (typeof result.isWearingShield !== 'boolean') {\r\n      result.isWearingShield = DEFAULT_CHARACTER_STATE.isWearingShield;\r\n    }\r\n    // Ensure shield bonus exists\r\n    if (typeof result.shieldBonus !== 'number') {\r\n      result.shieldBonus = DEFAULT_CHARACTER_STATE.shieldBonus;\r\n    }\r\n    // Ensure magic items exist\r\n    if (!Array.isArray(result.magicItems)) {\r\n      result.magicItems = DEFAULT_CHARACTER_STATE.magicItems;\r\n    }\r\n    // Ensure attunement slots exist\r\n    if (!result.attunementSlots || typeof result.attunementSlots !== 'object') {\r\n      result.attunementSlots = DEFAULT_CHARACTER_STATE.attunementSlots;\r\n    }\r\n    // Ensure armor items exist\r\n    if (!Array.isArray(result.armorItems)) {\r\n      result.armorItems = DEFAULT_CHARACTER_STATE.armorItems;\r\n    }\r\n    // Ensure inventory items exist\r\n    if (!Array.isArray(result.inventoryItems)) {\r\n      result.inventoryItems = DEFAULT_CHARACTER_STATE.inventoryItems;\r\n    }\r\n    // Ensure currency exists\r\n    if (!result.currency || typeof result.currency !== 'object') {\r\n      result.currency = DEFAULT_CHARACTER_STATE.currency;\r\n    }\r\n    // Ensure spellbook exists\r\n    if (!result.spellbook || typeof result.spellbook !== 'object') {\r\n      result.spellbook = DEFAULT_CHARACTER_STATE.spellbook;\r\n    }\r\n    // Ensure concentration tracking exists\r\n    if (!result.concentration || typeof result.concentration !== 'object') {\r\n      result.concentration = DEFAULT_CHARACTER_STATE.concentration;\r\n    }\r\n    // Ensure conditions and diseases tracking exists\r\n    if (\r\n      !result.conditionsAndDiseases ||\r\n      typeof result.conditionsAndDiseases !== 'object'\r\n    ) {\r\n      result.conditionsAndDiseases =\r\n        DEFAULT_CHARACTER_STATE.conditionsAndDiseases;\r\n    }\r\n    // Ensure daysSpent tracking exists\r\n    if (typeof result.daysSpent !== 'number') {\r\n      result.daysSpent = DEFAULT_CHARACTER_STATE.daysSpent;\r\n    }\r\n    return result;\r\n  }\r\n\r\n  // Migrate old character with string class to new format\r\n  const migratedCharacter: CharacterState = {\r\n    id: generateId(),\r\n    ...DEFAULT_CHARACTER_STATE,\r\n    ...(characterObj as Partial<CharacterState>),\r\n    class: {\r\n      name:\r\n        characterObj.class && typeof characterObj.class === 'string'\r\n          ? characterObj.class\r\n          : '',\r\n      isCustom: false,\r\n      spellcaster: 'none' as const,\r\n      hitDie: 8, // Default to d8\r\n    },\r\n    spellSlots: DEFAULT_CHARACTER_STATE.spellSlots,\r\n    pactMagic: undefined,\r\n    features: Array.isArray(characterObj.features)\r\n      ? characterObj.features\r\n      : DEFAULT_CHARACTER_STATE.features,\r\n    traits: Array.isArray(characterObj.traits)\r\n      ? characterObj.traits\r\n      : DEFAULT_CHARACTER_STATE.traits,\r\n    characterBackground:\r\n      characterObj.characterBackground &&\r\n      typeof characterObj.characterBackground === 'object' &&\r\n      'backstory' in characterObj.characterBackground\r\n        ? (characterObj.characterBackground as CharacterState['characterBackground'])\r\n        : DEFAULT_CHARACTER_STATE.characterBackground,\r\n    weapons: Array.isArray(characterObj.weapons)\r\n      ? (characterObj.weapons as Record<string, unknown>[]).map(\r\n          migrateWeaponDamage\r\n        )\r\n      : DEFAULT_CHARACTER_STATE.weapons,\r\n    weaponProficiencies:\r\n      characterObj.weaponProficiencies &&\r\n      typeof characterObj.weaponProficiencies === 'object'\r\n        ? (characterObj.weaponProficiencies as CharacterState['weaponProficiencies'])\r\n        : DEFAULT_CHARACTER_STATE.weaponProficiencies,\r\n    jackOfAllTrades:\r\n      characterObj.jackOfAllTrades &&\r\n      typeof characterObj.jackOfAllTrades === 'boolean'\r\n        ? characterObj.jackOfAllTrades\r\n        : DEFAULT_CHARACTER_STATE.jackOfAllTrades,\r\n  };\r\n\r\n  // Try to detect spellcaster type from class name\r\n  if (characterObj.class && typeof characterObj.class === 'string') {\r\n    const className = characterObj.class;\r\n    const matchingClass = COMMON_CLASSES.find(\r\n      c => c.name.toLowerCase() === className.toLowerCase()\r\n    );\r\n    if (matchingClass) {\r\n      migratedCharacter.class = {\r\n        name: matchingClass.name,\r\n        isCustom: false,\r\n        spellcaster: matchingClass.spellcaster,\r\n        hitDie: matchingClass.hitDie,\r\n      };\r\n\r\n      // Calculate initial spell slots\r\n      const level =\r\n        characterObj.level && typeof characterObj.level === 'number'\r\n          ? characterObj.level\r\n          : 1;\r\n      migratedCharacter.spellSlots = calculateSpellSlots(\r\n        migratedCharacter.class,\r\n        level\r\n      );\r\n\r\n      // Add pact magic for warlocks\r\n      if (matchingClass.spellcaster === 'warlock') {\r\n        migratedCharacter.pactMagic = calculatePactMagic(level);\r\n      }\r\n    } else {\r\n      // Unknown class, mark as custom\r\n      migratedCharacter.class = {\r\n        name: typeof characterObj.class === 'string' ? characterObj.class : '',\r\n        isCustom: true,\r\n        spellcaster: 'none',\r\n        hitDie: 8, // Default to d8 for custom classes\r\n      };\r\n    }\r\n  }\r\n\r\n  return migratedCharacter;\r\n}\r\n\r\ninterface CharacterStore {\r\n  // Character data\r\n  character: CharacterState;\r\n\r\n  // UI state\r\n  saveStatus: SaveStatus;\r\n  lastSaved: Date | string | null; // Can be string when rehydrated from localStorage\r\n  hasUnsavedChanges: boolean;\r\n  hasHydrated: boolean;\r\n  showDeathAnimation: boolean;\r\n  showLevelUpAnimation: boolean;\r\n  levelUpAnimationLevel: number;\r\n\r\n  // Actions\r\n  updateCharacter: (updates: Partial<CharacterState>) => void;\r\n  loadCharacterState: (characterState: CharacterState) => void;\r\n  updateAbilityScore: (\r\n    ability: keyof CharacterState['abilities'],\r\n    value: number\r\n  ) => void;\r\n  updateSkillProficiency: (\r\n    skill: keyof CharacterState['skills'],\r\n    proficient: boolean\r\n  ) => void;\r\n  updateSkillExpertise: (\r\n    skill: keyof CharacterState['skills'],\r\n    expertise: boolean\r\n  ) => void;\r\n  updateSavingThrowProficiency: (\r\n    ability: keyof CharacterState['savingThrows'],\r\n    proficient: boolean\r\n  ) => void;\r\n  updateHitPoints: (updates: Partial<CharacterState['hitPoints']>) => void;\r\n  updateInitiative: (value: number, isOverride: boolean) => void;\r\n  resetInitiativeToDefault: () => void;\r\n\r\n  // Reaction management\r\n  toggleReaction: () => void;\r\n  resetReaction: () => void;\r\n\r\n  // Class Features\r\n  toggleJackOfAllTrades: () => void;\r\n\r\n  // Heroic inspiration management\r\n  updateHeroicInspiration: (updates: Partial<HeroicInspiration>) => void;\r\n  addHeroicInspiration: (amount?: number) => void;\r\n  useHeroicInspiration: () => void;\r\n  resetHeroicInspiration: () => void;\r\n\r\n  // Armor Class management\r\n  updateTempArmorClass: (tempAC: number) => void;\r\n  toggleShield: () => void;\r\n  resetTempArmorClass: () => void;\r\n  updateShieldBonus: (bonus: number) => void;\r\n\r\n  // HP management actions\r\n  applyDamageToCharacter: (damage: number) => void;\r\n  applyHealingToCharacter: (healing: number) => void;\r\n  addTemporaryHPToCharacter: (tempHP: number) => void;\r\n  makeDeathSavingThrow: (isSuccess: boolean, isCritical?: boolean) => void;\r\n  resetDeathSavingThrows: () => void;\r\n  toggleHPCalculationMode: () => void;\r\n  recalculateMaxHP: () => void;\r\n  clearDeathAnimation: () => void;\r\n  clearLevelUpAnimation: () => void;\r\n\r\n  // Class and spell management\r\n  updateClass: (classInfo: ClassInfo) => void;\r\n  updateLevel: (level: number) => void;\r\n  updateSpellSlot: (level: keyof SpellSlots, used: number) => void;\r\n  updatePactMagicSlot: (used: number) => void;\r\n  resetSpellSlots: () => void;\r\n  resetPactMagicSlots: () => void;\r\n\r\n  // Multiclass management\r\n  addClassLevel: (\r\n    className: string,\r\n    isCustom?: boolean,\r\n    spellcaster?: 'full' | 'half' | 'third' | 'warlock' | 'none',\r\n    hitDie?: number,\r\n    subclass?: string\r\n  ) => void;\r\n  removeClassLevel: (className: string) => void;\r\n  updateClassLevel: (className: string, newLevel: number) => void;\r\n  isMulticlassed: () => boolean;\r\n  getClassDisplayString: () => string;\r\n\r\n  // Hit dice management\r\n  useHitDie: (dieType: string, count?: number) => void;\r\n  restoreHitDice: (dieType: string, count?: number) => void;\r\n  resetAllHitDice: () => void;\r\n\r\n  // Concentration management\r\n  startConcentration: (\r\n    spellName: string,\r\n    spellId?: string,\r\n    castAt?: number\r\n  ) => void;\r\n  stopConcentration: () => void;\r\n  isConcentratingOn: (spellName: string) => boolean;\r\n\r\n  // Conditions and diseases management\r\n  addCondition: (\r\n    conditionName: string,\r\n    source: string,\r\n    description: string,\r\n    count?: number,\r\n    notes?: string\r\n  ) => void;\r\n  updateCondition: (\r\n    conditionId: string,\r\n    updates: Partial<Pick<ActiveCondition, 'count' | 'notes'>>\r\n  ) => void;\r\n  removeCondition: (conditionId: string) => void;\r\n  addDisease: (\r\n    diseaseName: string,\r\n    source: string,\r\n    description: string,\r\n    onsetTime?: string,\r\n    notes?: string\r\n  ) => void;\r\n  updateDisease: (\r\n    diseaseId: string,\r\n    updates: Partial<Pick<ActiveDisease, 'onsetTime' | 'notes'>>\r\n  ) => void;\r\n  removeDisease: (diseaseId: string) => void;\r\n  setExhaustionVariant: (variant: ExhaustionVariant) => void;\r\n  clearAllConditions: () => void;\r\n  clearAllDiseases: () => void;\r\n\r\n  // XP management\r\n  addExperience: (xpToAdd: number) => void;\r\n  setExperience: (newXP: number) => void;\r\n\r\n  // Rich text content management\r\n  addFeature: (\r\n    feature: Omit<RichTextContent, 'id' | 'createdAt' | 'updatedAt'>\r\n  ) => void;\r\n  updateFeature: (id: string, updates: Partial<RichTextContent>) => void;\r\n  deleteFeature: (id: string) => void;\r\n  addTrait: (\r\n    trait: Omit<RichTextContent, 'id' | 'createdAt' | 'updatedAt'>\r\n  ) => void;\r\n  updateTrait: (id: string, updates: Partial<RichTextContent>) => void;\r\n  deleteTrait: (id: string) => void;\r\n  addNote: (\r\n    note: Omit<RichTextContent, 'id' | 'createdAt' | 'updatedAt'>\r\n  ) => void;\r\n  updateNote: (id: string, updates: Partial<RichTextContent>) => void;\r\n  deleteNote: (id: string) => void;\r\n  reorderNotes: (sourceIndex: number, destinationIndex: number) => void;\r\n\r\n  // Trackable trait management\r\n  addTrackableTrait: (\r\n    trait: Omit<TrackableTrait, 'id' | 'createdAt' | 'updatedAt'>\r\n  ) => void;\r\n  updateTrackableTrait: (id: string, updates: Partial<TrackableTrait>) => void;\r\n  deleteTrackableTrait: (id: string) => void;\r\n  useTrackableTrait: (id: string) => void;\r\n  resetTrackableTraits: (restType: 'short' | 'long') => void;\r\n\r\n  // Extended feature management\r\n  addExtendedFeature: (\r\n    feature: Omit<ExtendedFeature, 'id' | 'createdAt' | 'updatedAt'>\r\n  ) => void;\r\n  updateExtendedFeature: (\r\n    id: string,\r\n    updates: Partial<ExtendedFeature>\r\n  ) => void;\r\n  deleteExtendedFeature: (id: string) => void;\r\n  useExtendedFeature: (id: string) => void;\r\n  resetExtendedFeatures: (restType: 'short' | 'long') => void;\r\n  reorderExtendedFeatures: (\r\n    sourceIndex: number,\r\n    destinationIndex: number,\r\n    sourceType?: string\r\n  ) => void;\r\n  migrateTraitsToExtendedFeatures: () => void;\r\n\r\n  // Language management\r\n  addLanguage: (\r\n    language: Omit<Language, 'id' | 'createdAt' | 'updatedAt'>\r\n  ) => void;\r\n  deleteLanguage: (id: string) => void;\r\n\r\n  // Tool proficiency management\r\n  addToolProficiency: (\r\n    tool: Omit<ToolProficiency, 'id' | 'createdAt' | 'updatedAt'>\r\n  ) => void;\r\n  updateToolProficiency: (\r\n    id: string,\r\n    updates: Partial<ToolProficiency>\r\n  ) => void;\r\n  deleteToolProficiency: (id: string) => void;\r\n\r\n  // Rest management (centralized)\r\n  takeShortRest: () => void; // Resets all short rest abilities, pact magic, reaction\r\n  takeLongRest: () => void; // Resets everything: all abilities, all spell slots, hit dice, HP, etc.\r\n\r\n  // Campaign tracking\r\n  updateDaysSpent: (days: number) => void; // Set days spent directly\r\n  incrementDaysSpent: (amount?: number) => void; // Add days (default: 1)\r\n\r\n  updateCharacterBackground: (updates: Partial<CharacterBackground>) => void;\r\n\r\n  // Weapon management\r\n  addWeapon: (weapon: Omit<Weapon, 'id' | 'createdAt' | 'updatedAt'>) => void;\r\n  updateWeapon: (id: string, updates: Partial<Weapon>) => void;\r\n  deleteWeapon: (id: string) => void;\r\n  equipWeapon: (id: string, equipped: boolean) => void;\r\n  reorderWeapons: (sourceIndex: number, destinationIndex: number) => void;\r\n\r\n  // Magic item management\r\n  addMagicItem: (\r\n    item: Omit<MagicItem, 'id' | 'createdAt' | 'updatedAt'>\r\n  ) => void;\r\n  updateMagicItem: (id: string, updates: Partial<MagicItem>) => void;\r\n  deleteMagicItem: (id: string) => void;\r\n  attuneMagicItem: (id: string, attuned: boolean) => void;\r\n  updateAttunementSlots: (max: number) => void;\r\n  reorderMagicItems: (sourceIndex: number, destinationIndex: number) => void;\r\n\r\n  // Armor management\r\n  addArmorItem: (\r\n    item: Omit<ArmorItem, 'id' | 'createdAt' | 'updatedAt'>\r\n  ) => void;\r\n  updateArmorItem: (id: string, updates: Partial<ArmorItem>) => void;\r\n  deleteArmorItem: (id: string) => void;\r\n  equipArmorItem: (id: string, equipped: boolean) => void;\r\n  reorderArmorItems: (sourceIndex: number, destinationIndex: number) => void;\r\n\r\n  // Inventory management\r\n  addInventoryItem: (\r\n    item: Omit<InventoryItem, 'id' | 'createdAt' | 'updatedAt'>\r\n  ) => void;\r\n  updateInventoryItem: (id: string, updates: Partial<InventoryItem>) => void;\r\n  deleteInventoryItem: (id: string) => void;\r\n  updateItemQuantity: (id: string, quantity: number) => void;\r\n  reorderInventoryItems: (\r\n    sourceIndex: number,\r\n    destinationIndex: number\r\n  ) => void;\r\n\r\n  // Currency management\r\n  updateCurrency: (\r\n    updates: Partial<typeof DEFAULT_CHARACTER_STATE.currency>\r\n  ) => void;\r\n  addCurrency: (\r\n    type: keyof typeof DEFAULT_CHARACTER_STATE.currency,\r\n    amount: number\r\n  ) => void;\r\n  subtractCurrency: (\r\n    type: keyof typeof DEFAULT_CHARACTER_STATE.currency,\r\n    amount: number\r\n  ) => void;\r\n\r\n  // Spellbook management\r\n  addSpellToSpellbook: (spellId: string) => void;\r\n  removeSpellFromSpellbook: (spellId: string) => void;\r\n  toggleSpellFavorite: (spellId: string) => void;\r\n  prepareSpell: (spellId: string) => void;\r\n  unprepareSpell: (spellId: string) => void;\r\n  updateSpellbookSettings: (\r\n    settings: Partial<\r\n      typeof DEFAULT_CHARACTER_STATE.spellbook.spellbookSettings\r\n    >\r\n  ) => void;\r\n  addCustomSpell: (spell: ProcessedSpell) => void; // We'll type this properly later\r\n  removeCustomSpell: (spellId: string) => void;\r\n  reorderPreparedSpells: (\r\n    sourceIndex: number,\r\n    destinationIndex: number\r\n  ) => void;\r\n  reorderSpells: (sourceIndex: number, destinationIndex: number) => void;\r\n\r\n  // Persistence actions\r\n  saveCharacter: () => void;\r\n  loadCharacter: (character: CharacterState) => void;\r\n  resetCharacter: () => void;\r\n  exportCharacter: () => CharacterExport;\r\n  importCharacter: (exportData: CharacterExport) => boolean;\r\n\r\n  // Auto-save control\r\n  setSaveStatus: (status: SaveStatus) => void;\r\n  markSaved: () => void;\r\n  markUnsaved: () => void;\r\n}\r\n\r\n// Utility function to generate unique IDs\r\nconst generateId = () =>\r\n  Date.now().toString(36) + Math.random().toString(36).substr(2);\r\n\r\nexport const useCharacterStore = create<CharacterStore>()(\r\n  persist(\r\n    (set, get) => ({\r\n      // Initial state\r\n      character: {\r\n        ...DEFAULT_CHARACTER_STATE,\r\n        id: generateId(),\r\n      },\r\n      saveStatus: 'saved',\r\n      lastSaved: null,\r\n      hasUnsavedChanges: false,\r\n      hasHydrated: false,\r\n      showDeathAnimation: false,\r\n      showLevelUpAnimation: false,\r\n      levelUpAnimationLevel: 1,\r\n\r\n      // Character update actions\r\n      updateCharacter: updates => {\r\n        set(state => ({\r\n          character: { ...state.character, ...updates },\r\n          hasUnsavedChanges: true,\r\n          saveStatus: 'saving',\r\n        }));\r\n      },\r\n\r\n      loadCharacterState: characterState => {\r\n        const migratedCharacter = migrateCharacterData(characterState);\r\n        const multiclassCharacter = migrateToMulticlass(migratedCharacter);\r\n        set({\r\n          character: multiclassCharacter,\r\n          hasUnsavedChanges: false,\r\n          saveStatus: 'saved',\r\n          lastSaved: new Date(),\r\n        });\r\n      },\r\n\r\n      updateAbilityScore: (ability, value) => {\r\n        set(state => {\r\n          const newAbilities = {\r\n            ...state.character.abilities,\r\n            [ability]: Math.max(1, Math.min(30, value)),\r\n          };\r\n\r\n          // Auto-update initiative if it's not overridden and dexterity changed\r\n          let initiative = state.character.initiative;\r\n          if (ability === 'dexterity' && !initiative.isOverridden) {\r\n            initiative = {\r\n              ...initiative,\r\n              value: calculateModifier(newAbilities.dexterity),\r\n            };\r\n          }\r\n\r\n          return {\r\n            character: {\r\n              ...state.character,\r\n              abilities: newAbilities,\r\n              initiative,\r\n            },\r\n            hasUnsavedChanges: true,\r\n            saveStatus: 'saving',\r\n          };\r\n        });\r\n      },\r\n\r\n      updateSkillProficiency: (skill, proficient) => {\r\n        set(state => ({\r\n          character: {\r\n            ...state.character,\r\n            skills: {\r\n              ...state.character.skills,\r\n              [skill]: {\r\n                ...state.character.skills[skill],\r\n                proficient,\r\n              },\r\n            },\r\n          },\r\n          hasUnsavedChanges: true,\r\n          saveStatus: 'saving',\r\n        }));\r\n      },\r\n\r\n      updateSkillExpertise: (skill, expertise) => {\r\n        set(state => ({\r\n          character: {\r\n            ...state.character,\r\n            skills: {\r\n              ...state.character.skills,\r\n              [skill]: {\r\n                ...state.character.skills[skill],\r\n                expertise,\r\n              },\r\n            },\r\n          },\r\n          hasUnsavedChanges: true,\r\n          saveStatus: 'saving',\r\n        }));\r\n      },\r\n\r\n      updateSavingThrowProficiency: (ability, proficient) => {\r\n        set(state => ({\r\n          character: {\r\n            ...state.character,\r\n            savingThrows: {\r\n              ...state.character.savingThrows,\r\n              [ability]: {\r\n                ...state.character.savingThrows[ability],\r\n                proficient,\r\n              },\r\n            },\r\n          },\r\n          hasUnsavedChanges: true,\r\n          saveStatus: 'saving',\r\n        }));\r\n      },\r\n\r\n      updateHitPoints: updates => {\r\n        set(state => ({\r\n          character: {\r\n            ...state.character,\r\n            hitPoints: {\r\n              ...state.character.hitPoints,\r\n              ...updates,\r\n            },\r\n          },\r\n          hasUnsavedChanges: true,\r\n          saveStatus: 'saving',\r\n        }));\r\n      },\r\n\r\n      updateInitiative: (value, isOverride) => {\r\n        set(state => ({\r\n          character: {\r\n            ...state.character,\r\n            initiative: {\r\n              value,\r\n              isOverridden: isOverride,\r\n            },\r\n          },\r\n          hasUnsavedChanges: true,\r\n          saveStatus: 'saving',\r\n        }));\r\n      },\r\n\r\n      resetInitiativeToDefault: () => {\r\n        set(state => ({\r\n          character: {\r\n            ...state.character,\r\n            initiative: {\r\n              value: calculateModifier(state.character.abilities.dexterity),\r\n              isOverridden: false,\r\n            },\r\n          },\r\n          hasUnsavedChanges: true,\r\n          saveStatus: 'saving',\r\n        }));\r\n      },\r\n\r\n      // Reaction management actions\r\n      toggleReaction: () => {\r\n        set(state => ({\r\n          character: {\r\n            ...state.character,\r\n            reaction: {\r\n              hasUsedReaction: !state.character.reaction.hasUsedReaction,\r\n            },\r\n          },\r\n          hasUnsavedChanges: true,\r\n          saveStatus: 'saving',\r\n        }));\r\n      },\r\n\r\n      resetReaction: () => {\r\n        set(state => ({\r\n          character: {\r\n            ...state.character,\r\n            reaction: {\r\n              hasUsedReaction: false,\r\n            },\r\n          },\r\n          hasUnsavedChanges: true,\r\n          saveStatus: 'saving',\r\n        }));\r\n      },\r\n\r\n      // Class Features actions\r\n      toggleJackOfAllTrades: () => {\r\n        set(state => ({\r\n          character: {\r\n            ...state.character,\r\n            jackOfAllTrades: !state.character.jackOfAllTrades,\r\n          },\r\n          hasUnsavedChanges: true,\r\n          saveStatus: 'saving',\r\n        }));\r\n      },\r\n\r\n      // Heroic inspiration management actions\r\n      updateHeroicInspiration: updates => {\r\n        set(state => ({\r\n          character: {\r\n            ...state.character,\r\n            heroicInspiration: {\r\n              ...state.character.heroicInspiration,\r\n              ...updates,\r\n            },\r\n          },\r\n          hasUnsavedChanges: true,\r\n          saveStatus: 'saving',\r\n        }));\r\n      },\r\n\r\n      addHeroicInspiration: (amount = 1) => {\r\n        set(state => {\r\n          const current = state.character.heroicInspiration.count;\r\n          const max = state.character.heroicInspiration.maxCount;\r\n          const newCount = max\r\n            ? Math.min(current + amount, max)\r\n            : current + amount;\r\n\r\n          return {\r\n            character: {\r\n              ...state.character,\r\n              heroicInspiration: {\r\n                ...state.character.heroicInspiration,\r\n                count: Math.max(0, newCount),\r\n              },\r\n            },\r\n            hasUnsavedChanges: true,\r\n            saveStatus: 'saving',\r\n          };\r\n        });\r\n      },\r\n\r\n      useHeroicInspiration: () => {\r\n        set(state => ({\r\n          character: {\r\n            ...state.character,\r\n            heroicInspiration: {\r\n              ...state.character.heroicInspiration,\r\n              count: Math.max(0, state.character.heroicInspiration.count - 1),\r\n            },\r\n          },\r\n          hasUnsavedChanges: true,\r\n          saveStatus: 'saving',\r\n        }));\r\n      },\r\n\r\n      resetHeroicInspiration: () => {\r\n        set(state => ({\r\n          character: {\r\n            ...state.character,\r\n            heroicInspiration: {\r\n              ...state.character.heroicInspiration,\r\n              count: 0,\r\n            },\r\n          },\r\n          hasUnsavedChanges: true,\r\n          saveStatus: 'saving',\r\n        }));\r\n      },\r\n\r\n      // Armor Class management\r\n      updateTempArmorClass: tempAC => {\r\n        set(state => ({\r\n          character: {\r\n            ...state.character,\r\n            tempArmorClass: tempAC,\r\n          },\r\n          hasUnsavedChanges: true,\r\n          saveStatus: 'saving',\r\n        }));\r\n      },\r\n\r\n      toggleShield: () => {\r\n        set(state => ({\r\n          character: {\r\n            ...state.character,\r\n            isWearingShield: !state.character.isWearingShield,\r\n          },\r\n          hasUnsavedChanges: true,\r\n          saveStatus: 'saving',\r\n        }));\r\n      },\r\n\r\n      resetTempArmorClass: () => {\r\n        set(state => ({\r\n          character: {\r\n            ...state.character,\r\n            tempArmorClass: 0,\r\n          },\r\n          hasUnsavedChanges: true,\r\n          saveStatus: 'saving',\r\n        }));\r\n      },\r\n\r\n      updateShieldBonus: bonus => {\r\n        set(state => ({\r\n          character: {\r\n            ...state.character,\r\n            shieldBonus: bonus,\r\n          },\r\n          hasUnsavedChanges: true,\r\n          saveStatus: 'saving',\r\n        }));\r\n      },\r\n\r\n      // HP management actions\r\n      applyDamageToCharacter: damage => {\r\n        const state = get();\r\n        const wasDeadBefore = isDead(state.character.hitPoints);\r\n        const newHitPoints = applyDamage(state.character.hitPoints, damage);\r\n        const isDeadAfter = isDead(newHitPoints);\r\n\r\n        // Check if death animation is enabled in player settings\r\n        const playerSettings = usePlayerStore.getState().settings;\r\n        const shouldShowDeathAnimation =\r\n          playerSettings.enableDeathAnimation && !wasDeadBefore && isDeadAfter;\r\n\r\n        set({\r\n          character: {\r\n            ...state.character,\r\n            hitPoints: newHitPoints,\r\n          },\r\n          hasUnsavedChanges: true,\r\n          saveStatus: 'saving',\r\n          showDeathAnimation: shouldShowDeathAnimation\r\n            ? true\r\n            : state.showDeathAnimation,\r\n        });\r\n\r\n        // Auto-clear the death animation after 8.5 seconds\r\n        if (shouldShowDeathAnimation) {\r\n          setTimeout(() => {\r\n            set({ showDeathAnimation: false });\r\n          }, 8500);\r\n        }\r\n      },\r\n\r\n      applyHealingToCharacter: healing => {\r\n        set(state => ({\r\n          character: {\r\n            ...state.character,\r\n            hitPoints: applyHealing(state.character.hitPoints, healing),\r\n          },\r\n          hasUnsavedChanges: true,\r\n          saveStatus: 'saving',\r\n        }));\r\n      },\r\n\r\n      addTemporaryHPToCharacter: tempHP => {\r\n        set(state => ({\r\n          character: {\r\n            ...state.character,\r\n            hitPoints: addTemporaryHP(state.character.hitPoints, tempHP),\r\n          },\r\n          hasUnsavedChanges: true,\r\n          saveStatus: 'saving',\r\n        }));\r\n      },\r\n\r\n      makeDeathSavingThrow: (isSuccess, isCritical = false) => {\r\n        const state = get();\r\n        const wasDeadBefore = isDead(state.character.hitPoints);\r\n        const newHitPoints = makeDeathSave(\r\n          state.character.hitPoints,\r\n          isSuccess,\r\n          isCritical\r\n        );\r\n        const isDeadAfter = isDead(newHitPoints);\r\n\r\n        // Check if death animation is enabled in player settings\r\n        const playerSettings = usePlayerStore.getState().settings;\r\n        const shouldShowDeathAnimation =\r\n          playerSettings.enableDeathAnimation && !wasDeadBefore && isDeadAfter;\r\n\r\n        set({\r\n          character: {\r\n            ...state.character,\r\n            hitPoints: newHitPoints,\r\n          },\r\n          hasUnsavedChanges: true,\r\n          saveStatus: 'saving',\r\n          showDeathAnimation: shouldShowDeathAnimation\r\n            ? true\r\n            : state.showDeathAnimation,\r\n        });\r\n\r\n        if (shouldShowDeathAnimation) {\r\n          setTimeout(() => {\r\n            set({ showDeathAnimation: false });\r\n          }, 8500);\r\n        }\r\n      },\r\n\r\n      resetDeathSavingThrows: () => {\r\n        set(state => ({\r\n          character: {\r\n            ...state.character,\r\n            hitPoints: resetDeathSaves(state.character.hitPoints),\r\n          },\r\n          hasUnsavedChanges: true,\r\n          saveStatus: 'saving',\r\n        }));\r\n      },\r\n\r\n      clearDeathAnimation: () => {\r\n        set({ showDeathAnimation: false });\r\n      },\r\n\r\n      clearLevelUpAnimation: () => {\r\n        set({ showLevelUpAnimation: false });\r\n      },\r\n\r\n      toggleHPCalculationMode: () => {\r\n        set(state => {\r\n          const newMode =\r\n            state.character.hitPoints.calculationMode === 'auto'\r\n              ? 'manual'\r\n              : 'auto';\r\n          let newMaxHP = state.character.hitPoints.max;\r\n\r\n          // If switching to auto mode, recalculate max HP\r\n          if (newMode === 'auto') {\r\n            const hitDie = getClassHitDie(\r\n              state.character.class.name,\r\n              state.character.class.hitDie\r\n            );\r\n            newMaxHP = calculateMaxHP(\r\n              { ...state.character.class, hitDie },\r\n              state.character.level,\r\n              state.character.abilities.constitution\r\n            );\r\n          }\r\n\r\n          return {\r\n            character: {\r\n              ...state.character,\r\n              hitPoints: {\r\n                ...state.character.hitPoints,\r\n                calculationMode: newMode,\r\n                max: newMaxHP,\r\n                manualMaxOverride:\r\n                  newMode === 'manual'\r\n                    ? state.character.hitPoints.max\r\n                    : undefined,\r\n              },\r\n            },\r\n            hasUnsavedChanges: true,\r\n            saveStatus: 'saving',\r\n          };\r\n        });\r\n      },\r\n\r\n      recalculateMaxHP: () => {\r\n        set(state => {\r\n          if (state.character.hitPoints.calculationMode === 'manual') {\r\n            return state; // Don't recalculate in manual mode\r\n          }\r\n\r\n          const hitDie = getClassHitDie(\r\n            state.character.class.name,\r\n            state.character.class.hitDie\r\n          );\r\n          const newMaxHP = calculateMaxHP(\r\n            { ...state.character.class, hitDie },\r\n            state.character.level,\r\n            state.character.abilities.constitution\r\n          );\r\n\r\n          return {\r\n            character: {\r\n              ...state.character,\r\n              hitPoints: {\r\n                ...state.character.hitPoints,\r\n                max: newMaxHP,\r\n              },\r\n            },\r\n            hasUnsavedChanges: true,\r\n            saveStatus: 'saving',\r\n          };\r\n        });\r\n      },\r\n\r\n      // Class and spell management\r\n      updateClass: classInfo => {\r\n        set(state => {\r\n          // Ensure character has multiclass structure\r\n          const migratedCharacter = migrateToMulticlass(state.character);\r\n\r\n          // Update the primary class (first class or create new one)\r\n          const updatedClasses = [...(migratedCharacter.classes || [])];\r\n          if (updatedClasses.length === 0) {\r\n            updatedClasses.push({\r\n              className: classInfo.name,\r\n              level: migratedCharacter.level || 1,\r\n              isCustom: classInfo.isCustom,\r\n              spellcaster: classInfo.spellcaster,\r\n              hitDie: classInfo.hitDie,\r\n            });\r\n          } else {\r\n            // Update the first (primary) class\r\n            updatedClasses[0] = {\r\n              ...updatedClasses[0],\r\n              className: classInfo.name,\r\n              isCustom: classInfo.isCustom,\r\n              spellcaster: classInfo.spellcaster,\r\n              hitDie: classInfo.hitDie,\r\n            };\r\n          }\r\n\r\n          const updatedCharacter = {\r\n            ...migratedCharacter,\r\n            classes: updatedClasses,\r\n            class: classInfo, // Keep for backwards compatibility\r\n          };\r\n\r\n          // Recalculate spell slots and pact magic using multiclass-aware functions\r\n          const newSpellSlots = calculateCharacterSpellSlots(updatedCharacter);\r\n          const preservedSpellSlots = updateSpellSlotsPreservingUsed(\r\n            newSpellSlots,\r\n            state.character.spellSlots\r\n          );\r\n\r\n          const pactMagic = calculateCharacterPactMagic(updatedCharacter);\r\n          // Preserve existing pact magic used slots if possible\r\n          if (state.character.pactMagic && pactMagic) {\r\n            pactMagic.slots.used = Math.min(\r\n              state.character.pactMagic.slots.used,\r\n              pactMagic.slots.max\r\n            );\r\n          }\r\n\r\n          return {\r\n            character: {\r\n              ...updatedCharacter,\r\n              spellSlots: preservedSpellSlots,\r\n              pactMagic,\r\n            },\r\n            hasUnsavedChanges: true,\r\n            saveStatus: 'saving',\r\n          };\r\n        });\r\n      },\r\n\r\n      updateLevel: level => {\r\n        const currentState = get();\r\n        const oldLevel =\r\n          currentState.character.totalLevel || currentState.character.level;\r\n        const clampedLevel = Math.max(1, Math.min(20, level));\r\n\r\n        // Check if this is a level UP (not down or same)\r\n        const isLevelUp = clampedLevel > oldLevel;\r\n\r\n        set(state => {\r\n          // Ensure character has multiclass structure\r\n          const migratedCharacter = migrateToMulticlass(state.character);\r\n\r\n          // For single class characters, update the primary class level\r\n          // For multiclass characters, this updates the total level by adjusting the primary class\r\n          const updatedClasses = [...(migratedCharacter.classes || [])];\r\n          if (updatedClasses.length === 1) {\r\n            // Single class: update the class level directly\r\n            updatedClasses[0] = {\r\n              ...updatedClasses[0],\r\n              level: clampedLevel,\r\n            };\r\n          } else if (updatedClasses.length > 1) {\r\n            // Multiclass: adjust the primary (highest level) class to reach the target total level\r\n            const currentTotal = updatedClasses.reduce(\r\n              (sum, cls) => sum + cls.level,\r\n              0\r\n            );\r\n            const levelDifference = clampedLevel - currentTotal;\r\n\r\n            if (levelDifference !== 0) {\r\n              // Find the primary class (highest level)\r\n              const primaryIndex = updatedClasses.reduce(\r\n                (maxIndex, cls, index) =>\r\n                  cls.level > updatedClasses[maxIndex].level ? index : maxIndex,\r\n                0\r\n              );\r\n\r\n              const newPrimaryLevel = Math.max(\r\n                1,\r\n                updatedClasses[primaryIndex].level + levelDifference\r\n              );\r\n              updatedClasses[primaryIndex] = {\r\n                ...updatedClasses[primaryIndex],\r\n                level: newPrimaryLevel,\r\n              };\r\n            }\r\n          }\r\n\r\n          // Recalculate hit dice pools\r\n          const hitDicePools = calculateHitDicePools(\r\n            updatedClasses,\r\n            migratedCharacter.hitDicePools\r\n          );\r\n\r\n          const updatedCharacter = {\r\n            ...migratedCharacter,\r\n            classes: updatedClasses,\r\n            totalLevel: clampedLevel,\r\n            level: clampedLevel, // Keep for backwards compatibility\r\n            hitDicePools,\r\n          };\r\n\r\n          // Recalculate spell slots and pact magic using multiclass-aware functions\r\n          const newSpellSlots = calculateCharacterSpellSlots(updatedCharacter);\r\n          const preservedSpellSlots = updateSpellSlotsPreservingUsed(\r\n            newSpellSlots,\r\n            state.character.spellSlots\r\n          );\r\n\r\n          const pactMagic = calculateCharacterPactMagic(updatedCharacter);\r\n          // Preserve existing pact magic used slots if possible\r\n          if (state.character.pactMagic && pactMagic) {\r\n            pactMagic.slots.used = Math.min(\r\n              state.character.pactMagic.slots.used,\r\n              pactMagic.slots.max\r\n            );\r\n          }\r\n\r\n          // Check if level up animation should be shown\r\n          const playerSettings = usePlayerStore.getState().settings;\r\n          const enableLevelUp = playerSettings?.enableLevelUpAnimation;\r\n          const shouldShowLevelUp = isLevelUp && enableLevelUp;\r\n\r\n          // Update XP to minimum for the new level (only if current XP is less than required)\r\n          const minXPForLevel = getXPForLevel(clampedLevel);\r\n          const currentXP = state.character.experience || 0;\r\n          const newXP = currentXP < minXPForLevel ? minXPForLevel : currentXP;\r\n\r\n          return {\r\n            character: {\r\n              ...updatedCharacter,\r\n              experience: newXP,\r\n              spellSlots: preservedSpellSlots,\r\n              pactMagic,\r\n            },\r\n            hasUnsavedChanges: true,\r\n            saveStatus: 'saving',\r\n            showLevelUpAnimation: shouldShowLevelUp\r\n              ? true\r\n              : state.showLevelUpAnimation,\r\n            levelUpAnimationLevel: shouldShowLevelUp\r\n              ? clampedLevel\r\n              : state.levelUpAnimationLevel,\r\n          };\r\n        });\r\n\r\n        // Auto-clear the level up animation after 6 seconds\r\n        if (isLevelUp) {\r\n          const playerSettings = usePlayerStore.getState().settings;\r\n          const enableLevelUpAnim = playerSettings?.enableLevelUpAnimation;\r\n          if (enableLevelUpAnim) {\r\n            setTimeout(() => {\r\n              set({ showLevelUpAnimation: false });\r\n            }, 6000);\r\n          }\r\n        }\r\n      },\r\n\r\n      updateSpellSlot: (level, used) => {\r\n        set(state => ({\r\n          character: {\r\n            ...state.character,\r\n            spellSlots: {\r\n              ...state.character.spellSlots,\r\n              [level]: {\r\n                ...state.character.spellSlots[level],\r\n                used: Math.max(\r\n                  0,\r\n                  Math.min(used, state.character.spellSlots[level].max)\r\n                ),\r\n              },\r\n            },\r\n          },\r\n          hasUnsavedChanges: true,\r\n          saveStatus: 'saving',\r\n        }));\r\n      },\r\n\r\n      updatePactMagicSlot: used => {\r\n        set(state => {\r\n          if (!state.character.pactMagic) return state;\r\n\r\n          return {\r\n            character: {\r\n              ...state.character,\r\n              pactMagic: {\r\n                ...state.character.pactMagic,\r\n                slots: {\r\n                  ...state.character.pactMagic.slots,\r\n                  used: Math.max(\r\n                    0,\r\n                    Math.min(used, state.character.pactMagic.slots.max)\r\n                  ),\r\n                },\r\n              },\r\n            },\r\n            hasUnsavedChanges: true,\r\n            saveStatus: 'saving',\r\n          };\r\n        });\r\n      },\r\n\r\n      resetSpellSlots: () => {\r\n        set(state => {\r\n          const resetSlots: SpellSlots = {\r\n            1: { ...state.character.spellSlots[1], used: 0 },\r\n            2: { ...state.character.spellSlots[2], used: 0 },\r\n            3: { ...state.character.spellSlots[3], used: 0 },\r\n            4: { ...state.character.spellSlots[4], used: 0 },\r\n            5: { ...state.character.spellSlots[5], used: 0 },\r\n            6: { ...state.character.spellSlots[6], used: 0 },\r\n            7: { ...state.character.spellSlots[7], used: 0 },\r\n            8: { ...state.character.spellSlots[8], used: 0 },\r\n            9: { ...state.character.spellSlots[9], used: 0 },\r\n          };\r\n\r\n          return {\r\n            character: {\r\n              ...state.character,\r\n              spellSlots: resetSlots,\r\n            },\r\n            hasUnsavedChanges: true,\r\n            saveStatus: 'saving',\r\n          };\r\n        });\r\n      },\r\n\r\n      resetPactMagicSlots: () => {\r\n        set(state => {\r\n          if (!state.character.pactMagic) return state;\r\n\r\n          return {\r\n            character: {\r\n              ...state.character,\r\n              pactMagic: {\r\n                ...state.character.pactMagic,\r\n                slots: {\r\n                  ...state.character.pactMagic.slots,\r\n                  used: 0,\r\n                },\r\n              },\r\n            },\r\n            hasUnsavedChanges: true,\r\n            saveStatus: 'saving',\r\n          };\r\n        });\r\n      },\r\n\r\n      // Multiclass management\r\n      addClassLevel: (\r\n        className,\r\n        isCustom = false,\r\n        spellcaster = 'none',\r\n        hitDie = 8,\r\n        subclass\r\n      ) => {\r\n        set(state => {\r\n          // Ensure character has multiclass structure\r\n          const migratedCharacter = migrateToMulticlass(state.character);\r\n          const classes = [...(migratedCharacter.classes || [])];\r\n\r\n          // Find existing class or create new one\r\n          const existingClassIndex = classes.findIndex(\r\n            cls => cls.className === className\r\n          );\r\n\r\n          if (existingClassIndex >= 0) {\r\n            // Level up existing class\r\n            classes[existingClassIndex] = {\r\n              ...classes[existingClassIndex],\r\n              level: classes[existingClassIndex].level + 1,\r\n              subclass: subclass || classes[existingClassIndex].subclass,\r\n            };\r\n          } else {\r\n            // Add new class\r\n            classes.push({\r\n              className,\r\n              level: 1,\r\n              isCustom,\r\n              spellcaster,\r\n              hitDie,\r\n              subclass,\r\n            });\r\n          }\r\n\r\n          const totalLevel = classes.reduce((sum, cls) => sum + cls.level, 0);\r\n\r\n          // Update backwards compatibility fields\r\n          const primaryClass = classes.reduce((primary, current) =>\r\n            current.level > primary.level ? current : primary\r\n          );\r\n\r\n          const compatibilityClass: ClassInfo = {\r\n            name: primaryClass.className,\r\n            isCustom: primaryClass.isCustom,\r\n            spellcaster: primaryClass.spellcaster,\r\n            hitDie: primaryClass.hitDie,\r\n          };\r\n\r\n          // Recalculate hit dice pools\r\n          const hitDicePools = calculateHitDicePools(\r\n            classes,\r\n            migratedCharacter.hitDicePools\r\n          );\r\n\r\n          const updatedCharacter = {\r\n            ...migratedCharacter,\r\n            classes,\r\n            totalLevel,\r\n            hitDicePools,\r\n            class: compatibilityClass,\r\n            level: totalLevel,\r\n          };\r\n\r\n          // Recalculate spell slots and pact magic\r\n          const newSpellSlots = calculateCharacterSpellSlots(updatedCharacter);\r\n          const preservedSpellSlots = updateSpellSlotsPreservingUsed(\r\n            newSpellSlots,\r\n            state.character.spellSlots\r\n          );\r\n\r\n          const pactMagic = calculateCharacterPactMagic(updatedCharacter);\r\n          if (state.character.pactMagic && pactMagic) {\r\n            pactMagic.slots.used = Math.min(\r\n              state.character.pactMagic.slots.used,\r\n              pactMagic.slots.max\r\n            );\r\n          }\r\n\r\n          return {\r\n            character: {\r\n              ...updatedCharacter,\r\n              spellSlots: preservedSpellSlots,\r\n              pactMagic,\r\n            },\r\n            hasUnsavedChanges: true,\r\n            saveStatus: 'saving',\r\n          };\r\n        });\r\n      },\r\n\r\n      removeClassLevel: className => {\r\n        set(state => {\r\n          const migratedCharacter = migrateToMulticlass(state.character);\r\n          const classes = [...(migratedCharacter.classes || [])];\r\n\r\n          const classIndex = classes.findIndex(\r\n            cls => cls.className === className\r\n          );\r\n          if (classIndex === -1) {\r\n            return state; // Class not found\r\n          }\r\n\r\n          if (classes[classIndex].level > 1) {\r\n            // Reduce level by 1\r\n            classes[classIndex] = {\r\n              ...classes[classIndex],\r\n              level: classes[classIndex].level - 1,\r\n            };\r\n          } else {\r\n            // Remove class entirely\r\n            classes.splice(classIndex, 1);\r\n          }\r\n\r\n          // If no classes left, this shouldn't happen but handle gracefully\r\n          if (classes.length === 0) {\r\n            return state;\r\n          }\r\n\r\n          const totalLevel = classes.reduce((sum, cls) => sum + cls.level, 0);\r\n\r\n          // Update backwards compatibility fields\r\n          const primaryClass = classes.reduce((primary, current) =>\r\n            current.level > primary.level ? current : primary\r\n          );\r\n\r\n          const compatibilityClass: ClassInfo = {\r\n            name: primaryClass.className,\r\n            isCustom: primaryClass.isCustom,\r\n            spellcaster: primaryClass.spellcaster,\r\n            hitDie: primaryClass.hitDie,\r\n          };\r\n\r\n          // Recalculate hit dice pools\r\n          const hitDicePools = calculateHitDicePools(\r\n            classes,\r\n            migratedCharacter.hitDicePools\r\n          );\r\n\r\n          const updatedCharacter = {\r\n            ...migratedCharacter,\r\n            classes,\r\n            totalLevel,\r\n            hitDicePools,\r\n            class: compatibilityClass,\r\n            level: totalLevel,\r\n          };\r\n\r\n          // Recalculate spell slots and pact magic\r\n          const newSpellSlots = calculateCharacterSpellSlots(updatedCharacter);\r\n          const preservedSpellSlots = updateSpellSlotsPreservingUsed(\r\n            newSpellSlots,\r\n            state.character.spellSlots\r\n          );\r\n\r\n          const pactMagic = calculateCharacterPactMagic(updatedCharacter);\r\n\r\n          return {\r\n            character: {\r\n              ...updatedCharacter,\r\n              spellSlots: preservedSpellSlots,\r\n              pactMagic,\r\n            },\r\n            hasUnsavedChanges: true,\r\n            saveStatus: 'saving',\r\n          };\r\n        });\r\n      },\r\n\r\n      updateClassLevel: (className, newLevel) => {\r\n        set(state => {\r\n          const migratedCharacter = migrateToMulticlass(state.character);\r\n          const classes = [...(migratedCharacter.classes || [])];\r\n\r\n          const classIndex = classes.findIndex(\r\n            cls => cls.className === className\r\n          );\r\n          if (classIndex === -1) {\r\n            return state; // Class not found\r\n          }\r\n\r\n          const clampedLevel = Math.max(1, Math.min(20, newLevel));\r\n          classes[classIndex] = {\r\n            ...classes[classIndex],\r\n            level: clampedLevel,\r\n          };\r\n\r\n          const totalLevel = classes.reduce((sum, cls) => sum + cls.level, 0);\r\n\r\n          // Update backwards compatibility fields\r\n          const primaryClass = classes.reduce((primary, current) =>\r\n            current.level > primary.level ? current : primary\r\n          );\r\n\r\n          const compatibilityClass: ClassInfo = {\r\n            name: primaryClass.className,\r\n            isCustom: primaryClass.isCustom,\r\n            spellcaster: primaryClass.spellcaster,\r\n            hitDie: primaryClass.hitDie,\r\n          };\r\n\r\n          // Recalculate hit dice pools\r\n          const hitDicePools = calculateHitDicePools(\r\n            classes,\r\n            migratedCharacter.hitDicePools\r\n          );\r\n\r\n          const updatedCharacter = {\r\n            ...migratedCharacter,\r\n            classes,\r\n            totalLevel,\r\n            hitDicePools,\r\n            class: compatibilityClass,\r\n            level: totalLevel,\r\n          };\r\n\r\n          // Recalculate spell slots and pact magic\r\n          const newSpellSlots = calculateCharacterSpellSlots(updatedCharacter);\r\n          const preservedSpellSlots = updateSpellSlotsPreservingUsed(\r\n            newSpellSlots,\r\n            state.character.spellSlots\r\n          );\r\n\r\n          const pactMagic = calculateCharacterPactMagic(updatedCharacter);\r\n          if (state.character.pactMagic && pactMagic) {\r\n            pactMagic.slots.used = Math.min(\r\n              state.character.pactMagic.slots.used,\r\n              pactMagic.slots.max\r\n            );\r\n          }\r\n\r\n          return {\r\n            character: {\r\n              ...updatedCharacter,\r\n              spellSlots: preservedSpellSlots,\r\n              pactMagic,\r\n            },\r\n            hasUnsavedChanges: true,\r\n            saveStatus: 'saving',\r\n          };\r\n        });\r\n      },\r\n\r\n      isMulticlassed: () => {\r\n        const { character } = get();\r\n        return (character.classes?.length || 0) > 1;\r\n      },\r\n\r\n      getClassDisplayString: () => {\r\n        const { character } = get();\r\n\r\n        if (!character.classes || character.classes.length === 0) {\r\n          // Fallback to single class format\r\n          return `${character.class?.name || 'Unknown'} ${character.level || 1}`;\r\n        }\r\n\r\n        if (character.classes.length === 1) {\r\n          const cls = character.classes[0];\r\n          return `${cls.className} ${cls.level}`;\r\n        }\r\n\r\n        // Sort classes by level (descending) for display\r\n        const sortedClasses = [...character.classes].sort(\r\n          (a, b) => b.level - a.level\r\n        );\r\n        const classStrings = sortedClasses.map(\r\n          cls => `${cls.className} ${cls.level}`\r\n        );\r\n        const totalLevel = getCharacterTotalLevel(character);\r\n\r\n        return `${classStrings.join(' / ')} (Level ${totalLevel})`;\r\n      },\r\n\r\n      // Hit dice management\r\n      useHitDie: (dieType, count = 1) => {\r\n        set(state => {\r\n          const hitDicePools = { ...state.character.hitDicePools };\r\n\r\n          if (hitDicePools[dieType]) {\r\n            const pool = hitDicePools[dieType];\r\n            const actualCount = Math.min(count, pool.max - pool.used);\r\n\r\n            if (actualCount > 0) {\r\n              hitDicePools[dieType] = {\r\n                ...pool,\r\n                used: pool.used + actualCount,\r\n              };\r\n            }\r\n          }\r\n\r\n          return {\r\n            character: {\r\n              ...state.character,\r\n              hitDicePools,\r\n            },\r\n            hasUnsavedChanges: true,\r\n            saveStatus: 'saving',\r\n          };\r\n        });\r\n      },\r\n\r\n      restoreHitDice: (dieType, count = 1) => {\r\n        set(state => {\r\n          const hitDicePools = { ...state.character.hitDicePools };\r\n\r\n          if (hitDicePools[dieType]) {\r\n            const pool = hitDicePools[dieType];\r\n            const actualCount = Math.min(count, pool.used);\r\n\r\n            if (actualCount > 0) {\r\n              hitDicePools[dieType] = {\r\n                ...pool,\r\n                used: pool.used - actualCount,\r\n              };\r\n            }\r\n          }\r\n\r\n          return {\r\n            character: {\r\n              ...state.character,\r\n              hitDicePools,\r\n            },\r\n            hasUnsavedChanges: true,\r\n            saveStatus: 'saving',\r\n          };\r\n        });\r\n      },\r\n\r\n      resetAllHitDice: () => {\r\n        set(state => {\r\n          const hitDicePools = { ...state.character.hitDicePools };\r\n\r\n          // Reset all hit dice pools to 0 used\r\n          Object.keys(hitDicePools).forEach(dieType => {\r\n            hitDicePools[dieType] = {\r\n              ...hitDicePools[dieType],\r\n              used: 0,\r\n            };\r\n          });\r\n\r\n          return {\r\n            character: {\r\n              ...state.character,\r\n              hitDicePools,\r\n            },\r\n            hasUnsavedChanges: true,\r\n            saveStatus: 'saving',\r\n          };\r\n        });\r\n      },\r\n\r\n      resetHalfHitDice: () => {\r\n        set(state => {\r\n          const hitDicePools = { ...state.character.hitDicePools };\r\n\r\n          // Restore half of used hit dice (rounded down)\r\n          Object.keys(hitDicePools).forEach(dieType => {\r\n            const pool = hitDicePools[dieType];\r\n            const restoreCount = Math.floor(pool.used / 2);\r\n\r\n            hitDicePools[dieType] = {\r\n              ...pool,\r\n              used: pool.used - restoreCount,\r\n            };\r\n          });\r\n\r\n          return {\r\n            character: {\r\n              ...state.character,\r\n              hitDicePools,\r\n            },\r\n            hasUnsavedChanges: true,\r\n            saveStatus: 'saving',\r\n          };\r\n        });\r\n      },\r\n\r\n      // Concentration management\r\n      startConcentration: (spellName, spellId, castAt) => {\r\n        set(state => ({\r\n          character: {\r\n            ...state.character,\r\n            concentration: {\r\n              isConcentrating: true,\r\n              spellName,\r\n              spellId,\r\n              castAt,\r\n              startedAt: new Date().toISOString(),\r\n            },\r\n          },\r\n          hasUnsavedChanges: true,\r\n          saveStatus: 'saving',\r\n        }));\r\n      },\r\n\r\n      stopConcentration: () => {\r\n        set(state => ({\r\n          character: {\r\n            ...state.character,\r\n            concentration: {\r\n              isConcentrating: false,\r\n              spellName: undefined,\r\n              spellId: undefined,\r\n              castAt: undefined,\r\n              startedAt: undefined,\r\n            },\r\n          },\r\n          hasUnsavedChanges: true,\r\n          saveStatus: 'saving',\r\n        }));\r\n      },\r\n\r\n      isConcentratingOn: spellName => {\r\n        const state = get();\r\n        return (\r\n          state.character.concentration.isConcentrating &&\r\n          state.character.concentration.spellName === spellName\r\n        );\r\n      },\r\n\r\n      // Conditions and diseases management\r\n      addCondition: (conditionName, source, description, count = 1, notes) => {\r\n        set(state => {\r\n          const newCondition: ActiveCondition = {\r\n            id: `${conditionName.toLowerCase().replace(/[^a-z0-9]/g, '-')}-${Date.now()}`,\r\n            name: conditionName,\r\n            source,\r\n            description,\r\n            stackable: conditionName.toLowerCase() === 'exhaustion',\r\n            count,\r\n            appliedAt: new Date().toISOString(),\r\n            notes,\r\n          };\r\n\r\n          return {\r\n            character: {\r\n              ...state.character,\r\n              conditionsAndDiseases: {\r\n                ...state.character.conditionsAndDiseases,\r\n                activeConditions: [\r\n                  ...state.character.conditionsAndDiseases.activeConditions,\r\n                  newCondition,\r\n                ],\r\n              },\r\n            },\r\n            hasUnsavedChanges: true,\r\n            saveStatus: 'saving',\r\n          };\r\n        });\r\n      },\r\n\r\n      updateCondition: (conditionId, updates) => {\r\n        set(state => {\r\n          const updatedConditions =\r\n            state.character.conditionsAndDiseases.activeConditions.map(\r\n              condition =>\r\n                condition.id === conditionId\r\n                  ? { ...condition, ...updates }\r\n                  : condition\r\n            );\r\n\r\n          return {\r\n            character: {\r\n              ...state.character,\r\n              conditionsAndDiseases: {\r\n                ...state.character.conditionsAndDiseases,\r\n                activeConditions: updatedConditions,\r\n              },\r\n            },\r\n            hasUnsavedChanges: true,\r\n            saveStatus: 'saving',\r\n          };\r\n        });\r\n      },\r\n\r\n      removeCondition: conditionId => {\r\n        set(state => {\r\n          const filteredConditions =\r\n            state.character.conditionsAndDiseases.activeConditions.filter(\r\n              condition => condition.id !== conditionId\r\n            );\r\n\r\n          return {\r\n            character: {\r\n              ...state.character,\r\n              conditionsAndDiseases: {\r\n                ...state.character.conditionsAndDiseases,\r\n                activeConditions: filteredConditions,\r\n              },\r\n            },\r\n            hasUnsavedChanges: true,\r\n            saveStatus: 'saving',\r\n          };\r\n        });\r\n      },\r\n\r\n      addDisease: (diseaseName, source, description, onsetTime, notes) => {\r\n        set(state => {\r\n          const newDisease: ActiveDisease = {\r\n            id: `${diseaseName.toLowerCase().replace(/[^a-z0-9]/g, '-')}-${Date.now()}`,\r\n            name: diseaseName,\r\n            source,\r\n            description,\r\n            onsetTime,\r\n            appliedAt: new Date().toISOString(),\r\n            notes,\r\n          };\r\n\r\n          return {\r\n            character: {\r\n              ...state.character,\r\n              conditionsAndDiseases: {\r\n                ...state.character.conditionsAndDiseases,\r\n                activeDiseases: [\r\n                  ...state.character.conditionsAndDiseases.activeDiseases,\r\n                  newDisease,\r\n                ],\r\n              },\r\n            },\r\n            hasUnsavedChanges: true,\r\n            saveStatus: 'saving',\r\n          };\r\n        });\r\n      },\r\n\r\n      updateDisease: (diseaseId, updates) => {\r\n        set(state => {\r\n          const updatedDiseases =\r\n            state.character.conditionsAndDiseases.activeDiseases.map(disease =>\r\n              disease.id === diseaseId ? { ...disease, ...updates } : disease\r\n            );\r\n\r\n          return {\r\n            character: {\r\n              ...state.character,\r\n              conditionsAndDiseases: {\r\n                ...state.character.conditionsAndDiseases,\r\n                activeDiseases: updatedDiseases,\r\n              },\r\n            },\r\n            hasUnsavedChanges: true,\r\n            saveStatus: 'saving',\r\n          };\r\n        });\r\n      },\r\n\r\n      removeDisease: diseaseId => {\r\n        set(state => {\r\n          const filteredDiseases =\r\n            state.character.conditionsAndDiseases.activeDiseases.filter(\r\n              disease => disease.id !== diseaseId\r\n            );\r\n\r\n          return {\r\n            character: {\r\n              ...state.character,\r\n              conditionsAndDiseases: {\r\n                ...state.character.conditionsAndDiseases,\r\n                activeDiseases: filteredDiseases,\r\n              },\r\n            },\r\n            hasUnsavedChanges: true,\r\n            saveStatus: 'saving',\r\n          };\r\n        });\r\n      },\r\n\r\n      setExhaustionVariant: variant => {\r\n        set(state => ({\r\n          character: {\r\n            ...state.character,\r\n            conditionsAndDiseases: {\r\n              ...state.character.conditionsAndDiseases,\r\n              exhaustionVariant: variant,\r\n            },\r\n          },\r\n          hasUnsavedChanges: true,\r\n          saveStatus: 'saving',\r\n        }));\r\n      },\r\n\r\n      clearAllConditions: () => {\r\n        set(state => ({\r\n          character: {\r\n            ...state.character,\r\n            conditionsAndDiseases: {\r\n              ...state.character.conditionsAndDiseases,\r\n              activeConditions: [],\r\n            },\r\n          },\r\n          hasUnsavedChanges: true,\r\n          saveStatus: 'saving',\r\n        }));\r\n      },\r\n\r\n      clearAllDiseases: () => {\r\n        set(state => ({\r\n          character: {\r\n            ...state.character,\r\n            conditionsAndDiseases: {\r\n              ...state.character.conditionsAndDiseases,\r\n              activeDiseases: [],\r\n            },\r\n          },\r\n          hasUnsavedChanges: true,\r\n          saveStatus: 'saving',\r\n        }));\r\n      },\r\n\r\n      // XP management\r\n      addExperience: xpToAdd => {\r\n        const currentState = get();\r\n        const oldLevel =\r\n          currentState.character.totalLevel || currentState.character.level;\r\n        const newXP = currentState.character.experience + xpToAdd;\r\n        const newLevel = calculateLevelFromXP(newXP);\r\n\r\n        // Check if this is a level UP\r\n        const isLevelUp = newLevel > oldLevel;\r\n\r\n        // Debug logging\r\n        console.log('addExperience called:', {\r\n          xpToAdd,\r\n          oldXP: currentState.character.experience,\r\n          newXP,\r\n          oldLevel,\r\n          newLevel,\r\n          isLevelUp,\r\n        });\r\n\r\n        set(state => {\r\n          // Ensure character has multiclass structure\r\n          const migratedCharacter = migrateToMulticlass(state.character);\r\n\r\n          // Update class levels based on new total level\r\n          const updatedClasses = [...(migratedCharacter.classes || [])];\r\n          if (updatedClasses.length === 1) {\r\n            updatedClasses[0] = {\r\n              ...updatedClasses[0],\r\n              level: newLevel,\r\n            };\r\n          } else if (updatedClasses.length > 1) {\r\n            // Adjust the primary class to reach the target total level\r\n            const currentTotal = updatedClasses.reduce(\r\n              (sum, cls) => sum + cls.level,\r\n              0\r\n            );\r\n            const levelDifference = newLevel - currentTotal;\r\n\r\n            if (levelDifference !== 0) {\r\n              const primaryIndex = updatedClasses.reduce(\r\n                (maxIndex, cls, index) =>\r\n                  cls.level > updatedClasses[maxIndex].level ? index : maxIndex,\r\n                0\r\n              );\r\n\r\n              updatedClasses[primaryIndex] = {\r\n                ...updatedClasses[primaryIndex],\r\n                level: Math.max(\r\n                  1,\r\n                  updatedClasses[primaryIndex].level + levelDifference\r\n                ),\r\n              };\r\n            }\r\n          }\r\n\r\n          // Recalculate hit dice pools\r\n          const hitDicePools = calculateHitDicePools(\r\n            updatedClasses,\r\n            migratedCharacter.hitDicePools\r\n          );\r\n\r\n          const updatedCharacter = {\r\n            ...migratedCharacter,\r\n            classes: updatedClasses,\r\n            totalLevel: newLevel,\r\n            level: newLevel,\r\n            hitDicePools,\r\n          };\r\n\r\n          // Recalculate spell slots using multiclass-aware functions\r\n          const newSpellSlots = calculateCharacterSpellSlots(updatedCharacter);\r\n          const preservedSpellSlots = updateSpellSlotsPreservingUsed(\r\n            newSpellSlots,\r\n            state.character.spellSlots\r\n          );\r\n\r\n          const pactMagic = calculateCharacterPactMagic(updatedCharacter);\r\n          // Preserve existing pact magic used slots if possible\r\n          if (state.character.pactMagic && pactMagic) {\r\n            pactMagic.slots.used = Math.min(\r\n              state.character.pactMagic.slots.used,\r\n              pactMagic.slots.max\r\n            );\r\n          }\r\n\r\n          // Check if level up animation should be shown\r\n          const playerSettings = usePlayerStore.getState().settings;\r\n          const enableLevelUp = playerSettings?.enableLevelUpAnimation; // Default to true\r\n          const shouldShowLevelUp = isLevelUp && enableLevelUp;\r\n\r\n          console.log('addExperience animation check:', {\r\n            isLevelUp,\r\n            enableLevelUpAnimation: enableLevelUp,\r\n            shouldShowLevelUp,\r\n            newLevel,\r\n          });\r\n\r\n          return {\r\n            character: {\r\n              ...updatedCharacter,\r\n              experience: newXP,\r\n              spellSlots: preservedSpellSlots,\r\n              pactMagic,\r\n            },\r\n            hasUnsavedChanges: true,\r\n            saveStatus: 'saving',\r\n            showLevelUpAnimation: shouldShowLevelUp\r\n              ? true\r\n              : state.showLevelUpAnimation,\r\n            levelUpAnimationLevel: shouldShowLevelUp\r\n              ? newLevel\r\n              : state.levelUpAnimationLevel,\r\n          };\r\n        });\r\n\r\n        // Auto-clear the level up animation after 6 seconds\r\n        const playerSettings = usePlayerStore.getState().settings;\r\n        const enableLevelUpAnim = playerSettings?.enableLevelUpAnimation;\r\n        if (isLevelUp && enableLevelUpAnim) {\r\n          console.log('Setting up auto-clear timeout for level up animation');\r\n          setTimeout(() => {\r\n            set({ showLevelUpAnimation: false });\r\n          }, 6000);\r\n        }\r\n      },\r\n\r\n      setExperience: newXP => {\r\n        const currentState = get();\r\n        const oldLevel =\r\n          currentState.character.totalLevel || currentState.character.level;\r\n        const newLevel = calculateLevelFromXP(newXP);\r\n\r\n        // Check if this is a level UP\r\n        const isLevelUp = newLevel > oldLevel;\r\n\r\n        set(state => {\r\n          // Ensure character has multiclass structure\r\n          const migratedCharacter = migrateToMulticlass(state.character);\r\n\r\n          // Update class levels based on new total level\r\n          const updatedClasses = [...(migratedCharacter.classes || [])];\r\n          if (updatedClasses.length === 1) {\r\n            updatedClasses[0] = {\r\n              ...updatedClasses[0],\r\n              level: newLevel,\r\n            };\r\n          } else if (updatedClasses.length > 1) {\r\n            // Adjust the primary class to reach the target total level\r\n            const currentTotal = updatedClasses.reduce(\r\n              (sum, cls) => sum + cls.level,\r\n              0\r\n            );\r\n            const levelDifference = newLevel - currentTotal;\r\n\r\n            if (levelDifference !== 0) {\r\n              const primaryIndex = updatedClasses.reduce(\r\n                (maxIndex, cls, index) =>\r\n                  cls.level > updatedClasses[maxIndex].level ? index : maxIndex,\r\n                0\r\n              );\r\n\r\n              updatedClasses[primaryIndex] = {\r\n                ...updatedClasses[primaryIndex],\r\n                level: Math.max(\r\n                  1,\r\n                  updatedClasses[primaryIndex].level + levelDifference\r\n                ),\r\n              };\r\n            }\r\n          }\r\n\r\n          // Recalculate hit dice pools\r\n          const hitDicePools = calculateHitDicePools(\r\n            updatedClasses,\r\n            migratedCharacter.hitDicePools\r\n          );\r\n\r\n          const updatedCharacter = {\r\n            ...migratedCharacter,\r\n            classes: updatedClasses,\r\n            totalLevel: newLevel,\r\n            level: newLevel,\r\n            hitDicePools,\r\n          };\r\n\r\n          // Recalculate spell slots using multiclass-aware functions\r\n          const newSpellSlots = calculateCharacterSpellSlots(updatedCharacter);\r\n          const preservedSpellSlots = updateSpellSlotsPreservingUsed(\r\n            newSpellSlots,\r\n            state.character.spellSlots\r\n          );\r\n\r\n          const pactMagic = calculateCharacterPactMagic(updatedCharacter);\r\n          // Preserve existing pact magic used slots if possible\r\n          if (state.character.pactMagic && pactMagic) {\r\n            pactMagic.slots.used = Math.min(\r\n              state.character.pactMagic.slots.used,\r\n              pactMagic.slots.max\r\n            );\r\n          }\r\n\r\n          // Check if level up animation should be shown\r\n          const playerSettings = usePlayerStore.getState().settings;\r\n          const enableLevelUp = playerSettings?.enableLevelUpAnimation;\r\n          const shouldShowLevelUp = isLevelUp && enableLevelUp;\r\n\r\n          return {\r\n            character: {\r\n              ...updatedCharacter,\r\n              experience: newXP,\r\n              spellSlots: preservedSpellSlots,\r\n              pactMagic,\r\n            },\r\n            hasUnsavedChanges: true,\r\n            saveStatus: 'saving',\r\n            showLevelUpAnimation: shouldShowLevelUp\r\n              ? true\r\n              : state.showLevelUpAnimation,\r\n            levelUpAnimationLevel: shouldShowLevelUp\r\n              ? newLevel\r\n              : state.levelUpAnimationLevel,\r\n          };\r\n        });\r\n\r\n        // Auto-clear the level up animation after 6 seconds\r\n        const playerSettings = usePlayerStore.getState().settings;\r\n        const enableLevelUpAnim = playerSettings?.enableLevelUpAnimation;\r\n        if (isLevelUp && enableLevelUpAnim) {\r\n          setTimeout(() => {\r\n            set({ showLevelUpAnimation: false });\r\n          }, 6000);\r\n        }\r\n      },\r\n\r\n      // Rich text content management\r\n      addFeature: feature => {\r\n        set(state => {\r\n          const newFeature: RichTextContent = {\r\n            ...feature,\r\n            id: generateId(),\r\n            createdAt: new Date().toISOString(),\r\n            updatedAt: new Date().toISOString(),\r\n          };\r\n\r\n          return {\r\n            character: {\r\n              ...state.character,\r\n              features: [...state.character.features, newFeature],\r\n            },\r\n            hasUnsavedChanges: true,\r\n            saveStatus: 'saving',\r\n          };\r\n        });\r\n      },\r\n\r\n      updateFeature: (id, updates) => {\r\n        set(state => ({\r\n          character: {\r\n            ...state.character,\r\n            features: state.character.features.map(feature =>\r\n              feature.id === id\r\n                ? {\r\n                    ...feature,\r\n                    ...updates,\r\n                    updatedAt: new Date().toISOString(),\r\n                  }\r\n                : feature\r\n            ),\r\n          },\r\n          hasUnsavedChanges: true,\r\n          saveStatus: 'saving',\r\n        }));\r\n      },\r\n\r\n      deleteFeature: id => {\r\n        set(state => ({\r\n          character: {\r\n            ...state.character,\r\n            features: state.character.features.filter(\r\n              feature => feature.id !== id\r\n            ),\r\n          },\r\n          hasUnsavedChanges: true,\r\n          saveStatus: 'saving',\r\n        }));\r\n      },\r\n\r\n      addTrait: trait => {\r\n        set(state => {\r\n          const newTrait: RichTextContent = {\r\n            ...trait,\r\n            id: generateId(),\r\n            createdAt: new Date().toISOString(),\r\n            updatedAt: new Date().toISOString(),\r\n          };\r\n\r\n          return {\r\n            character: {\r\n              ...state.character,\r\n              traits: [...state.character.traits, newTrait],\r\n            },\r\n            hasUnsavedChanges: true,\r\n            saveStatus: 'saving',\r\n          };\r\n        });\r\n      },\r\n\r\n      updateTrait: (id, updates) => {\r\n        set(state => ({\r\n          character: {\r\n            ...state.character,\r\n            traits: state.character.traits.map(trait =>\r\n              trait.id === id\r\n                ? { ...trait, ...updates, updatedAt: new Date().toISOString() }\r\n                : trait\r\n            ),\r\n          },\r\n          hasUnsavedChanges: true,\r\n          saveStatus: 'saving',\r\n        }));\r\n      },\r\n\r\n      deleteTrait: id => {\r\n        set(state => ({\r\n          character: {\r\n            ...state.character,\r\n            traits: state.character.traits.filter(trait => trait.id !== id),\r\n          },\r\n          hasUnsavedChanges: true,\r\n          saveStatus: 'saving',\r\n        }));\r\n      },\r\n\r\n      addNote: (\r\n        note: Omit<RichTextContent, 'id' | 'createdAt' | 'updatedAt'>\r\n      ) => {\r\n        set(state => {\r\n          const newNote: RichTextContent = {\r\n            ...note,\r\n            id: generateId(),\r\n            order: state.character.notes.length, // Set order to the end\r\n            createdAt: new Date().toISOString(),\r\n            updatedAt: new Date().toISOString(),\r\n          };\r\n\r\n          return {\r\n            character: {\r\n              ...state.character,\r\n              notes: [...state.character.notes, newNote],\r\n            },\r\n            hasUnsavedChanges: true,\r\n            saveStatus: 'saving',\r\n          };\r\n        });\r\n      },\r\n\r\n      updateNote: (id: string, updates: Partial<RichTextContent>) => {\r\n        set(state => ({\r\n          character: {\r\n            ...state.character,\r\n            notes: state.character.notes.map(note =>\r\n              note.id === id\r\n                ? { ...note, ...updates, updatedAt: new Date().toISOString() }\r\n                : note\r\n            ),\r\n          },\r\n          hasUnsavedChanges: true,\r\n          saveStatus: 'saving',\r\n        }));\r\n      },\r\n\r\n      deleteNote: (id: string) => {\r\n        set(state => ({\r\n          character: {\r\n            ...state.character,\r\n            notes: state.character.notes.filter(note => note.id !== id),\r\n          },\r\n          hasUnsavedChanges: true,\r\n          saveStatus: 'saving',\r\n        }));\r\n      },\r\n\r\n      reorderNotes: (sourceIndex: number, destinationIndex: number) => {\r\n        set(state => {\r\n          const notes = [...state.character.notes];\r\n          const [removed] = notes.splice(sourceIndex, 1);\r\n          notes.splice(destinationIndex, 0, removed);\r\n\r\n          // Update order property\r\n          const updatedNotes = notes.map((note, index) => ({\r\n            ...note,\r\n            order: index,\r\n            updatedAt: new Date().toISOString(),\r\n          }));\r\n\r\n          return {\r\n            character: {\r\n              ...state.character,\r\n              notes: updatedNotes,\r\n            },\r\n            hasUnsavedChanges: true,\r\n            saveStatus: 'saving',\r\n          };\r\n        });\r\n      },\r\n\r\n      // Trackable trait management\r\n      addTrackableTrait: trait => {\r\n        set(state => {\r\n          const newTrait: TrackableTrait = {\r\n            ...trait,\r\n            id: generateId(),\r\n            createdAt: new Date().toISOString(),\r\n            updatedAt: new Date().toISOString(),\r\n          };\r\n\r\n          // Also add as extended feature\r\n          const newExtendedFeature: ExtendedFeature = {\r\n            ...newTrait,\r\n            sourceType: 'other' as const,\r\n            sourceDetail: newTrait.source || undefined,\r\n            displayOrder: (state.character.extendedFeatures || []).length,\r\n            isPassive: newTrait.maxUses === 0,\r\n          };\r\n\r\n          return {\r\n            character: {\r\n              ...state.character,\r\n              trackableTraits: [\r\n                ...(state.character.trackableTraits || []),\r\n                newTrait,\r\n              ],\r\n              extendedFeatures: [\r\n                ...(state.character.extendedFeatures || []),\r\n                newExtendedFeature,\r\n              ],\r\n            },\r\n            hasUnsavedChanges: true,\r\n            saveStatus: 'saving',\r\n          };\r\n        });\r\n      },\r\n\r\n      updateTrackableTrait: (id, updates) => {\r\n        set(state => {\r\n          const updatedTraits = (state.character.trackableTraits || []).map(\r\n            trait =>\r\n              trait.id === id\r\n                ? {\r\n                    ...trait,\r\n                    ...updates,\r\n                    updatedAt: new Date().toISOString(),\r\n                  }\r\n                : trait\r\n          );\r\n\r\n          // Also update corresponding extended feature\r\n          const updatedExtendedFeatures = (\r\n            state.character.extendedFeatures || []\r\n          ).map(feature =>\r\n            feature.id === id\r\n              ? {\r\n                  ...feature,\r\n                  ...updates,\r\n                  sourceDetail: updates.source || feature.sourceDetail,\r\n                  isPassive:\r\n                    (updates.maxUses !== undefined\r\n                      ? updates.maxUses\r\n                      : feature.maxUses) === 0,\r\n                  updatedAt: new Date().toISOString(),\r\n                }\r\n              : feature\r\n          );\r\n\r\n          return {\r\n            character: {\r\n              ...state.character,\r\n              trackableTraits: updatedTraits,\r\n              extendedFeatures: updatedExtendedFeatures,\r\n            },\r\n            hasUnsavedChanges: true,\r\n            saveStatus: 'saving',\r\n          };\r\n        });\r\n      },\r\n\r\n      deleteTrackableTrait: id => {\r\n        set(state => ({\r\n          character: {\r\n            ...state.character,\r\n            trackableTraits: (state.character.trackableTraits || []).filter(\r\n              trait => trait.id !== id\r\n            ),\r\n            extendedFeatures: (state.character.extendedFeatures || []).filter(\r\n              feature => feature.id !== id\r\n            ),\r\n          },\r\n          hasUnsavedChanges: true,\r\n          saveStatus: 'saving',\r\n        }));\r\n      },\r\n\r\n      useTrackableTrait: id => {\r\n        set(state => {\r\n          const updatedTraits = (state.character.trackableTraits || []).map(\r\n            trait =>\r\n              trait.id === id\r\n                ? {\r\n                    ...trait,\r\n                    usedUses: Math.min(\r\n                      trait.usedUses + 1,\r\n                      calculateTraitMaxUses(trait, state.character.level)\r\n                    ),\r\n                    updatedAt: new Date().toISOString(),\r\n                  }\r\n                : trait\r\n          );\r\n\r\n          // Also update corresponding extended feature\r\n          const updatedExtendedFeatures = (\r\n            state.character.extendedFeatures || []\r\n          ).map(feature =>\r\n            feature.id === id\r\n              ? {\r\n                  ...feature,\r\n                  usedUses: Math.min(\r\n                    feature.usedUses + 1,\r\n                    calculateTraitMaxUses(feature, state.character.level)\r\n                  ),\r\n                  updatedAt: new Date().toISOString(),\r\n                }\r\n              : feature\r\n          );\r\n\r\n          return {\r\n            character: {\r\n              ...state.character,\r\n              trackableTraits: updatedTraits,\r\n              extendedFeatures: updatedExtendedFeatures,\r\n            },\r\n            hasUnsavedChanges: true,\r\n            saveStatus: 'saving',\r\n          };\r\n        });\r\n      },\r\n\r\n      resetTrackableTraits: restType => {\r\n        set(state => {\r\n          const updatedTraits = (state.character.trackableTraits || []).map(\r\n            trait =>\r\n              trait.restType === restType || restType === 'long'\r\n                ? {\r\n                    ...trait,\r\n                    usedUses: 0,\r\n                    updatedAt: new Date().toISOString(),\r\n                  }\r\n                : trait\r\n          );\r\n\r\n          // Also update corresponding extended features\r\n          const updatedExtendedFeatures = (\r\n            state.character.extendedFeatures || []\r\n          ).map(feature =>\r\n            feature.restType === restType || restType === 'long'\r\n              ? {\r\n                  ...feature,\r\n                  usedUses: 0,\r\n                  updatedAt: new Date().toISOString(),\r\n                }\r\n              : feature\r\n          );\r\n\r\n          return {\r\n            character: {\r\n              ...state.character,\r\n              trackableTraits: updatedTraits,\r\n              extendedFeatures: updatedExtendedFeatures,\r\n            },\r\n            hasUnsavedChanges: true,\r\n            saveStatus: 'saving',\r\n          };\r\n        });\r\n      },\r\n\r\n      // Extended feature management actions\r\n      addExtendedFeature: feature => {\r\n        set(state => {\r\n          const newFeature: ExtendedFeature = {\r\n            ...feature,\r\n            id: generateId(),\r\n            createdAt: new Date().toISOString(),\r\n            updatedAt: new Date().toISOString(),\r\n          };\r\n\r\n          // Also add as trackable trait\r\n          const newTrackableTrait: TrackableTrait = {\r\n            id: newFeature.id,\r\n            name: newFeature.name,\r\n            description: newFeature.description,\r\n            maxUses: newFeature.maxUses,\r\n            usedUses: newFeature.usedUses,\r\n            restType: newFeature.restType,\r\n            source: newFeature.sourceDetail || newFeature.source,\r\n            scaleWithProficiency: newFeature.scaleWithProficiency,\r\n            proficiencyMultiplier: newFeature.proficiencyMultiplier,\r\n            createdAt: newFeature.createdAt,\r\n            updatedAt: newFeature.updatedAt,\r\n          };\r\n\r\n          return {\r\n            character: {\r\n              ...state.character,\r\n              extendedFeatures: [\r\n                ...(state.character.extendedFeatures || []),\r\n                newFeature,\r\n              ],\r\n              trackableTraits: [\r\n                ...(state.character.trackableTraits || []),\r\n                newTrackableTrait,\r\n              ],\r\n            },\r\n            hasUnsavedChanges: true,\r\n            saveStatus: 'saving',\r\n          };\r\n        });\r\n      },\r\n\r\n      updateExtendedFeature: (id, updates) => {\r\n        set(state => {\r\n          const updatedFeatures = (state.character.extendedFeatures || []).map(\r\n            feature =>\r\n              feature.id === id\r\n                ? {\r\n                    ...feature,\r\n                    ...updates,\r\n                    updatedAt: new Date().toISOString(),\r\n                  }\r\n                : feature\r\n          );\r\n\r\n          // Also update corresponding trackable trait\r\n          const updatedTraits = (state.character.trackableTraits || []).map(\r\n            trait =>\r\n              trait.id === id\r\n                ? {\r\n                    ...trait,\r\n                    ...updates,\r\n                    source:\r\n                      updates.sourceDetail || updates.source || trait.source,\r\n                    updatedAt: new Date().toISOString(),\r\n                  }\r\n                : trait\r\n          );\r\n\r\n          return {\r\n            character: {\r\n              ...state.character,\r\n              extendedFeatures: updatedFeatures,\r\n              trackableTraits: updatedTraits,\r\n            },\r\n            hasUnsavedChanges: true,\r\n            saveStatus: 'saving',\r\n          };\r\n        });\r\n      },\r\n\r\n      deleteExtendedFeature: id => {\r\n        set(state => ({\r\n          character: {\r\n            ...state.character,\r\n            extendedFeatures: (state.character.extendedFeatures || []).filter(\r\n              feature => feature.id !== id\r\n            ),\r\n            trackableTraits: (state.character.trackableTraits || []).filter(\r\n              trait => trait.id !== id\r\n            ),\r\n          },\r\n          hasUnsavedChanges: true,\r\n          saveStatus: 'saving',\r\n        }));\r\n      },\r\n\r\n      useExtendedFeature: id => {\r\n        set(state => {\r\n          const updatedFeatures = (state.character.extendedFeatures || []).map(\r\n            feature =>\r\n              feature.id === id\r\n                ? {\r\n                    ...feature,\r\n                    usedUses: Math.min(\r\n                      feature.usedUses + 1,\r\n                      calculateTraitMaxUses(feature, state.character.level)\r\n                    ),\r\n                    updatedAt: new Date().toISOString(),\r\n                  }\r\n                : feature\r\n          );\r\n\r\n          // Also update corresponding trackable trait\r\n          const updatedTraits = (state.character.trackableTraits || []).map(\r\n            trait =>\r\n              trait.id === id\r\n                ? {\r\n                    ...trait,\r\n                    usedUses: Math.min(\r\n                      trait.usedUses + 1,\r\n                      calculateTraitMaxUses(trait, state.character.level)\r\n                    ),\r\n                    updatedAt: new Date().toISOString(),\r\n                  }\r\n                : trait\r\n          );\r\n\r\n          return {\r\n            character: {\r\n              ...state.character,\r\n              extendedFeatures: updatedFeatures,\r\n              trackableTraits: updatedTraits,\r\n            },\r\n            hasUnsavedChanges: true,\r\n            saveStatus: 'saving',\r\n          };\r\n        });\r\n      },\r\n\r\n      resetExtendedFeatures: restType => {\r\n        set(state => {\r\n          const updatedFeatures = (state.character.extendedFeatures || []).map(\r\n            feature =>\r\n              feature.restType === restType || restType === 'long'\r\n                ? {\r\n                    ...feature,\r\n                    usedUses: 0,\r\n                    updatedAt: new Date().toISOString(),\r\n                  }\r\n                : feature\r\n          );\r\n\r\n          // Also update corresponding trackable traits\r\n          const updatedTraits = (state.character.trackableTraits || []).map(\r\n            trait =>\r\n              trait.restType === restType || restType === 'long'\r\n                ? {\r\n                    ...trait,\r\n                    usedUses: 0,\r\n                    updatedAt: new Date().toISOString(),\r\n                  }\r\n                : trait\r\n          );\r\n\r\n          return {\r\n            character: {\r\n              ...state.character,\r\n              extendedFeatures: updatedFeatures,\r\n              trackableTraits: updatedTraits,\r\n            },\r\n            hasUnsavedChanges: true,\r\n            saveStatus: 'saving',\r\n          };\r\n        });\r\n      },\r\n\r\n      reorderExtendedFeatures: (sourceIndex, destinationIndex, sourceType) => {\r\n        set(state => {\r\n          const features = [...(state.character.extendedFeatures || [])];\r\n\r\n          if (sourceType) {\r\n            // Reorder within a specific source type\r\n            const filteredFeatures = features.filter(\r\n              f => f.sourceType === sourceType\r\n            );\r\n            const otherFeatures = features.filter(\r\n              f => f.sourceType !== sourceType\r\n            );\r\n\r\n            if (\r\n              sourceIndex >= filteredFeatures.length ||\r\n              destinationIndex >= filteredFeatures.length\r\n            ) {\r\n              return state;\r\n            }\r\n\r\n            const [movedFeature] = filteredFeatures.splice(sourceIndex, 1);\r\n            filteredFeatures.splice(destinationIndex, 0, movedFeature);\r\n\r\n            // Update display orders\r\n            filteredFeatures.forEach((feature, index) => {\r\n              feature.displayOrder = index;\r\n              feature.updatedAt = new Date().toISOString();\r\n            });\r\n\r\n            return {\r\n              character: {\r\n                ...state.character,\r\n                extendedFeatures: [...otherFeatures, ...filteredFeatures],\r\n              },\r\n              hasUnsavedChanges: true,\r\n              saveStatus: 'saving',\r\n            };\r\n          } else {\r\n            // Reorder all features\r\n            if (\r\n              sourceIndex >= features.length ||\r\n              destinationIndex >= features.length\r\n            ) {\r\n              return state;\r\n            }\r\n\r\n            const [movedFeature] = features.splice(sourceIndex, 1);\r\n            features.splice(destinationIndex, 0, movedFeature);\r\n\r\n            // Update display orders\r\n            features.forEach((feature, index) => {\r\n              feature.displayOrder = index;\r\n              feature.updatedAt = new Date().toISOString();\r\n            });\r\n\r\n            return {\r\n              character: {\r\n                ...state.character,\r\n                extendedFeatures: features,\r\n              },\r\n              hasUnsavedChanges: true,\r\n              saveStatus: 'saving',\r\n            };\r\n          }\r\n        });\r\n      },\r\n\r\n      migrateTraitsToExtendedFeatures: () => {\r\n        set(state => {\r\n          const existingTraits = state.character.trackableTraits || [];\r\n          const existingExtended = state.character.extendedFeatures || [];\r\n\r\n          // Only migrate if there are traits and no extended features yet\r\n          if (existingTraits.length === 0 || existingExtended.length > 0) {\r\n            return state;\r\n          }\r\n\r\n          const migratedFeatures: ExtendedFeature[] = existingTraits.map(\r\n            (trait, index) => ({\r\n              ...trait,\r\n              sourceType: 'other' as const,\r\n              sourceDetail: trait.source || undefined,\r\n              displayOrder: index,\r\n              isPassive: trait.maxUses === 0,\r\n            })\r\n          );\r\n\r\n          return {\r\n            character: {\r\n              ...state.character,\r\n              extendedFeatures: migratedFeatures,\r\n            },\r\n            hasUnsavedChanges: true,\r\n            saveStatus: 'saving',\r\n          };\r\n        });\r\n      },\r\n\r\n      // Language management\r\n      addLanguage: (\r\n        language: Omit<Language, 'id' | 'createdAt' | 'updatedAt'>\r\n      ) => {\r\n        set(state => {\r\n          const newLanguage: Language = {\r\n            ...language,\r\n            id: generateId(),\r\n            createdAt: new Date().toISOString(),\r\n            updatedAt: new Date().toISOString(),\r\n          };\r\n\r\n          return {\r\n            character: {\r\n              ...state.character,\r\n              languages: [...(state.character.languages || []), newLanguage],\r\n            },\r\n            hasUnsavedChanges: true,\r\n            saveStatus: 'saving',\r\n          };\r\n        });\r\n      },\r\n\r\n      deleteLanguage: (id: string) => {\r\n        set(state => ({\r\n          character: {\r\n            ...state.character,\r\n            languages: (state.character.languages || []).filter(\r\n              lang => lang.id !== id\r\n            ),\r\n          },\r\n          hasUnsavedChanges: true,\r\n          saveStatus: 'saving',\r\n        }));\r\n      },\r\n\r\n      // Tool proficiency management\r\n      addToolProficiency: (\r\n        tool: Omit<ToolProficiency, 'id' | 'createdAt' | 'updatedAt'>\r\n      ) => {\r\n        set(state => {\r\n          const newTool: ToolProficiency = {\r\n            ...tool,\r\n            id: generateId(),\r\n            createdAt: new Date().toISOString(),\r\n            updatedAt: new Date().toISOString(),\r\n          };\r\n\r\n          return {\r\n            character: {\r\n              ...state.character,\r\n              toolProficiencies: [\r\n                ...(state.character.toolProficiencies || []),\r\n                newTool,\r\n              ],\r\n            },\r\n            hasUnsavedChanges: true,\r\n            saveStatus: 'saving',\r\n          };\r\n        });\r\n      },\r\n\r\n      updateToolProficiency: (\r\n        id: string,\r\n        updates: Partial<ToolProficiency>\r\n      ) => {\r\n        set(state => ({\r\n          character: {\r\n            ...state.character,\r\n            toolProficiencies: (state.character.toolProficiencies || []).map(\r\n              tool =>\r\n                tool.id === id\r\n                  ? { ...tool, ...updates, updatedAt: new Date().toISOString() }\r\n                  : tool\r\n            ),\r\n          },\r\n          hasUnsavedChanges: true,\r\n          saveStatus: 'saving',\r\n        }));\r\n      },\r\n\r\n      deleteToolProficiency: (id: string) => {\r\n        set(state => ({\r\n          character: {\r\n            ...state.character,\r\n            toolProficiencies: (state.character.toolProficiencies || []).filter(\r\n              tool => tool.id !== id\r\n            ),\r\n          },\r\n          hasUnsavedChanges: true,\r\n          saveStatus: 'saving',\r\n        }));\r\n      },\r\n\r\n      // Rest management (centralized)\r\n      takeShortRest: () => {\r\n        set(state => {\r\n          const { character } = state;\r\n\r\n          // Reset short rest abilities (trackableTraits and extendedFeatures)\r\n          const resetTrackableTraits = character.trackableTraits.map(trait =>\r\n            trait.restType === 'short' ? { ...trait, usedUses: 0 } : trait\r\n          );\r\n\r\n          const resetExtendedFeatures = character.extendedFeatures.map(\r\n            feature =>\r\n              feature.restType === 'short' && !feature.isPassive\r\n                ? { ...feature, usedUses: 0 }\r\n                : feature\r\n          );\r\n\r\n          // Reset Pact Magic slots (if Warlock)\r\n          let resetPactMagic = character.pactMagic;\r\n          if (resetPactMagic) {\r\n            resetPactMagic = {\r\n              ...resetPactMagic,\r\n              slots: {\r\n                ...resetPactMagic.slots,\r\n                used: 0,\r\n              },\r\n            };\r\n          }\r\n\r\n          // Reset reaction\r\n          const resetReaction = {\r\n            hasUsedReaction: false,\r\n          };\r\n\r\n          return {\r\n            character: {\r\n              ...character,\r\n              trackableTraits: resetTrackableTraits,\r\n              extendedFeatures: resetExtendedFeatures,\r\n              pactMagic: resetPactMagic,\r\n              reaction: resetReaction,\r\n            },\r\n            hasUnsavedChanges: true,\r\n            saveStatus: 'saving',\r\n          };\r\n        });\r\n      },\r\n\r\n      takeLongRest: () => {\r\n        set(state => {\r\n          const { character } = state;\r\n\r\n          // Reset ALL abilities (both short and long rest)\r\n          const resetTrackableTraits = character.trackableTraits.map(trait => ({\r\n            ...trait,\r\n            usedUses: 0,\r\n          }));\r\n\r\n          const resetExtendedFeatures = character.extendedFeatures.map(\r\n            feature =>\r\n              feature.isPassive ? feature : { ...feature, usedUses: 0 }\r\n          );\r\n\r\n          // Reset ALL spell slots\r\n          const resetSpellSlots = { ...character.spellSlots };\r\n          for (let level = 1; level <= 9; level++) {\r\n            const slot = character.spellSlots[level as keyof SpellSlots];\r\n            if (slot) {\r\n              resetSpellSlots[level as keyof SpellSlots] = {\r\n                ...slot,\r\n                used: 0,\r\n              };\r\n            }\r\n          }\r\n\r\n          // Reset Pact Magic slots (if Warlock)\r\n          let resetPactMagic = character.pactMagic;\r\n          if (resetPactMagic) {\r\n            resetPactMagic = {\r\n              ...resetPactMagic,\r\n              slots: {\r\n                ...resetPactMagic.slots,\r\n                used: 0,\r\n              },\r\n            };\r\n          }\r\n\r\n          // Reset ALL hit dice\r\n          const resetHitDicePools = { ...character.hitDicePools };\r\n          Object.keys(resetHitDicePools).forEach(dieType => {\r\n            resetHitDicePools[dieType] = {\r\n              ...resetHitDicePools[dieType],\r\n              used: 0,\r\n            };\r\n          });\r\n\r\n          // Reset HP to max (remove temp HP, heal to full)\r\n          const resetHitPoints = {\r\n            ...character.hitPoints,\r\n            current: character.hitPoints.max,\r\n            temporary: 0,\r\n            deathSaves: undefined, // Clear death saves\r\n          };\r\n\r\n          // Reset reaction\r\n          const resetReaction = {\r\n            hasUsedReaction: false,\r\n          };\r\n\r\n          // Reset temp AC\r\n          const resetTempArmorClass = 0;\r\n\r\n          return {\r\n            character: {\r\n              ...character,\r\n              trackableTraits: resetTrackableTraits,\r\n              extendedFeatures: resetExtendedFeatures,\r\n              spellSlots: resetSpellSlots,\r\n              pactMagic: resetPactMagic,\r\n              hitDicePools: resetHitDicePools,\r\n              hitPoints: resetHitPoints,\r\n              reaction: resetReaction,\r\n              tempArmorClass: resetTempArmorClass,\r\n              daysSpent: (character.daysSpent || 0) + 1, // Increment days spent on long rest\r\n            },\r\n            hasUnsavedChanges: true,\r\n            saveStatus: 'saving',\r\n          };\r\n        });\r\n      },\r\n\r\n      // Campaign tracking\r\n      updateDaysSpent: (days: number) => {\r\n        set(state => ({\r\n          character: {\r\n            ...state.character,\r\n            daysSpent: Math.max(0, days),\r\n          },\r\n          hasUnsavedChanges: true,\r\n          saveStatus: 'saving' as SaveStatus,\r\n        }));\r\n      },\r\n\r\n      incrementDaysSpent: (amount = 1) => {\r\n        set(state => ({\r\n          character: {\r\n            ...state.character,\r\n            daysSpent: Math.max(0, (state.character.daysSpent || 0) + amount),\r\n          },\r\n          hasUnsavedChanges: true,\r\n          saveStatus: 'saving' as SaveStatus,\r\n        }));\r\n      },\r\n\r\n      updateCharacterBackground: updates => {\r\n        set(state => ({\r\n          character: {\r\n            ...state.character,\r\n            characterBackground: {\r\n              ...state.character.characterBackground,\r\n              ...updates,\r\n            },\r\n          },\r\n          hasUnsavedChanges: true,\r\n          saveStatus: 'saving' as SaveStatus,\r\n        }));\r\n      },\r\n\r\n      // Weapon management actions\r\n      addWeapon: weapon => {\r\n        set(state => {\r\n          const newWeapon: Weapon = {\r\n            ...weapon,\r\n            id: generateId(),\r\n            createdAt: new Date().toISOString(),\r\n            updatedAt: new Date().toISOString(),\r\n          };\r\n\r\n          return {\r\n            character: {\r\n              ...state.character,\r\n              weapons: [...state.character.weapons, newWeapon],\r\n            },\r\n            hasUnsavedChanges: true,\r\n            saveStatus: 'saving',\r\n          };\r\n        });\r\n      },\r\n\r\n      updateWeapon: (id, updates) => {\r\n        set(state => ({\r\n          character: {\r\n            ...state.character,\r\n            weapons: state.character.weapons.map(weapon =>\r\n              weapon.id === id\r\n                ? { ...weapon, ...updates, updatedAt: new Date().toISOString() }\r\n                : weapon\r\n            ),\r\n          },\r\n          hasUnsavedChanges: true,\r\n          saveStatus: 'saving',\r\n        }));\r\n      },\r\n\r\n      deleteWeapon: id => {\r\n        set(state => ({\r\n          character: {\r\n            ...state.character,\r\n            weapons: state.character.weapons.filter(weapon => weapon.id !== id),\r\n          },\r\n          hasUnsavedChanges: true,\r\n          saveStatus: 'saving',\r\n        }));\r\n      },\r\n\r\n      equipWeapon: (id, equipped) => {\r\n        set(state => ({\r\n          character: {\r\n            ...state.character,\r\n            weapons: state.character.weapons.map(weapon =>\r\n              weapon.id === id\r\n                ? {\r\n                    ...weapon,\r\n                    isEquipped: equipped,\r\n                    updatedAt: new Date().toISOString(),\r\n                  }\r\n                : weapon\r\n            ),\r\n          },\r\n          hasUnsavedChanges: true,\r\n          saveStatus: 'saving',\r\n        }));\r\n      },\r\n\r\n      reorderWeapons: (sourceIndex: number, destinationIndex: number) => {\r\n        set(state => {\r\n          const weapons = [...state.character.weapons];\r\n          const [removed] = weapons.splice(sourceIndex, 1);\r\n          weapons.splice(destinationIndex, 0, removed);\r\n\r\n          // Update all weapons with new timestamps\r\n          const updatedWeapons = weapons.map(weapon => ({\r\n            ...weapon,\r\n            updatedAt: new Date().toISOString(),\r\n          }));\r\n\r\n          return {\r\n            character: {\r\n              ...state.character,\r\n              weapons: updatedWeapons,\r\n            },\r\n            hasUnsavedChanges: true,\r\n            saveStatus: 'saving',\r\n          };\r\n        });\r\n      },\r\n\r\n      // Magic item management actions\r\n      addMagicItem: item => {\r\n        set(state => {\r\n          const newItem: MagicItem = {\r\n            ...item,\r\n            id: generateId(),\r\n            createdAt: new Date().toISOString(),\r\n            updatedAt: new Date().toISOString(),\r\n          };\r\n\r\n          return {\r\n            character: {\r\n              ...state.character,\r\n              magicItems: [...(state.character.magicItems || []), newItem],\r\n            },\r\n            hasUnsavedChanges: true,\r\n            saveStatus: 'saving',\r\n          };\r\n        });\r\n      },\r\n\r\n      updateMagicItem: (id, updates) => {\r\n        set(state => ({\r\n          character: {\r\n            ...state.character,\r\n            magicItems: (state.character.magicItems || []).map(item =>\r\n              item.id === id\r\n                ? { ...item, ...updates, updatedAt: new Date().toISOString() }\r\n                : item\r\n            ),\r\n          },\r\n          hasUnsavedChanges: true,\r\n          saveStatus: 'saving',\r\n        }));\r\n      },\r\n\r\n      deleteMagicItem: id => {\r\n        set(state => ({\r\n          character: {\r\n            ...state.character,\r\n            magicItems: (state.character.magicItems || []).filter(\r\n              item => item.id !== id\r\n            ),\r\n          },\r\n          hasUnsavedChanges: true,\r\n          saveStatus: 'saving',\r\n        }));\r\n      },\r\n\r\n      attuneMagicItem: (id, attuned) => {\r\n        set(state => ({\r\n          character: {\r\n            ...state.character,\r\n            magicItems: (state.character.magicItems || []).map(item =>\r\n              item.id === id\r\n                ? {\r\n                    ...item,\r\n                    isAttuned: attuned,\r\n                    updatedAt: new Date().toISOString(),\r\n                  }\r\n                : item\r\n            ),\r\n          },\r\n          hasUnsavedChanges: true,\r\n          saveStatus: 'saving',\r\n        }));\r\n      },\r\n\r\n      updateAttunementSlots: max => {\r\n        set(state => ({\r\n          character: {\r\n            ...state.character,\r\n            attunementSlots: {\r\n              ...state.character.attunementSlots,\r\n              max,\r\n            },\r\n          },\r\n          hasUnsavedChanges: true,\r\n          saveStatus: 'saving',\r\n        }));\r\n      },\r\n\r\n      reorderMagicItems: (sourceIndex: number, destinationIndex: number) => {\r\n        set(state => {\r\n          const magicItems = [...(state.character.magicItems || [])];\r\n          const [removed] = magicItems.splice(sourceIndex, 1);\r\n          magicItems.splice(destinationIndex, 0, removed);\r\n\r\n          // Update all magic items with new timestamps\r\n          const updatedMagicItems = magicItems.map(item => ({\r\n            ...item,\r\n            updatedAt: new Date().toISOString(),\r\n          }));\r\n\r\n          return {\r\n            character: {\r\n              ...state.character,\r\n              magicItems: updatedMagicItems,\r\n            },\r\n            hasUnsavedChanges: true,\r\n            saveStatus: 'saving',\r\n          };\r\n        });\r\n      },\r\n\r\n      // Armor management\r\n      addArmorItem: item => {\r\n        set(state => {\r\n          const newItem: ArmorItem = {\r\n            ...item,\r\n            id: generateId(),\r\n            createdAt: new Date().toISOString(),\r\n            updatedAt: new Date().toISOString(),\r\n          };\r\n\r\n          return {\r\n            character: {\r\n              ...state.character,\r\n              armorItems: [...(state.character.armorItems || []), newItem],\r\n            },\r\n            hasUnsavedChanges: true,\r\n            saveStatus: 'saving',\r\n          };\r\n        });\r\n      },\r\n\r\n      updateArmorItem: (id, updates) => {\r\n        set(state => ({\r\n          character: {\r\n            ...state.character,\r\n            armorItems: state.character.armorItems.map(item =>\r\n              item.id === id\r\n                ? { ...item, ...updates, updatedAt: new Date().toISOString() }\r\n                : item\r\n            ),\r\n          },\r\n          hasUnsavedChanges: true,\r\n          saveStatus: 'saving',\r\n        }));\r\n      },\r\n\r\n      deleteArmorItem: id => {\r\n        set(state => ({\r\n          character: {\r\n            ...state.character,\r\n            armorItems: state.character.armorItems.filter(\r\n              item => item.id !== id\r\n            ),\r\n          },\r\n          hasUnsavedChanges: true,\r\n          saveStatus: 'saving',\r\n        }));\r\n      },\r\n\r\n      equipArmorItem: (id, equipped) => {\r\n        set(state => ({\r\n          character: {\r\n            ...state.character,\r\n            armorItems: state.character.armorItems.map(item =>\r\n              item.id === id\r\n                ? {\r\n                    ...item,\r\n                    isEquipped: equipped,\r\n                    updatedAt: new Date().toISOString(),\r\n                  }\r\n                : item\r\n            ),\r\n          },\r\n          hasUnsavedChanges: true,\r\n          saveStatus: 'saving',\r\n        }));\r\n      },\r\n\r\n      reorderArmorItems: (sourceIndex: number, destinationIndex: number) => {\r\n        set(state => {\r\n          const armorItems = [...state.character.armorItems];\r\n          const [removed] = armorItems.splice(sourceIndex, 1);\r\n          armorItems.splice(destinationIndex, 0, removed);\r\n\r\n          // Update all armor items with new timestamps\r\n          const updatedArmorItems = armorItems.map(item => ({\r\n            ...item,\r\n            updatedAt: new Date().toISOString(),\r\n          }));\r\n\r\n          return {\r\n            character: {\r\n              ...state.character,\r\n              armorItems: updatedArmorItems,\r\n            },\r\n            hasUnsavedChanges: true,\r\n            saveStatus: 'saving',\r\n          };\r\n        });\r\n      },\r\n\r\n      // Inventory management\r\n      addInventoryItem: item => {\r\n        set(state => {\r\n          const newItem: InventoryItem = {\r\n            ...item,\r\n            id: generateId(),\r\n            createdAt: new Date().toISOString(),\r\n            updatedAt: new Date().toISOString(),\r\n          };\r\n\r\n          return {\r\n            character: {\r\n              ...state.character,\r\n              inventoryItems: [\r\n                ...(state.character.inventoryItems || []),\r\n                newItem,\r\n              ],\r\n            },\r\n            hasUnsavedChanges: true,\r\n            saveStatus: 'saving',\r\n          };\r\n        });\r\n      },\r\n\r\n      updateInventoryItem: (id, updates) => {\r\n        set(state => ({\r\n          character: {\r\n            ...state.character,\r\n            inventoryItems: state.character.inventoryItems.map(item =>\r\n              item.id === id\r\n                ? { ...item, ...updates, updatedAt: new Date().toISOString() }\r\n                : item\r\n            ),\r\n          },\r\n          hasUnsavedChanges: true,\r\n          saveStatus: 'saving',\r\n        }));\r\n      },\r\n\r\n      deleteInventoryItem: id => {\r\n        set(state => ({\r\n          character: {\r\n            ...state.character,\r\n            inventoryItems: state.character.inventoryItems.filter(\r\n              item => item.id !== id\r\n            ),\r\n          },\r\n          hasUnsavedChanges: true,\r\n          saveStatus: 'saving',\r\n        }));\r\n      },\r\n\r\n      updateItemQuantity: (id, quantity) => {\r\n        set(state => ({\r\n          character: {\r\n            ...state.character,\r\n            inventoryItems: state.character.inventoryItems.map(item =>\r\n              item.id === id ? { ...item, quantity } : item\r\n            ),\r\n          },\r\n          hasUnsavedChanges: true,\r\n          saveStatus: 'saving',\r\n        }));\r\n      },\r\n\r\n      reorderInventoryItems: (\r\n        sourceIndex: number,\r\n        destinationIndex: number\r\n      ) => {\r\n        set(state => {\r\n          const inventoryItems = [...state.character.inventoryItems];\r\n          const [removed] = inventoryItems.splice(sourceIndex, 1);\r\n          inventoryItems.splice(destinationIndex, 0, removed);\r\n\r\n          // Update all inventory items with new timestamps\r\n          const updatedInventoryItems = inventoryItems.map(item => ({\r\n            ...item,\r\n            updatedAt: new Date().toISOString(),\r\n          }));\r\n\r\n          return {\r\n            character: {\r\n              ...state.character,\r\n              inventoryItems: updatedInventoryItems,\r\n            },\r\n            hasUnsavedChanges: true,\r\n            saveStatus: 'saving',\r\n          };\r\n        });\r\n      },\r\n\r\n      // Currency management\r\n      updateCurrency: updates => {\r\n        set(state => ({\r\n          character: {\r\n            ...state.character,\r\n            currency: {\r\n              ...state.character.currency,\r\n              ...updates,\r\n            },\r\n          },\r\n          hasUnsavedChanges: true,\r\n          saveStatus: 'saving',\r\n        }));\r\n      },\r\n\r\n      addCurrency: (type, amount) => {\r\n        set(state => ({\r\n          character: {\r\n            ...state.character,\r\n            currency: {\r\n              ...state.character.currency,\r\n              [type]: (state.character.currency[type] || 0) + amount,\r\n            },\r\n          },\r\n          hasUnsavedChanges: true,\r\n          saveStatus: 'saving',\r\n        }));\r\n      },\r\n\r\n      subtractCurrency: (type, amount) => {\r\n        set(state => ({\r\n          character: {\r\n            ...state.character,\r\n            currency: {\r\n              ...state.character.currency,\r\n              [type]: Math.max(\r\n                0,\r\n                (state.character.currency[type] || 0) - amount\r\n              ),\r\n            },\r\n          },\r\n          hasUnsavedChanges: true,\r\n          saveStatus: 'saving',\r\n        }));\r\n      },\r\n\r\n      // Spellbook management\r\n      addSpellToSpellbook: spellId => {\r\n        set(state => {\r\n          const isAlreadyKnown =\r\n            state.character.spellbook.knownSpells.includes(spellId);\r\n          if (!isAlreadyKnown) {\r\n            return {\r\n              character: {\r\n                ...state.character,\r\n                spellbook: {\r\n                  ...state.character.spellbook,\r\n                  knownSpells: [\r\n                    ...state.character.spellbook.knownSpells,\r\n                    spellId,\r\n                  ],\r\n                },\r\n              },\r\n              hasUnsavedChanges: true,\r\n              saveStatus: 'saving',\r\n            };\r\n          }\r\n          return state;\r\n        });\r\n      },\r\n\r\n      removeSpellFromSpellbook: spellId => {\r\n        set(state => ({\r\n          character: {\r\n            ...state.character,\r\n            spellbook: {\r\n              ...state.character.spellbook,\r\n              knownSpells: state.character.spellbook.knownSpells.filter(\r\n                id => id !== spellId\r\n              ),\r\n              preparedSpells: state.character.spellbook.preparedSpells.filter(\r\n                id => id !== spellId\r\n              ),\r\n              favoriteSpells: state.character.spellbook.favoriteSpells.filter(\r\n                id => id !== spellId\r\n              ),\r\n            },\r\n          },\r\n          hasUnsavedChanges: true,\r\n          saveStatus: 'saving',\r\n        }));\r\n      },\r\n\r\n      toggleSpellFavorite: spellId => {\r\n        set(state => {\r\n          const isFavorite =\r\n            state.character.spellbook.favoriteSpells.includes(spellId);\r\n          return {\r\n            character: {\r\n              ...state.character,\r\n              spellbook: {\r\n                ...state.character.spellbook,\r\n                favoriteSpells: isFavorite\r\n                  ? state.character.spellbook.favoriteSpells.filter(\r\n                      id => id !== spellId\r\n                    )\r\n                  : [...state.character.spellbook.favoriteSpells, spellId],\r\n              },\r\n            },\r\n            hasUnsavedChanges: true,\r\n            saveStatus: 'saving',\r\n          };\r\n        });\r\n      },\r\n\r\n      prepareSpell: spellId => {\r\n        set(state => {\r\n          const isAlreadyPrepared =\r\n            state.character.spellbook.preparedSpells.includes(spellId);\r\n          if (!isAlreadyPrepared) {\r\n            return {\r\n              character: {\r\n                ...state.character,\r\n                spellbook: {\r\n                  ...state.character.spellbook,\r\n                  preparedSpells: [\r\n                    ...state.character.spellbook.preparedSpells,\r\n                    spellId,\r\n                  ],\r\n                },\r\n              },\r\n              hasUnsavedChanges: true,\r\n              saveStatus: 'saving',\r\n            };\r\n          }\r\n          return state;\r\n        });\r\n      },\r\n\r\n      unprepareSpell: spellId => {\r\n        set(state => ({\r\n          character: {\r\n            ...state.character,\r\n            spellbook: {\r\n              ...state.character.spellbook,\r\n              preparedSpells: state.character.spellbook.preparedSpells.filter(\r\n                id => id !== spellId\r\n              ),\r\n            },\r\n          },\r\n          hasUnsavedChanges: true,\r\n          saveStatus: 'saving',\r\n        }));\r\n      },\r\n\r\n      updateSpellbookSettings: settings => {\r\n        set(state => ({\r\n          character: {\r\n            ...state.character,\r\n            spellbook: {\r\n              ...state.character.spellbook,\r\n              spellbookSettings: {\r\n                ...state.character.spellbook.spellbookSettings,\r\n                ...settings,\r\n              },\r\n            },\r\n          },\r\n          hasUnsavedChanges: true,\r\n          saveStatus: 'saving',\r\n        }));\r\n      },\r\n\r\n      addCustomSpell: (spell: ProcessedSpell) => {\r\n        set(state => ({\r\n          character: {\r\n            ...state.character,\r\n            spellbook: {\r\n              ...state.character.spellbook,\r\n              customSpells: [\r\n                ...(state.character.spellbook.customSpells || []),\r\n                spell,\r\n              ],\r\n            },\r\n          },\r\n          hasUnsavedChanges: true,\r\n          saveStatus: 'saving',\r\n        }));\r\n      },\r\n\r\n      removeCustomSpell: spellId => {\r\n        set(state => ({\r\n          character: {\r\n            ...state.character,\r\n            spellbook: {\r\n              ...state.character.spellbook,\r\n              customSpells: (\r\n                state.character.spellbook.customSpells || []\r\n              ).filter(s => s.id !== spellId),\r\n            },\r\n          },\r\n          hasUnsavedChanges: true,\r\n          saveStatus: 'saving',\r\n        }));\r\n      },\r\n\r\n      reorderPreparedSpells: (\r\n        sourceIndex: number,\r\n        destinationIndex: number\r\n      ) => {\r\n        set(state => {\r\n          const preparedSpells = [...state.character.spellbook.preparedSpells];\r\n          const [removed] = preparedSpells.splice(sourceIndex, 1);\r\n          preparedSpells.splice(destinationIndex, 0, removed);\r\n\r\n          return {\r\n            character: {\r\n              ...state.character,\r\n              spellbook: {\r\n                ...state.character.spellbook,\r\n                preparedSpells,\r\n              },\r\n            },\r\n            hasUnsavedChanges: true,\r\n            saveStatus: 'saving',\r\n          };\r\n        });\r\n      },\r\n\r\n      reorderSpells: (sourceIndex: number, destinationIndex: number) => {\r\n        set(state => {\r\n          const spells = [...state.character.spells];\r\n          const [removed] = spells.splice(sourceIndex, 1);\r\n          spells.splice(destinationIndex, 0, removed);\r\n\r\n          return {\r\n            character: {\r\n              ...state.character,\r\n              spells,\r\n            },\r\n            hasUnsavedChanges: true,\r\n            saveStatus: 'saving',\r\n          };\r\n        });\r\n      },\r\n\r\n      // Persistence actions\r\n      saveCharacter: () => {\r\n        try {\r\n          // Save to localStorage (handled by persist middleware)\r\n          set({\r\n            saveStatus: 'saved',\r\n            lastSaved: new Date(),\r\n            hasUnsavedChanges: false,\r\n          });\r\n        } catch (error) {\r\n          console.error('Failed to save character:', error);\r\n          set({ saveStatus: 'error' });\r\n        }\r\n      },\r\n\r\n      loadCharacter: character => {\r\n        set({\r\n          character,\r\n          saveStatus: 'saved',\r\n          lastSaved: new Date(),\r\n          hasUnsavedChanges: false,\r\n        });\r\n      },\r\n\r\n      resetCharacter: () => {\r\n        set({\r\n          character: {\r\n            ...DEFAULT_CHARACTER_STATE,\r\n            id: generateId(),\r\n          },\r\n          saveStatus: 'saved',\r\n          lastSaved: new Date(),\r\n          hasUnsavedChanges: false,\r\n        });\r\n      },\r\n\r\n      exportCharacter: () => {\r\n        const state = get();\r\n        return {\r\n          version: APP_VERSION,\r\n          exportDate: new Date().toISOString(),\r\n          character: state.character,\r\n        };\r\n      },\r\n\r\n      importCharacter: exportData => {\r\n        try {\r\n          // Basic validation\r\n          if (\r\n            !exportData.character ||\r\n            typeof exportData.character !== 'object'\r\n          ) {\r\n            throw new Error('Invalid character data');\r\n          }\r\n\r\n          // Version compatibility check (for future use)\r\n          if (exportData.version && exportData.version !== APP_VERSION) {\r\n            console.warn(\r\n              `Version mismatch: expected ${APP_VERSION}, got ${exportData.version}`\r\n            );\r\n          }\r\n\r\n          set({\r\n            character: exportData.character,\r\n            saveStatus: 'saved',\r\n            lastSaved: new Date(),\r\n            hasUnsavedChanges: false,\r\n          });\r\n\r\n          return true;\r\n        } catch (error) {\r\n          console.error('Failed to import character:', error);\r\n          set({ saveStatus: 'error' });\r\n          return false;\r\n        }\r\n      },\r\n\r\n      // Auto-save control\r\n      setSaveStatus: status => {\r\n        set({ saveStatus: status });\r\n      },\r\n\r\n      markSaved: () => {\r\n        set({\r\n          saveStatus: 'saved',\r\n          lastSaved: new Date(),\r\n          hasUnsavedChanges: false,\r\n        });\r\n      },\r\n\r\n      markUnsaved: () => {\r\n        set({\r\n          hasUnsavedChanges: true,\r\n          saveStatus: 'saving',\r\n        });\r\n      },\r\n    }),\r\n    {\r\n      name: STORAGE_KEY,\r\n      storage: createJSONStorage(() => localStorage),\r\n      // Only persist the character data and save metadata\r\n      partialize: state => ({\r\n        character: state.character,\r\n        lastSaved: state.lastSaved,\r\n      }),\r\n      // Handle rehydration and migration\r\n      onRehydrateStorage: () => state => {\r\n        if (state) {\r\n          // Migrate character data if needed\r\n          state.character = migrateCharacterData(state.character);\r\n          state.saveStatus = 'saved';\r\n          state.hasUnsavedChanges = false;\r\n          state.hasHydrated = true;\r\n        }\r\n      },\r\n    }\r\n  )\r\n);\r\n"],"names":[],"mappings":"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","debugId":null}}]
}