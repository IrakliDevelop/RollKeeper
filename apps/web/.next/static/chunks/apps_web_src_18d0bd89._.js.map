{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 4, "column": 0}, "map": {"version":3,"sources":["file:///home/irakli/Projects/RollKeeper/apps/web/src/hooks/useAutoSave.ts"],"sourcesContent":["import { useEffect, useRef, useCallback } from 'react';\r\nimport { useCharacterStore } from '@/store/characterStore';\r\nimport { AUTOSAVE_DELAY } from '@/utils/constants';\r\n\r\ninterface UseAutoSaveOptions {\r\n  delay?: number;\r\n  enabled?: boolean;\r\n}\r\n\r\nexport const useAutoSave = (options: UseAutoSaveOptions = {}) => {\r\n  const { delay = AUTOSAVE_DELAY, enabled = true } = options;\r\n\r\n  const saveTimeoutRef = useRef<NodeJS.Timeout | null>(null);\r\n  const isInitialMount = useRef(true);\r\n\r\n  const {\r\n    hasUnsavedChanges,\r\n    saveStatus,\r\n    saveCharacter,\r\n    setSaveStatus,\r\n    markSaved,\r\n  } = useCharacterStore();\r\n\r\n  // Debounced save function\r\n  const debouncedSave = useCallback(() => {\r\n    if (saveTimeoutRef.current) {\r\n      clearTimeout(saveTimeoutRef.current);\r\n    }\r\n\r\n    if (!enabled || !hasUnsavedChanges) {\r\n      return;\r\n    }\r\n\r\n    setSaveStatus('saving');\r\n\r\n    saveTimeoutRef.current = setTimeout(() => {\r\n      try {\r\n        saveCharacter();\r\n        setSaveStatus('saved');\r\n        markSaved();\r\n      } catch (error) {\r\n        console.error('Auto-save failed:', error);\r\n        setSaveStatus('error');\r\n      }\r\n    }, delay);\r\n  }, [\r\n    enabled,\r\n    hasUnsavedChanges,\r\n    delay,\r\n    saveCharacter,\r\n    setSaveStatus,\r\n    markSaved,\r\n  ]);\r\n\r\n  // Manual save function (for Ctrl+S, etc.)\r\n  const manualSave = useCallback(() => {\r\n    if (saveTimeoutRef.current) {\r\n      clearTimeout(saveTimeoutRef.current);\r\n    }\r\n\r\n    if (!hasUnsavedChanges) {\r\n      return;\r\n    }\r\n\r\n    setSaveStatus('saving');\r\n\r\n    try {\r\n      saveCharacter();\r\n      setSaveStatus('saved');\r\n      markSaved();\r\n    } catch (error) {\r\n      console.error('Manual save failed:', error);\r\n      setSaveStatus('error');\r\n    }\r\n  }, [hasUnsavedChanges, saveCharacter, setSaveStatus, markSaved]);\r\n\r\n  // Effect to trigger auto-save when data changes\r\n  useEffect(() => {\r\n    // Skip auto-save on initial mount to avoid saving default state\r\n    if (isInitialMount.current) {\r\n      isInitialMount.current = false;\r\n      return;\r\n    }\r\n\r\n    if (hasUnsavedChanges && enabled) {\r\n      debouncedSave();\r\n    }\r\n\r\n    // Cleanup timeout on unmount\r\n    return () => {\r\n      if (saveTimeoutRef.current) {\r\n        clearTimeout(saveTimeoutRef.current);\r\n      }\r\n    };\r\n  }, [hasUnsavedChanges, debouncedSave, enabled]);\r\n\r\n  // Keyboard shortcuts effect\r\n  useEffect(() => {\r\n    const handleKeyDown = (event: KeyboardEvent) => {\r\n      // Ctrl+S (or Cmd+S on Mac)\r\n      if ((event.ctrlKey || event.metaKey) && event.key === 's') {\r\n        event.preventDefault();\r\n        manualSave();\r\n      }\r\n    };\r\n\r\n    window.addEventListener('keydown', handleKeyDown);\r\n\r\n    return () => {\r\n      window.removeEventListener('keydown', handleKeyDown);\r\n    };\r\n  }, [manualSave]);\r\n\r\n  // Save on page beforeunload (browser close/refresh)\r\n  useEffect(() => {\r\n    const handleBeforeUnload = (event: BeforeUnloadEvent) => {\r\n      if (hasUnsavedChanges) {\r\n        // Cancel any pending auto-save\r\n        if (saveTimeoutRef.current) {\r\n          clearTimeout(saveTimeoutRef.current);\r\n        }\r\n\r\n        // Attempt immediate save\r\n        try {\r\n          saveCharacter();\r\n        } catch (error) {\r\n          console.error('Failed to save on page unload:', error);\r\n        }\r\n\r\n        // Show browser warning if there are unsaved changes\r\n        event.preventDefault();\r\n        event.returnValue = '';\r\n        return '';\r\n      }\r\n    };\r\n\r\n    window.addEventListener('beforeunload', handleBeforeUnload);\r\n\r\n    return () => {\r\n      window.removeEventListener('beforeunload', handleBeforeUnload);\r\n    };\r\n  }, [hasUnsavedChanges, saveCharacter]);\r\n\r\n  // Save on visibility change (tab switch, minimize)\r\n  useEffect(() => {\r\n    const handleVisibilityChange = () => {\r\n      if (document.visibilityState === 'hidden' && hasUnsavedChanges) {\r\n        // Cancel pending auto-save and save immediately\r\n        if (saveTimeoutRef.current) {\r\n          clearTimeout(saveTimeoutRef.current);\r\n        }\r\n\r\n        try {\r\n          saveCharacter();\r\n          markSaved();\r\n        } catch (error) {\r\n          console.error('Failed to save on visibility change:', error);\r\n        }\r\n      }\r\n    };\r\n\r\n    document.addEventListener('visibilitychange', handleVisibilityChange);\r\n\r\n    return () => {\r\n      document.removeEventListener('visibilitychange', handleVisibilityChange);\r\n    };\r\n  }, [hasUnsavedChanges, saveCharacter, markSaved]);\r\n\r\n  return {\r\n    saveStatus,\r\n    hasUnsavedChanges,\r\n    manualSave,\r\n    isAutoSaveEnabled: enabled,\r\n  };\r\n};\r\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 209, "column": 0}, "map": {"version":3,"sources":["file:///home/irakli/Projects/RollKeeper/apps/web/src/hooks/useDragAndDrop.ts"],"sourcesContent":["import { useState, useCallback } from 'react';\r\n\r\nexport interface DragDropState {\r\n  draggedIndex: number | null;\r\n  dragOverIndex: number | null;\r\n}\r\n\r\nexport interface DragDropHandlers {\r\n  handleDragStart: (e: React.DragEvent, index: number) => void;\r\n  handleDragEnd: (e: React.DragEvent) => void;\r\n  handleDragOver: (e: React.DragEvent, index: number) => void;\r\n  handleDragLeave: () => void;\r\n  handleDrop: (e: React.DragEvent, dropIndex: number) => void;\r\n}\r\n\r\nexport interface UseDragAndDropOptions {\r\n  onReorder: (sourceIndex: number, destinationIndex: number) => void;\r\n  disabled?: boolean;\r\n}\r\n\r\nexport interface UseDragAndDropReturn extends DragDropState, DragDropHandlers {\r\n  isDragging: boolean;\r\n  getDragOverStyles: (index: number) => string;\r\n  getDraggedStyles: (index: number) => string;\r\n}\r\n\r\n/**\r\n * Reusable hook for drag and drop functionality on lists\r\n */\r\nexport function useDragAndDrop({\r\n  onReorder,\r\n  disabled = false,\r\n}: UseDragAndDropOptions): UseDragAndDropReturn {\r\n  const [draggedIndex, setDraggedIndex] = useState<number | null>(null);\r\n  const [dragOverIndex, setDragOverIndex] = useState<number | null>(null);\r\n\r\n  const handleDragStart = useCallback(\r\n    (e: React.DragEvent, index: number) => {\r\n      if (disabled) return;\r\n\r\n      setDraggedIndex(index);\r\n      e.dataTransfer.effectAllowed = 'move';\r\n      e.dataTransfer.setData('text/html', e.currentTarget.outerHTML);\r\n      (e.currentTarget as HTMLElement).style.opacity = '0.5';\r\n    },\r\n    [disabled]\r\n  );\r\n\r\n  const handleDragEnd = useCallback(\r\n    (e: React.DragEvent) => {\r\n      if (disabled) return;\r\n\r\n      (e.currentTarget as HTMLElement).style.opacity = '1';\r\n      setDraggedIndex(null);\r\n      setDragOverIndex(null);\r\n    },\r\n    [disabled]\r\n  );\r\n\r\n  const handleDragOver = useCallback(\r\n    (e: React.DragEvent, index: number) => {\r\n      if (disabled) return;\r\n\r\n      e.preventDefault();\r\n      e.dataTransfer.dropEffect = 'move';\r\n      setDragOverIndex(index);\r\n    },\r\n    [disabled]\r\n  );\r\n\r\n  const handleDragLeave = useCallback(() => {\r\n    if (disabled) return;\r\n    setDragOverIndex(null);\r\n  }, [disabled]);\r\n\r\n  const handleDrop = useCallback(\r\n    (e: React.DragEvent, dropIndex: number) => {\r\n      if (disabled) return;\r\n\r\n      e.preventDefault();\r\n\r\n      if (draggedIndex !== null && draggedIndex !== dropIndex) {\r\n        onReorder(draggedIndex, dropIndex);\r\n      }\r\n\r\n      setDraggedIndex(null);\r\n      setDragOverIndex(null);\r\n    },\r\n    [disabled, draggedIndex, onReorder]\r\n  );\r\n\r\n  const getDragOverStyles = useCallback(\r\n    (index: number): string => {\r\n      return dragOverIndex === index\r\n        ? 'border-blue-400 border-2 bg-blue-50'\r\n        : '';\r\n    },\r\n    [dragOverIndex]\r\n  );\r\n\r\n  const getDraggedStyles = useCallback(\r\n    (index: number): string => {\r\n      return draggedIndex === index ? 'opacity-50' : '';\r\n    },\r\n    [draggedIndex]\r\n  );\r\n\r\n  return {\r\n    draggedIndex,\r\n    dragOverIndex,\r\n    isDragging: draggedIndex !== null,\r\n    handleDragStart,\r\n    handleDragEnd,\r\n    handleDragOver,\r\n    handleDragLeave,\r\n    handleDrop,\r\n    getDragOverStyles,\r\n    getDraggedStyles,\r\n  };\r\n}\r\n"],"names":[],"mappings":";;;;AAAA;;;AA6BO,SAAS,eAAe,KAGP;QAHO,EAC7B,SAAS,EACT,WAAW,KAAK,EACM,GAHO;;IAI7B,MAAM,CAAC,cAAc,gBAAgB,GAAG,IAAA,yKAAQ,EAAgB;IAChE,MAAM,CAAC,eAAe,iBAAiB,GAAG,IAAA,yKAAQ,EAAgB;IAElE,MAAM,kBAAkB,IAAA,4KAAW;uDACjC,CAAC,GAAoB;YACnB,IAAI,UAAU;YAEd,gBAAgB;YAChB,EAAE,YAAY,CAAC,aAAa,GAAG;YAC/B,EAAE,YAAY,CAAC,OAAO,CAAC,aAAa,EAAE,aAAa,CAAC,SAAS;YAC5D,EAAE,aAAa,CAAiB,KAAK,CAAC,OAAO,GAAG;QACnD;sDACA;QAAC;KAAS;IAGZ,MAAM,gBAAgB,IAAA,4KAAW;qDAC/B,CAAC;YACC,IAAI,UAAU;YAEb,EAAE,aAAa,CAAiB,KAAK,CAAC,OAAO,GAAG;YACjD,gBAAgB;YAChB,iBAAiB;QACnB;oDACA;QAAC;KAAS;IAGZ,MAAM,iBAAiB,IAAA,4KAAW;sDAChC,CAAC,GAAoB;YACnB,IAAI,UAAU;YAEd,EAAE,cAAc;YAChB,EAAE,YAAY,CAAC,UAAU,GAAG;YAC5B,iBAAiB;QACnB;qDACA;QAAC;KAAS;IAGZ,MAAM,kBAAkB,IAAA,4KAAW;uDAAC;YAClC,IAAI,UAAU;YACd,iBAAiB;QACnB;sDAAG;QAAC;KAAS;IAEb,MAAM,aAAa,IAAA,4KAAW;kDAC5B,CAAC,GAAoB;YACnB,IAAI,UAAU;YAEd,EAAE,cAAc;YAEhB,IAAI,iBAAiB,QAAQ,iBAAiB,WAAW;gBACvD,UAAU,cAAc;YAC1B;YAEA,gBAAgB;YAChB,iBAAiB;QACnB;iDACA;QAAC;QAAU;QAAc;KAAU;IAGrC,MAAM,oBAAoB,IAAA,4KAAW;yDACnC,CAAC;YACC,OAAO,kBAAkB,QACrB,wCACA;QACN;wDACA;QAAC;KAAc;IAGjB,MAAM,mBAAmB,IAAA,4KAAW;wDAClC,CAAC;YACC,OAAO,iBAAiB,QAAQ,eAAe;QACjD;uDACA;QAAC;KAAa;IAGhB,OAAO;QACL;QACA;QACA,YAAY,iBAAiB;QAC7B;QACA;QACA;QACA;QACA;QACA;QACA;IACF;AACF;GA1FgB","debugId":null}},
    {"offset": {"line": 310, "column": 0}, "map": {"version":3,"sources":["file:///home/irakli/Projects/RollKeeper/apps/web/src/hooks/useClassData.ts"],"sourcesContent":["import { useState, useEffect } from 'react';\r\nimport { ProcessedClass } from '@/types/classes';\r\nimport { fetchClasses } from '@/utils/apiClient';\r\n\r\nexport function useClassData() {\r\n  const [classData, setClassData] = useState<ProcessedClass[]>([]);\r\n  const [loading, setLoading] = useState(true);\r\n  const [error, setError] = useState<string | null>(null);\r\n\r\n  useEffect(() => {\r\n    async function loadClasses() {\r\n      try {\r\n        setLoading(true);\r\n        const classes = await fetchClasses();\r\n        setClassData(classes);\r\n        setError(null);\r\n      } catch (err) {\r\n        console.error('Failed to load class data:', err);\r\n        setError('Failed to load class data');\r\n      } finally {\r\n        setLoading(false);\r\n      }\r\n    }\r\n\r\n    loadClasses();\r\n  }, []);\r\n\r\n  return { classData, loading, error };\r\n}\r\n"],"names":[],"mappings":";;;;AAAA;AAEA;;;;AAEO,SAAS;;IACd,MAAM,CAAC,WAAW,aAAa,GAAG,IAAA,yKAAQ,EAAmB,EAAE;IAC/D,MAAM,CAAC,SAAS,WAAW,GAAG,IAAA,yKAAQ,EAAC;IACvC,MAAM,CAAC,OAAO,SAAS,GAAG,IAAA,yKAAQ,EAAgB;IAElD,IAAA,0KAAS;kCAAC;YACR,eAAe;gBACb,IAAI;oBACF,WAAW;oBACX,MAAM,UAAU,MAAM,IAAA,2JAAY;oBAClC,aAAa;oBACb,SAAS;gBACX,EAAE,OAAO,KAAK;oBACZ,QAAQ,KAAK,CAAC,8BAA8B;oBAC5C,SAAS;gBACX,SAAU;oBACR,WAAW;gBACb;YACF;YAEA;QACF;iCAAG,EAAE;IAEL,OAAO;QAAE;QAAW;QAAS;IAAM;AACrC;GAxBgB","debugId":null}},
    {"offset": {"line": 356, "column": 0}, "map": {"version":3,"sources":["file:///home/irakli/Projects/RollKeeper/apps/web/src/hooks/useDiceRoller.ts"],"sourcesContent":["import { useState, useEffect, useCallback, useRef } from 'react';\r\n// @ts-expect-error - DiceBox is not typed\r\nimport DiceBox from '@3d-dice/dice-box';\r\nimport { DiceRollResults, RollSummary } from '@/types/dice';\r\nimport { calculateRollSummary, autoClearDice } from '@/utils/diceUtils';\r\n\r\ninterface DiceBoxInstance {\r\n  clear?: () => void;\r\n  roll?: (notation: string) => Promise<DiceRollResults>;\r\n  init?: () => Promise<void>;\r\n}\r\n\r\nexport interface UseDiceRollerOptions {\r\n  containerId: string;\r\n  theme?: string;\r\n  themeColor?: string;\r\n  scale?: number;\r\n  autoClearDelay?: number;\r\n  onRollComplete?: (summary: RollSummary) => void;\r\n  onError?: (error: string) => void;\r\n  onLog?: (message: string) => void;\r\n}\r\n\r\nexport interface UseDiceRollerReturn {\r\n  isInitialized: boolean;\r\n  isRolling: boolean;\r\n  rollHistory: RollSummary[];\r\n  roll: (notation: string) => Promise<RollSummary | null>;\r\n  clearDice: () => void;\r\n  clearHistory: () => void;\r\n  setAutoClearDelay: (delay: number) => void;\r\n  autoClearDelay: number;\r\n}\r\n\r\nexport function useDiceRoller({\r\n  containerId,\r\n  theme = 'diceOfRolling',\r\n  themeColor = '#feea03',\r\n  scale = 6,\r\n  autoClearDelay: initialAutoClearDelay = 10000,\r\n  onRollComplete,\r\n  onError,\r\n  onLog,\r\n}: UseDiceRollerOptions): UseDiceRollerReturn {\r\n  const [diceBox, setDiceBox] = useState<DiceBoxInstance | null>(null);\r\n  const [isInitialized, setIsInitialized] = useState(false);\r\n  const [isRolling, setIsRolling] = useState(false);\r\n  const [rollHistory, setRollHistory] = useState<RollSummary[]>([]);\r\n  const [autoClearDelay, setAutoClearDelay] = useState(initialAutoClearDelay);\r\n  const [isMounted, setIsMounted] = useState(false);\r\n\r\n  // Use ref to avoid recreating log function on every render\r\n  const onLogRef = useRef(onLog);\r\n  const onErrorRef = useRef(onError);\r\n\r\n  // Update refs when props change\r\n  useEffect(() => {\r\n    onLogRef.current = onLog;\r\n    onErrorRef.current = onError;\r\n  });\r\n\r\n  // Stable log function\r\n  const log = useCallback((message: string) => {\r\n    console.log(`[DiceRoller] ${message}`);\r\n    if (onLogRef.current) {\r\n      onLogRef.current(message);\r\n    }\r\n  }, []);\r\n\r\n  // Track mounting state\r\n  useEffect(() => {\r\n    setIsMounted(true);\r\n    return () => setIsMounted(false);\r\n  }, []);\r\n\r\n  // Initialize dice box\r\n  useEffect(() => {\r\n    if (!isInitialized && isMounted) {\r\n      const initializeDiceBox = () => {\r\n        // Check if DOM element exists\r\n        const containerElement = document.querySelector(`#${containerId}`);\r\n        if (!containerElement) {\r\n          log(\r\n            `Container element #${containerId} not found, waiting for DOM...`\r\n          );\r\n          return false;\r\n        }\r\n\r\n        const rect = (containerElement as HTMLElement).getBoundingClientRect();\r\n        log(\r\n          `Container element #${containerId} found at ${Math.round(rect.left)},${Math.round(rect.top)} size ${Math.round(rect.width)}x${Math.round(rect.height)} - creating DiceBox...`\r\n        );\r\n\r\n        const selector = `#${containerId}`;\r\n        const box = new DiceBox(selector, {\r\n          assetPath: '/assets/',\r\n          scale,\r\n          theme,\r\n          themeColor,\r\n          offscreen: false,\r\n          throwForce: 5,\r\n          gravity: 1,\r\n          mass: 1,\r\n          spinForce: 6,\r\n        });\r\n\r\n        setDiceBox(box);\r\n        log('DiceBox instance created');\r\n\r\n        box\r\n          .init()\r\n          .then(() => {\r\n            log('DiceBox initialized successfully');\r\n            setIsInitialized(true);\r\n          })\r\n          .catch((error: unknown) => {\r\n            const errorMessage =\r\n              error instanceof Error ? error.message : String(error);\r\n            const message = `Failed to initialize DiceBox: ${errorMessage}`;\r\n            log(message);\r\n            if (onErrorRef.current) {\r\n              onErrorRef.current(message);\r\n            }\r\n          });\r\n\r\n        return true;\r\n      };\r\n\r\n      // Try to initialize immediately\r\n      if (!initializeDiceBox()) {\r\n        // If DOM not ready, wait a bit and try again (only once)\r\n        const timer = setTimeout(() => {\r\n          initializeDiceBox();\r\n        }, 100);\r\n\r\n        return () => clearTimeout(timer);\r\n      }\r\n    }\r\n  }, [containerId, scale, theme, themeColor, isInitialized, isMounted, log]);\r\n\r\n  // Roll dice function\r\n  const roll = useCallback(\r\n    async (notation: string): Promise<RollSummary | null> => {\r\n      if (!diceBox || !isInitialized) {\r\n        const message = 'DiceBox not ready yet';\r\n        log(message);\r\n        if (onErrorRef.current) {\r\n          onErrorRef.current(message);\r\n        }\r\n        return null;\r\n      }\r\n\r\n      if (isRolling) {\r\n        const message = 'Already rolling dice, please wait';\r\n        log(message);\r\n        if (onErrorRef.current) {\r\n          onErrorRef.current(message);\r\n        }\r\n        return null;\r\n      }\r\n\r\n      setIsRolling(true);\r\n      log(`Rolling: ${notation}`);\r\n\r\n      try {\r\n        if (!diceBox.roll) {\r\n          throw new Error('DiceBox roll method not available');\r\n        }\r\n        const results: DiceRollResults = await diceBox.roll(notation);\r\n        log(`Roll completed: ${notation}`);\r\n\r\n        // Calculate summary\r\n        const summary = calculateRollSummary(results, notation);\r\n        setRollHistory(prev => [...prev, summary]);\r\n\r\n        log(\r\n          `Total: ${summary.finalTotal} (dice: ${summary.total}, modifier: ${summary.modifier})`\r\n        );\r\n\r\n        // Call completion callback\r\n        if (onRollComplete) {\r\n          onRollComplete(summary);\r\n        }\r\n\r\n        // Auto-clear if enabled\r\n        if (autoClearDelay > 0) {\r\n          autoClearDice(diceBox, autoClearDelay, () => {\r\n            log(`Dice auto-cleared after ${autoClearDelay}ms`);\r\n          });\r\n        }\r\n\r\n        setIsRolling(false);\r\n        return summary;\r\n      } catch (error) {\r\n        const errorMessage =\r\n          error instanceof Error ? error.message : String(error);\r\n        const message = `Error rolling dice: ${errorMessage}`;\r\n        log(message);\r\n        if (onErrorRef.current) {\r\n          onErrorRef.current(message);\r\n        }\r\n        setIsRolling(false);\r\n        return null;\r\n      }\r\n    },\r\n    [diceBox, isInitialized, isRolling, autoClearDelay, onRollComplete, log]\r\n  );\r\n\r\n  // Clear dice function\r\n  const clearDice = useCallback(() => {\r\n    if (diceBox && typeof diceBox.clear === 'function' && isInitialized) {\r\n      log('Clearing dice from screen');\r\n      try {\r\n        diceBox.clear();\r\n        log('Dice cleared successfully');\r\n      } catch (error) {\r\n        const errorMessage =\r\n          error instanceof Error ? error.message : String(error);\r\n        const message = `Error clearing dice: ${errorMessage}`;\r\n        log(message);\r\n        if (onErrorRef.current) {\r\n          onErrorRef.current(message);\r\n        }\r\n      }\r\n    } else {\r\n      const message =\r\n        'Cannot clear dice - not initialized or clear method unavailable';\r\n      log(message);\r\n      if (onErrorRef.current) {\r\n        onErrorRef.current(message);\r\n      }\r\n    }\r\n  }, [diceBox, isInitialized, log]);\r\n\r\n  // Clear history function\r\n  const clearHistory = useCallback(() => {\r\n    setRollHistory([]);\r\n    log('Roll history cleared');\r\n  }, [log]);\r\n\r\n  // Cleanup on unmount\r\n  useEffect(() => {\r\n    return () => {\r\n      if (diceBox && typeof diceBox.clear === 'function') {\r\n        try {\r\n          console.log('[DiceRoller] Cleaning up DiceBox on unmount');\r\n          diceBox.clear();\r\n        } catch (error) {\r\n          console.warn('Error during component unmount cleanup:', error);\r\n        }\r\n      }\r\n    };\r\n  }, [diceBox]);\r\n\r\n  return {\r\n    isInitialized,\r\n    isRolling,\r\n    rollHistory,\r\n    roll,\r\n    clearDice,\r\n    clearHistory,\r\n    setAutoClearDelay,\r\n    autoClearDelay,\r\n  };\r\n}\r\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 619, "column": 0}, "map": {"version":3,"sources":["file:///home/irakli/Projects/RollKeeper/apps/web/src/hooks/useSimpleDiceRoll.ts"],"sourcesContent":["import { useCallback } from 'react';\r\nimport { useDiceRoller } from './useDiceRoller';\r\nimport { RollSummary } from '@/types/dice';\r\n\r\nexport interface UseSimpleDiceRollOptions {\r\n  containerId?: string;\r\n  autoClearDelay?: number;\r\n  onRollComplete?: (summary: RollSummary) => void;\r\n  onError?: (error: string) => void;\r\n}\r\n\r\nexport interface UseSimpleDiceRollReturn {\r\n  isReady: boolean;\r\n  isRolling: boolean;\r\n  roll: (notation: string) => Promise<RollSummary | null>;\r\n  clearDice: () => void;\r\n}\r\n\r\n/**\r\n * Simple hook for dice rolling without UI components\r\n * Perfect for integrating into existing character sheet components\r\n */\r\nexport function useSimpleDiceRoll({\r\n  containerId = 'main-dice-container',\r\n  autoClearDelay = 1000,\r\n  onRollComplete,\r\n  onError,\r\n}: UseSimpleDiceRollOptions = {}): UseSimpleDiceRollReturn {\r\n  const { isInitialized, isRolling, roll, clearDice } = useDiceRoller({\r\n    containerId,\r\n    autoClearDelay,\r\n    onRollComplete,\r\n    onError,\r\n  });\r\n\r\n  const rollDice = useCallback(\r\n    async (notation: string): Promise<RollSummary | null> => {\r\n      return await roll(notation);\r\n    },\r\n    [roll]\r\n  );\r\n\r\n  return {\r\n    isReady: isInitialized,\r\n    isRolling,\r\n    roll: rollDice,\r\n    clearDice,\r\n  };\r\n}\r\n"],"names":[],"mappings":";;;;AAAA;AACA;;;;AAqBO,SAAS;QAAkB,EAChC,cAAc,qBAAqB,EACnC,iBAAiB,IAAI,EACrB,cAAc,EACd,OAAO,EACkB,GALO,iEAKJ,CAAC;;IAC7B,MAAM,EAAE,aAAa,EAAE,SAAS,EAAE,IAAI,EAAE,SAAS,EAAE,GAAG,IAAA,gKAAa,EAAC;QAClE;QACA;QACA;QACA;IACF;IAEA,MAAM,WAAW,IAAA,4KAAW;mDAC1B,OAAO;YACL,OAAO,MAAM,KAAK;QACpB;kDACA;QAAC;KAAK;IAGR,OAAO;QACL,SAAS;QACT;QACA,MAAM;QACN;IACF;AACF;GA1BgB;;QAMwC,gKAAa","debugId":null}},
    {"offset": {"line": 663, "column": 0}, "map": {"version":3,"sources":["file:///home/irakli/Projects/RollKeeper/apps/web/src/hooks/useBackgroundsData.ts"],"sourcesContent":["/**\r\n * Hook for loading and managing background data\r\n * Similar to useSpellsData\r\n */\r\n\r\n'use client';\r\n\r\nimport { useState, useEffect, useCallback } from 'react';\r\nimport type {\r\n  ProcessedBackground,\r\n  ProcessedBackgroundFeature,\r\n} from '@/utils/backgroundDataLoader';\r\n\r\ninterface UseBackgroundsDataReturn {\r\n  backgrounds: ProcessedBackground[];\r\n  features: ProcessedBackgroundFeature[];\r\n  loading: boolean;\r\n  error: Error | null;\r\n  getBackgroundByName: (name: string) => ProcessedBackground | undefined;\r\n  searchFeatures: (query: string) => ProcessedBackgroundFeature[];\r\n}\r\n\r\n/**\r\n * Hook to load and manage background data\r\n */\r\nexport function useBackgroundsData(): UseBackgroundsDataReturn {\r\n  const [backgrounds, setBackgrounds] = useState<ProcessedBackground[]>([]);\r\n  const [features, setFeatures] = useState<ProcessedBackgroundFeature[]>([]);\r\n  const [loading, setLoading] = useState(true);\r\n  const [error, setError] = useState<Error | null>(null);\r\n\r\n  // Load backgrounds on mount\r\n  useEffect(() => {\r\n    let mounted = true;\r\n\r\n    const loadData = async () => {\r\n      try {\r\n        setLoading(true);\r\n        setError(null);\r\n\r\n        const response = await fetch('/api/backgrounds');\r\n        if (!response.ok) {\r\n          throw new Error(\r\n            `Failed to fetch backgrounds: ${response.statusText}`\r\n          );\r\n        }\r\n\r\n        const data = await response.json();\r\n\r\n        if (mounted) {\r\n          setBackgrounds(data.backgrounds || []);\r\n          setFeatures(data.features || []);\r\n          setLoading(false);\r\n        }\r\n      } catch (err) {\r\n        console.error('Error loading backgrounds:', err);\r\n        if (mounted) {\r\n          setError(\r\n            err instanceof Error ? err : new Error('Failed to load backgrounds')\r\n          );\r\n          setLoading(false);\r\n        }\r\n      }\r\n    };\r\n\r\n    loadData();\r\n\r\n    return () => {\r\n      mounted = false;\r\n    };\r\n  }, []);\r\n\r\n  // Get background by name\r\n  const getBackgroundByName = useCallback(\r\n    (name: string): ProcessedBackground | undefined => {\r\n      const nameLower = name.toLowerCase();\r\n      return backgrounds.find(bg => bg.name.toLowerCase() === nameLower);\r\n    },\r\n    [backgrounds]\r\n  );\r\n\r\n  // Search features by query\r\n  const searchFeatures = useCallback(\r\n    (query: string): ProcessedBackgroundFeature[] => {\r\n      if (!query.trim()) return features;\r\n\r\n      const queryLower = query.toLowerCase().trim();\r\n\r\n      return features.filter(\r\n        feature =>\r\n          feature.name.toLowerCase().includes(queryLower) ||\r\n          feature.backgroundName.toLowerCase().includes(queryLower) ||\r\n          feature.description.toLowerCase().includes(queryLower)\r\n      );\r\n    },\r\n    [features]\r\n  );\r\n\r\n  return {\r\n    backgrounds,\r\n    features,\r\n    loading,\r\n    error,\r\n    getBackgroundByName,\r\n    searchFeatures,\r\n  };\r\n}\r\n"],"names":[],"mappings":"AAAA;;;CAGC;;;;AAID;;AAFA;;AAoBO,SAAS;;IACd,MAAM,CAAC,aAAa,eAAe,GAAG,IAAA,yKAAQ,EAAwB,EAAE;IACxE,MAAM,CAAC,UAAU,YAAY,GAAG,IAAA,yKAAQ,EAA+B,EAAE;IACzE,MAAM,CAAC,SAAS,WAAW,GAAG,IAAA,yKAAQ,EAAC;IACvC,MAAM,CAAC,OAAO,SAAS,GAAG,IAAA,yKAAQ,EAAe;IAEjD,4BAA4B;IAC5B,IAAA,0KAAS;wCAAC;YACR,IAAI,UAAU;YAEd,MAAM;yDAAW;oBACf,IAAI;wBACF,WAAW;wBACX,SAAS;wBAET,MAAM,WAAW,MAAM,MAAM;wBAC7B,IAAI,CAAC,SAAS,EAAE,EAAE;4BAChB,MAAM,IAAI,MACR,AAAC,gCAAmD,OAApB,SAAS,UAAU;wBAEvD;wBAEA,MAAM,OAAO,MAAM,SAAS,IAAI;wBAEhC,IAAI,SAAS;4BACX,eAAe,KAAK,WAAW,IAAI,EAAE;4BACrC,YAAY,KAAK,QAAQ,IAAI,EAAE;4BAC/B,WAAW;wBACb;oBACF,EAAE,OAAO,KAAK;wBACZ,QAAQ,KAAK,CAAC,8BAA8B;wBAC5C,IAAI,SAAS;4BACX,SACE,eAAe,QAAQ,MAAM,IAAI,MAAM;4BAEzC,WAAW;wBACb;oBACF;gBACF;;YAEA;YAEA;gDAAO;oBACL,UAAU;gBACZ;;QACF;uCAAG,EAAE;IAEL,yBAAyB;IACzB,MAAM,sBAAsB,IAAA,4KAAW;+DACrC,CAAC;YACC,MAAM,YAAY,KAAK,WAAW;YAClC,OAAO,YAAY,IAAI;uEAAC,CAAA,KAAM,GAAG,IAAI,CAAC,WAAW,OAAO;;QAC1D;8DACA;QAAC;KAAY;IAGf,2BAA2B;IAC3B,MAAM,iBAAiB,IAAA,4KAAW;0DAChC,CAAC;YACC,IAAI,CAAC,MAAM,IAAI,IAAI,OAAO;YAE1B,MAAM,aAAa,MAAM,WAAW,GAAG,IAAI;YAE3C,OAAO,SAAS,MAAM;kEACpB,CAAA,UACE,QAAQ,IAAI,CAAC,WAAW,GAAG,QAAQ,CAAC,eACpC,QAAQ,cAAc,CAAC,WAAW,GAAG,QAAQ,CAAC,eAC9C,QAAQ,WAAW,CAAC,WAAW,GAAG,QAAQ,CAAC;;QAEjD;yDACA;QAAC;KAAS;IAGZ,OAAO;QACL;QACA;QACA;QACA;QACA;QACA;IACF;AACF;GAjFgB","debugId":null}},
    {"offset": {"line": 756, "column": 0}, "map": {"version":3,"sources":["file:///home/irakli/Projects/RollKeeper/apps/web/src/hooks/useFeatsData.ts"],"sourcesContent":["/**\r\n * Hook for loading and managing feat data\r\n * Similar to useSpellsData\r\n */\r\n\r\n'use client';\r\n\r\nimport { useState, useEffect, useCallback } from 'react';\r\nimport type { ProcessedFeat } from '@/utils/featDataLoader';\r\n\r\ninterface UseFeatsDataReturn {\r\n  feats: ProcessedFeat[];\r\n  loading: boolean;\r\n  error: Error | null;\r\n  searchResults: (query: string) => ProcessedFeat[];\r\n  getFeatByName: (name: string) => ProcessedFeat | undefined;\r\n}\r\n\r\n/**\r\n * Hook to load and manage feat data\r\n */\r\nexport function useFeatsData(): UseFeatsDataReturn {\r\n  const [feats, setFeats] = useState<ProcessedFeat[]>([]);\r\n  const [loading, setLoading] = useState(true);\r\n  const [error, setError] = useState<Error | null>(null);\r\n\r\n  // Load feats on mount\r\n  useEffect(() => {\r\n    let mounted = true;\r\n\r\n    const loadData = async () => {\r\n      try {\r\n        setLoading(true);\r\n        setError(null);\r\n\r\n        const response = await fetch('/api/feats');\r\n        if (!response.ok) {\r\n          throw new Error(`Failed to fetch feats: ${response.statusText}`);\r\n        }\r\n\r\n        const data = await response.json();\r\n\r\n        if (mounted) {\r\n          setFeats(data.feats || []);\r\n          setLoading(false);\r\n        }\r\n      } catch (err) {\r\n        console.error('Error loading feats:', err);\r\n        if (mounted) {\r\n          setError(\r\n            err instanceof Error ? err : new Error('Failed to load feats')\r\n          );\r\n          setLoading(false);\r\n        }\r\n      }\r\n    };\r\n\r\n    loadData();\r\n\r\n    return () => {\r\n      mounted = false;\r\n    };\r\n  }, []);\r\n\r\n  // Search feats by query\r\n  const searchResults = useCallback(\r\n    (query: string): ProcessedFeat[] => {\r\n      if (!query.trim()) return feats;\r\n\r\n      const queryLower = query.toLowerCase().trim();\r\n\r\n      return feats.filter(\r\n        feat =>\r\n          feat.name.toLowerCase().includes(queryLower) ||\r\n          feat.description.toLowerCase().includes(queryLower) ||\r\n          feat.prerequisites.some(p => p.toLowerCase().includes(queryLower)) ||\r\n          feat.tags.some(t => t.toLowerCase().includes(queryLower))\r\n      );\r\n    },\r\n    [feats]\r\n  );\r\n\r\n  // Get feat by name (case-insensitive)\r\n  const getFeatByName = useCallback(\r\n    (name: string): ProcessedFeat | undefined => {\r\n      const nameLower = name.toLowerCase();\r\n      return feats.find(feat => feat.name.toLowerCase() === nameLower);\r\n    },\r\n    [feats]\r\n  );\r\n\r\n  return {\r\n    feats,\r\n    loading,\r\n    error,\r\n    searchResults,\r\n    getFeatByName,\r\n  };\r\n}\r\n"],"names":[],"mappings":"AAAA;;;CAGC;;;;AAID;;AAFA;;AAgBO,SAAS;;IACd,MAAM,CAAC,OAAO,SAAS,GAAG,IAAA,yKAAQ,EAAkB,EAAE;IACtD,MAAM,CAAC,SAAS,WAAW,GAAG,IAAA,yKAAQ,EAAC;IACvC,MAAM,CAAC,OAAO,SAAS,GAAG,IAAA,yKAAQ,EAAe;IAEjD,sBAAsB;IACtB,IAAA,0KAAS;kCAAC;YACR,IAAI,UAAU;YAEd,MAAM;mDAAW;oBACf,IAAI;wBACF,WAAW;wBACX,SAAS;wBAET,MAAM,WAAW,MAAM,MAAM;wBAC7B,IAAI,CAAC,SAAS,EAAE,EAAE;4BAChB,MAAM,IAAI,MAAM,AAAC,0BAA6C,OAApB,SAAS,UAAU;wBAC/D;wBAEA,MAAM,OAAO,MAAM,SAAS,IAAI;wBAEhC,IAAI,SAAS;4BACX,SAAS,KAAK,KAAK,IAAI,EAAE;4BACzB,WAAW;wBACb;oBACF,EAAE,OAAO,KAAK;wBACZ,QAAQ,KAAK,CAAC,wBAAwB;wBACtC,IAAI,SAAS;4BACX,SACE,eAAe,QAAQ,MAAM,IAAI,MAAM;4BAEzC,WAAW;wBACb;oBACF;gBACF;;YAEA;YAEA;0CAAO;oBACL,UAAU;gBACZ;;QACF;iCAAG,EAAE;IAEL,wBAAwB;IACxB,MAAM,gBAAgB,IAAA,4KAAW;mDAC/B,CAAC;YACC,IAAI,CAAC,MAAM,IAAI,IAAI,OAAO;YAE1B,MAAM,aAAa,MAAM,WAAW,GAAG,IAAI;YAE3C,OAAO,MAAM,MAAM;2DACjB,CAAA,OACE,KAAK,IAAI,CAAC,WAAW,GAAG,QAAQ,CAAC,eACjC,KAAK,WAAW,CAAC,WAAW,GAAG,QAAQ,CAAC,eACxC,KAAK,aAAa,CAAC,IAAI;mEAAC,CAAA,IAAK,EAAE,WAAW,GAAG,QAAQ,CAAC;qEACtD,KAAK,IAAI,CAAC,IAAI;mEAAC,CAAA,IAAK,EAAE,WAAW,GAAG,QAAQ,CAAC;;;QAEnD;kDACA;QAAC;KAAM;IAGT,sCAAsC;IACtC,MAAM,gBAAgB,IAAA,4KAAW;mDAC/B,CAAC;YACC,MAAM,YAAY,KAAK,WAAW;YAClC,OAAO,MAAM,IAAI;2DAAC,CAAA,OAAQ,KAAK,IAAI,CAAC,WAAW,OAAO;;QACxD;kDACA;QAAC;KAAM;IAGT,OAAO;QACL;QACA;QACA;QACA;QACA;IACF;AACF;GA7EgB","debugId":null}},
    {"offset": {"line": 850, "column": 0}, "map": {"version":3,"sources":["file:///home/irakli/Projects/RollKeeper/apps/web/src/hooks/useFeatureSourcesData.ts"],"sourcesContent":["/**\r\n * Hook for loading and managing all feature sources\r\n * Aggregates backgrounds, feats, and class features\r\n */\r\n\r\n'use client';\r\n\r\nimport { useState, useEffect, useCallback, useMemo } from 'react';\r\nimport { useBackgroundsData } from './useBackgroundsData';\r\nimport { useFeatsData } from './useFeatsData';\r\nimport { CharacterState } from '@/types/character';\r\nimport type { ProcessedClass } from '@/types/classes';\r\nimport {\r\n  FeatureAutocompleteItem,\r\n  backgroundFeatureToAutocompleteItem,\r\n  featToAutocompleteItem,\r\n  classFeatureToAutocompleteItem,\r\n  FeatureSourceFilter,\r\n} from '@/types/features';\r\n\r\ninterface UseFeatureSourcesDataReturn {\r\n  allFeatures: FeatureAutocompleteItem[];\r\n  loading: boolean;\r\n  error: Error | null;\r\n  filterBySourceType: (\r\n    sourceType: FeatureSourceFilter\r\n  ) => FeatureAutocompleteItem[];\r\n  filterByClass: (className: string) => FeatureAutocompleteItem[];\r\n  filterBySubclass: (\r\n    className: string,\r\n    subclassName: string\r\n  ) => FeatureAutocompleteItem[];\r\n  searchFeatures: (\r\n    query: string,\r\n    sourceType?: FeatureSourceFilter\r\n  ) => FeatureAutocompleteItem[];\r\n}\r\n\r\n/**\r\n * Hook to load and manage all feature sources\r\n */\r\nexport function useFeatureSourcesData(\r\n  character?: CharacterState\r\n): UseFeatureSourcesDataReturn {\r\n  const {\r\n    features: backgroundFeatures,\r\n    loading: backgroundsLoading,\r\n    error: backgroundsError,\r\n  } = useBackgroundsData();\r\n  const { feats, loading: featsLoading, error: featsError } = useFeatsData();\r\n  const [classes, setClasses] = useState<ProcessedClass[]>([]);\r\n  const [classesLoading, setClassesLoading] = useState(true);\r\n  const [classesError, setClassesError] = useState<Error | null>(null);\r\n\r\n  // Load class data on mount\r\n  useEffect(() => {\r\n    let mounted = true;\r\n\r\n    const loadData = async () => {\r\n      try {\r\n        setClassesLoading(true);\r\n        setClassesError(null);\r\n\r\n        const response = await fetch('/api/classes');\r\n        if (!response.ok) {\r\n          throw new Error(`Failed to fetch classes: ${response.statusText}`);\r\n        }\r\n\r\n        const data = await response.json();\r\n\r\n        if (mounted) {\r\n          setClasses(data.classes || []);\r\n          setClassesLoading(false);\r\n        }\r\n      } catch (err) {\r\n        console.error('Error loading classes:', err);\r\n        if (mounted) {\r\n          setClassesError(\r\n            err instanceof Error ? err : new Error('Failed to load classes')\r\n          );\r\n          setClassesLoading(false);\r\n        }\r\n      }\r\n    };\r\n\r\n    loadData();\r\n\r\n    return () => {\r\n      mounted = false;\r\n    };\r\n  }, []);\r\n\r\n  // Combine loading and error states\r\n  const loading = backgroundsLoading || featsLoading || classesLoading;\r\n  const error = backgroundsError || featsError || classesError;\r\n\r\n  // Convert all sources to unified autocomplete items\r\n  const allFeatures = useMemo(() => {\r\n    const items: FeatureAutocompleteItem[] = [];\r\n\r\n    // Add background features\r\n    backgroundFeatures.forEach(feature => {\r\n      items.push(backgroundFeatureToAutocompleteItem(feature));\r\n    });\r\n\r\n    // Add feats\r\n    feats.forEach(feat => {\r\n      items.push(featToAutocompleteItem(feat));\r\n    });\r\n\r\n    // Add class features from all classes\r\n    // Note: We load ALL class/subclass features and let the user select via dropdown\r\n    classes.forEach(classData => {\r\n      // Add main class features\r\n      classData.features.forEach(feature => {\r\n        // If character data available, only show features up to their level\r\n        if (!character || feature.level <= character.level) {\r\n          items.push(classFeatureToAutocompleteItem(feature));\r\n        }\r\n      });\r\n\r\n      // Add all subclass features (user will select via dropdown)\r\n      classData.subclasses?.forEach(subclass => {\r\n        subclass.features.forEach(feature => {\r\n          // If character data available, only show features up to their level\r\n          if (!character || feature.level <= character.level) {\r\n            items.push(classFeatureToAutocompleteItem(feature));\r\n          }\r\n        });\r\n      });\r\n    });\r\n\r\n    return items;\r\n  }, [backgroundFeatures, feats, classes, character]);\r\n\r\n  // Filter by source type\r\n  const filterBySourceType = useCallback(\r\n    (sourceType: FeatureSourceFilter): FeatureAutocompleteItem[] => {\r\n      if (sourceType === 'all') return allFeatures;\r\n      return allFeatures.filter(f => f.sourceType === sourceType);\r\n    },\r\n    [allFeatures]\r\n  );\r\n\r\n  // Filter by class name\r\n  const filterByClass = useCallback(\r\n    (className: string): FeatureAutocompleteItem[] => {\r\n      return allFeatures.filter(\r\n        f =>\r\n          f.sourceType === 'class' &&\r\n          f.metadata.className?.toLowerCase() === className.toLowerCase() &&\r\n          !f.metadata.isSubclassFeature\r\n      );\r\n    },\r\n    [allFeatures]\r\n  );\r\n\r\n  // Filter by subclass (className and subclass name/short name)\r\n  const filterBySubclass = useCallback(\r\n    (className: string, subclassName?: string): FeatureAutocompleteItem[] => {\r\n      return allFeatures.filter(f => {\r\n        if (f.sourceType !== 'subclass') return false;\r\n        if (f.metadata.className?.toLowerCase() !== className.toLowerCase())\r\n          return false;\r\n\r\n        // If no subclass name provided, return all subclasses for this class\r\n        if (!subclassName) return true;\r\n\r\n        // Filter by specific subclass\r\n        return (\r\n          f.metadata.subclassShortName\r\n            ?.toLowerCase()\r\n            .includes(subclassName.toLowerCase()) ||\r\n          f.name.toLowerCase().includes(subclassName.toLowerCase())\r\n        );\r\n      });\r\n    },\r\n    [allFeatures]\r\n  );\r\n\r\n  // Search features with optional source type filter\r\n  const searchFeatures = useCallback(\r\n    (\r\n      query: string,\r\n      sourceType?: FeatureSourceFilter\r\n    ): FeatureAutocompleteItem[] => {\r\n      const features =\r\n        sourceType && sourceType !== 'all'\r\n          ? filterBySourceType(sourceType)\r\n          : allFeatures;\r\n\r\n      if (!query.trim()) return features;\r\n\r\n      const queryLower = query.toLowerCase().trim();\r\n\r\n      return features.filter(\r\n        f =>\r\n          f.name.toLowerCase().includes(queryLower) ||\r\n          f.description.toLowerCase().includes(queryLower) ||\r\n          f.tags.some(t => t.toLowerCase().includes(queryLower)) ||\r\n          f.metadata.backgroundName?.toLowerCase().includes(queryLower) ||\r\n          f.metadata.className?.toLowerCase().includes(queryLower)\r\n      );\r\n    },\r\n    [allFeatures, filterBySourceType]\r\n  );\r\n\r\n  return {\r\n    allFeatures,\r\n    loading,\r\n    error,\r\n    filterBySourceType,\r\n    filterByClass,\r\n    filterBySubclass,\r\n    searchFeatures,\r\n  };\r\n}\r\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 1049, "column": 0}, "map": {"version":3,"sources":["file:///home/irakli/Projects/RollKeeper/apps/web/src/hooks/useHydration.ts"],"sourcesContent":["import { useEffect } from 'react';\r\nimport { useCharacterStore } from '@/store/characterStore';\r\n\r\n/**\r\n * Hook to ensure components wait for Zustand store hydration before rendering\r\n * This prevents hydration mismatches between server and client\r\n */\r\nexport function useHydration() {\r\n  const hasHydrated = useCharacterStore(state => state.hasHydrated);\r\n\r\n  useEffect(() => {\r\n    // Set hasHydrated to true after initial render to prevent hydration mismatches\r\n    // The onRehydrateStorage callback will have already run if there was stored data\r\n    if (!hasHydrated) {\r\n      console.log('[useHydration] Setting hasHydrated to true');\r\n      const timer = setTimeout(() => {\r\n        useCharacterStore.setState({ hasHydrated: true });\r\n      }, 0);\r\n\r\n      return () => clearTimeout(timer);\r\n    }\r\n  }, [hasHydrated]);\r\n\r\n  return hasHydrated;\r\n}\r\n"],"names":[],"mappings":";;;;AAAA;AACA;;;;AAMO,SAAS;;IACd,MAAM,cAAc,IAAA,qKAAiB;uDAAC,CAAA,QAAS,MAAM,WAAW;;IAEhE,IAAA,0KAAS;kCAAC;YACR,+EAA+E;YAC/E,iFAAiF;YACjF,IAAI,CAAC,aAAa;gBAChB,QAAQ,GAAG,CAAC;gBACZ,MAAM,QAAQ;oDAAW;wBACvB,qKAAiB,CAAC,QAAQ,CAAC;4BAAE,aAAa;wBAAK;oBACjD;mDAAG;gBAEH;8CAAO,IAAM,aAAa;;YAC5B;QACF;iCAAG;QAAC;KAAY;IAEhB,OAAO;AACT;GAjBgB;;QACM,qKAAiB","debugId":null}},
    {"offset": {"line": 1098, "column": 0}, "map": {"version":3,"sources":["file:///home/irakli/Projects/RollKeeper/apps/web/src/hooks/useSpellsData.ts"],"sourcesContent":["/**\r\n * Hook for loading and managing spell data from spellbook\r\n */\r\n\r\n'use client';\r\n\r\nimport { useState, useEffect, useCallback } from 'react';\r\nimport { ProcessedSpell } from '@/types/spells';\r\nimport { searchSpells } from '@/utils/spellConversion';\r\n\r\ninterface UseSpellsDataReturn {\r\n  spells: ProcessedSpell[];\r\n  loading: boolean;\r\n  error: Error | null;\r\n  searchResults: (query: string) => ProcessedSpell[];\r\n  getSpellById: (id: string) => ProcessedSpell | undefined;\r\n  getSpellByName: (name: string) => ProcessedSpell | undefined;\r\n}\r\n\r\n// Cache spells in memory for the session\r\nlet cachedSpells: ProcessedSpell[] | null = null;\r\nlet cachePromise: Promise<ProcessedSpell[]> | null = null;\r\n\r\n/**\r\n * Fetch spells from the API\r\n */\r\nasync function fetchSpells(): Promise<ProcessedSpell[]> {\r\n  // Return cached spells if available\r\n  if (cachedSpells) {\r\n    return cachedSpells;\r\n  }\r\n\r\n  // If already fetching, return the existing promise\r\n  if (cachePromise) {\r\n    return cachePromise;\r\n  }\r\n\r\n  // Start fetching\r\n  cachePromise = fetch('/api/spells')\r\n    .then(res => {\r\n      if (!res.ok) {\r\n        throw new Error(`Failed to fetch spells: ${res.statusText}`);\r\n      }\r\n      return res.json();\r\n    })\r\n    .then(data => {\r\n      cachedSpells = data.spells;\r\n      cachePromise = null;\r\n      return cachedSpells!;\r\n    })\r\n    .catch(error => {\r\n      cachePromise = null;\r\n      throw error;\r\n    });\r\n\r\n  return cachePromise;\r\n}\r\n\r\n/**\r\n * Hook to load and manage spell data\r\n * Loads spells in the background on mount\r\n */\r\nexport function useSpellsData(): UseSpellsDataReturn {\r\n  const [spells, setSpells] = useState<ProcessedSpell[]>([]);\r\n  const [loading, setLoading] = useState(true);\r\n  const [error, setError] = useState<Error | null>(null);\r\n\r\n  // Load spells on mount\r\n  useEffect(() => {\r\n    let mounted = true;\r\n\r\n    const loadSpells = async () => {\r\n      try {\r\n        setLoading(true);\r\n        setError(null);\r\n        const data = await fetchSpells();\r\n\r\n        if (mounted) {\r\n          setSpells(data);\r\n          setLoading(false);\r\n        }\r\n      } catch (err) {\r\n        console.error('Error loading spells:', err);\r\n        if (mounted) {\r\n          setError(\r\n            err instanceof Error ? err : new Error('Failed to load spells')\r\n          );\r\n          setLoading(false);\r\n        }\r\n      }\r\n    };\r\n\r\n    loadSpells();\r\n\r\n    return () => {\r\n      mounted = false;\r\n    };\r\n  }, []);\r\n\r\n  // Search spells by query\r\n  const searchResults = useCallback(\r\n    (query: string): ProcessedSpell[] => {\r\n      return searchSpells(spells, query);\r\n    },\r\n    [spells]\r\n  );\r\n\r\n  // Get spell by ID\r\n  const getSpellById = useCallback(\r\n    (id: string): ProcessedSpell | undefined => {\r\n      return spells.find(spell => spell.id === id);\r\n    },\r\n    [spells]\r\n  );\r\n\r\n  // Get spell by name (case-insensitive)\r\n  const getSpellByName = useCallback(\r\n    (name: string): ProcessedSpell | undefined => {\r\n      const nameLower = name.toLowerCase();\r\n      return spells.find(spell => spell.name.toLowerCase() === nameLower);\r\n    },\r\n    [spells]\r\n  );\r\n\r\n  return {\r\n    spells,\r\n    loading,\r\n    error,\r\n    searchResults,\r\n    getSpellById,\r\n    getSpellByName,\r\n  };\r\n}\r\n\r\n/**\r\n * Clear the spell cache (useful for testing or when data is updated)\r\n */\r\nexport function clearSpellCache(): void {\r\n  cachedSpells = null;\r\n  cachePromise = null;\r\n}\r\n"],"names":[],"mappings":"AAAA;;CAEC;;;;;;AAID;AAEA;;AAJA;;;AAeA,yCAAyC;AACzC,IAAI,eAAwC;AAC5C,IAAI,eAAiD;AAErD;;CAEC,GACD,eAAe;IACb,oCAAoC;IACpC,IAAI,cAAc;QAChB,OAAO;IACT;IAEA,mDAAmD;IACnD,IAAI,cAAc;QAChB,OAAO;IACT;IAEA,iBAAiB;IACjB,eAAe,MAAM,eAClB,IAAI,CAAC,CAAA;QACJ,IAAI,CAAC,IAAI,EAAE,EAAE;YACX,MAAM,IAAI,MAAM,AAAC,2BAAyC,OAAf,IAAI,UAAU;QAC3D;QACA,OAAO,IAAI,IAAI;IACjB,GACC,IAAI,CAAC,CAAA;QACJ,eAAe,KAAK,MAAM;QAC1B,eAAe;QACf,OAAO;IACT,GACC,KAAK,CAAC,CAAA;QACL,eAAe;QACf,MAAM;IACR;IAEF,OAAO;AACT;AAMO,SAAS;;IACd,MAAM,CAAC,QAAQ,UAAU,GAAG,IAAA,yKAAQ,EAAmB,EAAE;IACzD,MAAM,CAAC,SAAS,WAAW,GAAG,IAAA,yKAAQ,EAAC;IACvC,MAAM,CAAC,OAAO,SAAS,GAAG,IAAA,yKAAQ,EAAe;IAEjD,uBAAuB;IACvB,IAAA,0KAAS;mCAAC;YACR,IAAI,UAAU;YAEd,MAAM;sDAAa;oBACjB,IAAI;wBACF,WAAW;wBACX,SAAS;wBACT,MAAM,OAAO,MAAM;wBAEnB,IAAI,SAAS;4BACX,UAAU;4BACV,WAAW;wBACb;oBACF,EAAE,OAAO,KAAK;wBACZ,QAAQ,KAAK,CAAC,yBAAyB;wBACvC,IAAI,SAAS;4BACX,SACE,eAAe,QAAQ,MAAM,IAAI,MAAM;4BAEzC,WAAW;wBACb;oBACF;gBACF;;YAEA;YAEA;2CAAO;oBACL,UAAU;gBACZ;;QACF;kCAAG,EAAE;IAEL,yBAAyB;IACzB,MAAM,gBAAgB,IAAA,4KAAW;oDAC/B,CAAC;YACC,OAAO,IAAA,iKAAY,EAAC,QAAQ;QAC9B;mDACA;QAAC;KAAO;IAGV,kBAAkB;IAClB,MAAM,eAAe,IAAA,4KAAW;mDAC9B,CAAC;YACC,OAAO,OAAO,IAAI;2DAAC,CAAA,QAAS,MAAM,EAAE,KAAK;;QAC3C;kDACA;QAAC;KAAO;IAGV,uCAAuC;IACvC,MAAM,iBAAiB,IAAA,4KAAW;qDAChC,CAAC;YACC,MAAM,YAAY,KAAK,WAAW;YAClC,OAAO,OAAO,IAAI;6DAAC,CAAA,QAAS,MAAM,IAAI,CAAC,WAAW,OAAO;;QAC3D;oDACA;QAAC;KAAO;IAGV,OAAO;QACL;QACA;QACA;QACA;QACA;QACA;IACF;AACF;GAtEgB;AA2ET,SAAS;IACd,eAAe;IACf,eAAe;AACjB","debugId":null}},
    {"offset": {"line": 1228, "column": 0}, "map": {"version":3,"sources":["file:///home/irakli/Projects/RollKeeper/apps/web/src/types/character.ts"],"sourcesContent":["// Basic character types for D&D 5e character sheet\r\nexport type AbilityName =\r\n  | 'strength'\r\n  | 'dexterity'\r\n  | 'constitution'\r\n  | 'intelligence'\r\n  | 'wisdom'\r\n  | 'charisma';\r\nexport type SkillName =\r\n  | 'acrobatics'\r\n  | 'animalHandling'\r\n  | 'arcana'\r\n  | 'athletics'\r\n  | 'deception'\r\n  | 'history'\r\n  | 'insight'\r\n  | 'intimidation'\r\n  | 'investigation'\r\n  | 'medicine'\r\n  | 'nature'\r\n  | 'perception'\r\n  | 'performance'\r\n  | 'persuasion'\r\n  | 'religion'\r\n  | 'sleightOfHand'\r\n  | 'stealth'\r\n  | 'survival';\r\n\r\nimport type { SpellbookState } from './spells';\r\n\r\n// Character abilities with scores\r\nexport interface CharacterAbilities {\r\n  strength: number;\r\n  dexterity: number;\r\n  constitution: number;\r\n  intelligence: number;\r\n  wisdom: number;\r\n  charisma: number;\r\n}\r\n\r\n// Skill proficiency data\r\nexport interface SkillProficiency {\r\n  proficient: boolean;\r\n  expertise: boolean;\r\n  customModifier?: number;\r\n}\r\n\r\n// Tool proficiency levels\r\nexport type ToolProficiencyLevel = 'none' | 'proficient' | 'expertise';\r\n\r\n// Tool proficiency tracking\r\nexport interface ToolProficiency {\r\n  id: string;\r\n  name: string; // e.g., \"Thieves' Tools\", \"Smith's Tools\", \"Lute\"\r\n  proficiencyLevel: ToolProficiencyLevel;\r\n  createdAt: string;\r\n  updatedAt: string;\r\n}\r\n\r\n// Language tracking\r\nexport interface Language {\r\n  id: string;\r\n  name: string; // e.g., \"Common\", \"Elvish\", \"Draconic\"\r\n  script?: string; // e.g., \"Common\", \"Elvish\", \"Draconic\" (optional)\r\n  createdAt: string;\r\n  updatedAt: string;\r\n}\r\n\r\n// Saving throw proficiency\r\nexport interface SavingThrowProficiency {\r\n  proficient: boolean;\r\n  customModifier?: number;\r\n}\r\n\r\n// Hit Points calculation mode\r\nexport type HPCalculationMode = 'auto' | 'manual';\r\n\r\n// Death Saving Throws\r\nexport interface DeathSavingThrows {\r\n  successes: number; // 0-3\r\n  failures: number; // 0-3\r\n  isStabilized: boolean;\r\n}\r\n\r\n// Hit points tracking\r\nexport interface HitPoints {\r\n  current: number;\r\n  max: number;\r\n  temporary: number;\r\n  calculationMode: HPCalculationMode;\r\n  manualMaxOverride?: number; // Used when calculationMode is 'manual'\r\n  deathSaves?: DeathSavingThrows; // Only present when at 0 HP\r\n}\r\n\r\n// Initiative tracking with override capability\r\nexport interface InitiativeData {\r\n  value: number;\r\n  isOverridden: boolean; // If true, use custom value; if false, calculate from DEX\r\n}\r\n\r\n// Reaction tracking for combat\r\nexport interface ReactionData {\r\n  hasUsedReaction: boolean; // Whether reaction has been used this turn/round\r\n}\r\n\r\n// Heroic Inspiration tracking (stackable)\r\nexport interface HeroicInspiration {\r\n  count: number; // Number of inspiration dice available\r\n  maxCount?: number; // Optional maximum (some DMs set limits)\r\n}\r\n\r\n// Rich text content for character information\r\nexport interface RichTextContent {\r\n  id: string;\r\n  title: string;\r\n  content: string; // HTML content from WYSIWYG editor\r\n  category: 'feature' | 'trait' | 'background' | 'note' | 'spell';\r\n  order?: number; // For ordering notes\r\n  createdAt: string;\r\n  updatedAt: string;\r\n}\r\n\r\n// Character background and history\r\nexport interface CharacterBackground {\r\n  backstory: string; // Rich text HTML content\r\n  personality: string; // Rich text HTML content\r\n  ideals: string; // Rich text HTML content\r\n  bonds: string; // Rich text HTML content\r\n  flaws: string; // Rich text HTML content\r\n}\r\n\r\n// Spell slot tracking for each level\r\nexport interface SpellSlot {\r\n  max: number;\r\n  used: number;\r\n}\r\n\r\n// Spell slot data structure\r\nexport interface SpellSlots {\r\n  1: SpellSlot;\r\n  2: SpellSlot;\r\n  3: SpellSlot;\r\n  4: SpellSlot;\r\n  5: SpellSlot;\r\n  6: SpellSlot;\r\n  7: SpellSlot;\r\n  8: SpellSlot;\r\n  9: SpellSlot;\r\n}\r\n\r\n// Trackable trait/feature with limited uses\r\nexport interface TrackableTrait {\r\n  id: string;\r\n  name: string;\r\n  description?: string;\r\n  maxUses: number;\r\n  usedUses: number;\r\n  restType: 'short' | 'long'; // Recharges on short or long rest\r\n  source?: string; // e.g., \"Racial\", \"Feat\", \"Class Feature\", etc.\r\n  scaleWithProficiency?: boolean; // If true, maxUses scales with proficiency bonus\r\n  proficiencyMultiplier?: number; // Multiplier for proficiency bonus (default 1)\r\n  isPassive?: boolean; // If true, this is a passive ability (no usage tracking needed)\r\n  createdAt: string;\r\n  updatedAt: string;\r\n}\r\n\r\n// Extended feature source types\r\nexport type FeatureSourceType =\r\n  | 'class' // Class features (e.g., Action Surge, Sneak Attack)\r\n  | 'race' // Racial features (e.g., Darkvision, Breath Weapon)\r\n  | 'feat' // Feat abilities (e.g., Great Weapon Master, Lucky)\r\n  | 'background' // Background features (e.g., Criminal Contact)\r\n  | 'magic-item' // Magic item abilities\r\n  | 'other'; // Custom/miscellaneous features\r\n\r\n// Extended feature interface that builds upon TrackableTrait\r\nexport interface ExtendedFeature extends TrackableTrait {\r\n  sourceType: FeatureSourceType;\r\n  sourceDetail?: string; // e.g., \"Fighter Level 2\", \"Hill Dwarf\", \"Winged Boots\"\r\n  category?: string; // Custom categorization within source type\r\n  displayOrder: number; // For drag & drop ordering within categories\r\n  isPassive?: boolean; // True for passive abilities (no usage tracking)\r\n}\r\n\r\n// Feature category grouping for UI organization\r\nexport interface FeatureCategory {\r\n  sourceType: FeatureSourceType;\r\n  label: string;\r\n  description: string;\r\n  features: ExtendedFeature[];\r\n  isCollapsed?: boolean;\r\n}\r\n\r\n// Constants for feature source types\r\nexport const FEATURE_SOURCE_LABELS: Record<FeatureSourceType, string> = {\r\n  class: 'Class Features',\r\n  race: 'Racial Features',\r\n  feat: 'Feats',\r\n  background: 'Background Features',\r\n  'magic-item': 'Magic Items',\r\n  other: 'Other/Custom',\r\n};\r\n\r\nexport const FEATURE_SOURCE_DESCRIPTIONS: Record<FeatureSourceType, string> = {\r\n  class: 'Abilities gained from your character class and level',\r\n  race: \"Traits and abilities from your character's race and subrace\",\r\n  feat: 'Special abilities gained from feats',\r\n  background: \"Features from your character's background\",\r\n  'magic-item': 'Abilities granted by magic items and equipment',\r\n  other: 'Custom or miscellaneous abilities',\r\n};\r\n\r\n// Warlock pact magic slots\r\nexport interface PactMagic {\r\n  slots: SpellSlot;\r\n  level: number; // Pact slot level (1-5)\r\n}\r\n\r\n// Spellcasting ability types\r\nexport type SpellcastingAbility = 'intelligence' | 'wisdom' | 'charisma';\r\n\r\n// Spell action types\r\nexport type SpellActionType = 'attack' | 'save' | 'utility';\r\n\r\n// Concentration tracking state\r\nexport interface ConcentrationState {\r\n  isConcentrating: boolean;\r\n  spellName?: string; // Name of the spell being concentrated on\r\n  spellId?: string; // ID of the spell being concentrated on (for user spells)\r\n  castAt?: number; // What level the concentration spell was cast at\r\n  startedAt?: string; // ISO timestamp when concentration started\r\n}\r\n\r\n// Spell information\r\nexport interface Spell {\r\n  id: string;\r\n  name: string;\r\n  level: number; // 0 for cantrips, 1-9 for spells\r\n  school: string; // Divination, Evocation, etc.\r\n  castingTime: string; // \"1 action\", \"1 bonus action\", \"1 minute\", etc.\r\n  range: string; // \"Touch\", \"30 feet\", \"Self\", etc.\r\n  components: {\r\n    verbal: boolean;\r\n    somatic: boolean;\r\n    material: boolean;\r\n    materialDescription?: string; // e.g., \"a handful of clay\"\r\n  };\r\n  duration: string; // \"Instantaneous\", \"1 minute\", \"Concentration, up to 1 hour\", etc.\r\n  description: string;\r\n  higherLevel?: string; // Description of what happens when cast at higher levels\r\n  ritual?: boolean; // Can be cast as a ritual\r\n  concentration?: boolean; // Requires concentration\r\n  isPrepared?: boolean; // For classes that prepare spells\r\n  isAlwaysPrepared?: boolean; // For domain spells, patron spells, etc.\r\n  actionType?: SpellActionType; // Whether spell requires attack roll, saving throw, or is utility\r\n  savingThrow?: string; // Which saving throw (if actionType is 'save'): \"Dexterity\", \"Constitution\", etc.\r\n  damage?: string; // Damage dice (if applicable): \"1d10\", \"3d6\", etc.\r\n  damageType?: string; // Type of damage: \"fire\", \"cold\", \"psychic\", etc.\r\n  source?: string; // PHB, XGE, etc.\r\n  createdAt: string;\r\n  updatedAt: string;\r\n}\r\n\r\n// Spellcasting statistics with override capability\r\nexport interface SpellcastingStats {\r\n  spellcastingAbility: SpellcastingAbility | null; // null for non-spellcasters\r\n  isAbilityOverridden: boolean; // If true, use manual override instead of class-based\r\n  spellAttackBonus?: number; // Manual override for spell attack bonus\r\n  spellSaveDC?: number; // Manual override for spell save DC\r\n}\r\n\r\n// Class information with custom support\r\nexport interface ClassInfo {\r\n  name: string;\r\n  isCustom: boolean;\r\n  spellcaster?: 'full' | 'half' | 'third' | 'warlock' | 'none';\r\n  hitDie: number; // d6, d8, d10, d12 - the size of the hit die for this class\r\n}\r\n\r\n// Multiclass information for individual classes\r\nexport interface MulticlassInfo {\r\n  className: string;\r\n  level: number;\r\n  isCustom: boolean;\r\n  spellcaster?: 'full' | 'half' | 'third' | 'warlock' | 'none';\r\n  hitDie: number; // d6, d8, d10, d12 - the size of the hit die for this class\r\n  subclass?: string; // Optional subclass name\r\n}\r\n\r\n// Multiclass validation result\r\nexport interface MulticlassValidation {\r\n  valid: boolean;\r\n  errors: string[];\r\n  warnings?: string[];\r\n}\r\n\r\n// Weapon and magic item types\r\nexport type WeaponCategory = 'simple' | 'martial' | 'magic' | 'artifact';\r\nexport type WeaponType =\r\n  | 'melee'\r\n  | 'ranged'\r\n  | 'finesse'\r\n  | 'versatile'\r\n  | 'light'\r\n  | 'heavy'\r\n  | 'reach'\r\n  | 'thrown'\r\n  | 'ammunition'\r\n  | 'loading'\r\n  | 'special';\r\nexport type DamageType =\r\n  | 'acid'\r\n  | 'bludgeoning'\r\n  | 'cold'\r\n  | 'fire'\r\n  | 'force'\r\n  | 'lightning'\r\n  | 'necrotic'\r\n  | 'piercing'\r\n  | 'poison'\r\n  | 'psychic'\r\n  | 'radiant'\r\n  | 'slashing'\r\n  | 'thunder';\r\n\r\n// Weapon damage entry for multiple damage types\r\nexport interface WeaponDamage {\r\n  dice: string; // e.g., \"1d8\", \"2d6\"\r\n  type: DamageType;\r\n  versatiledice?: string; // For versatile weapons (e.g., \"1d10\")\r\n  label?: string; // Optional label like \"Cold Damage\", \"Fire Damage\", etc.\r\n}\r\n\r\n// Individual weapon/magic item\r\nexport interface Weapon {\r\n  id: string;\r\n  name: string;\r\n  category: WeaponCategory;\r\n  weaponType: WeaponType[];\r\n  // Updated to support multiple damage types\r\n  damage: WeaponDamage[]; // Array of damage entries\r\n  // Legacy single damage support for backward compatibility\r\n  legacyDamage?: {\r\n    dice: string;\r\n    type: DamageType;\r\n    versatiledice?: string;\r\n  };\r\n  enhancementBonus: number; // +0, +1, +2, +3 (enhancement bonus)\r\n  attackBonus?: number; // Additional custom attack bonus beyond enhancement\r\n  damageBonus?: number; // Additional custom damage bonus beyond enhancement\r\n  properties: string[]; // Custom properties like \"magical\", \"silvered\", etc.\r\n  description?: string; // Optional description for magic items\r\n  range?: {\r\n    normal: number;\r\n    long?: number;\r\n  };\r\n  isEquipped: boolean; // Whether this weapon is currently equipped/ready\r\n  manualProficiency?: boolean; // Manual override for proficiency (undefined = use auto calculation)\r\n  requiresAttunement?: boolean; // Whether this weapon requires attunement\r\n  isAttuned?: boolean; // Whether character is attuned to this item\r\n  createdAt: string;\r\n  updatedAt: string;\r\n}\r\n\r\n// Magic item categories and types\r\nexport type MagicItemCategory =\r\n  | 'wondrous'\r\n  | 'armor'\r\n  | 'shield'\r\n  | 'ring'\r\n  | 'staff'\r\n  | 'wand'\r\n  | 'rod'\r\n  | 'scroll'\r\n  | 'potion'\r\n  | 'artifact'\r\n  | 'other';\r\nexport type MagicItemRarity =\r\n  | 'common'\r\n  | 'uncommon'\r\n  | 'rare'\r\n  | 'very rare'\r\n  | 'legendary'\r\n  | 'artifact';\r\n\r\n// Magic item interface\r\nexport interface MagicItem {\r\n  id: string;\r\n  name: string;\r\n  category: MagicItemCategory;\r\n  rarity: MagicItemRarity;\r\n  description: string;\r\n  properties: string[]; // Special properties or abilities\r\n  requiresAttunement: boolean;\r\n  isAttuned: boolean;\r\n  isEquipped?: boolean; // For wearable items\r\n  charges?: {\r\n    current: number;\r\n    max: number;\r\n    rechargeRule?: string; // e.g., \"1d6+1 at dawn\", \"all at dawn\"\r\n  };\r\n  createdAt: string;\r\n  updatedAt: string;\r\n}\r\n\r\n// Attunement tracking\r\nexport interface AttunementSlots {\r\n  used: number;\r\n  max: number; // Usually 3, but can be modified by features\r\n}\r\n\r\n// Armor types and interfaces\r\nexport type ArmorCategory = 'light' | 'medium' | 'heavy' | 'shield';\r\nexport type ArmorType =\r\n  | 'padded'\r\n  | 'leather'\r\n  | 'studded-leather'\r\n  | 'hide'\r\n  | 'chain-shirt'\r\n  | 'scale-mail'\r\n  | 'breastplate'\r\n  | 'half-plate'\r\n  | 'ring-mail'\r\n  | 'chain-mail'\r\n  | 'splint'\r\n  | 'plate'\r\n  | 'shield'\r\n  | 'custom';\r\n\r\nexport interface ArmorItem {\r\n  id: string;\r\n  name: string;\r\n  category: ArmorCategory;\r\n  type: ArmorType;\r\n  baseAC: number; // Base AC provided by armor\r\n  maxDexBonus?: number; // Max dex bonus (null = unlimited)\r\n  stealthDisadvantage: boolean;\r\n  strengthRequirement?: number;\r\n  enhancementBonus: number; // +0, +1, +2, +3\r\n  isEquipped: boolean;\r\n  requiresAttunement?: boolean;\r\n  isAttuned?: boolean;\r\n  description?: string;\r\n  weight?: number;\r\n  value?: number; // In copper pieces\r\n  createdAt: string;\r\n  updatedAt: string;\r\n}\r\n\r\n// General inventory item\r\nexport interface InventoryItem {\r\n  id: string;\r\n  name: string;\r\n  category: string; // \"weapon\", \"armor\", \"tool\", \"consumable\", \"treasure\", \"misc\"\r\n  location?: string; // Custom location like \"backpack\", \"bag of holding\", \"pocket\", etc.\r\n  rarity?: MagicItemRarity; // Item rarity (common, uncommon, rare, etc.)\r\n  type?: MagicItemCategory; // Item type (wondrous, ring, potion, etc.)\r\n  quantity: number;\r\n  weight?: number; // Per item\r\n  value?: number; // Per item, in copper pieces\r\n  description?: string;\r\n  tags: string[]; // For filtering/organization\r\n  createdAt: string;\r\n  updatedAt: string;\r\n}\r\n\r\n// Currency tracking\r\nexport interface Currency {\r\n  copper: number;\r\n  silver: number;\r\n  electrum: number;\r\n  gold: number;\r\n  platinum: number;\r\n}\r\n\r\n// Main character state interface\r\nexport interface CharacterState {\r\n  id: string;\r\n  // Basic Information\r\n  name: string;\r\n  race: string;\r\n  avatar?: string; // Base64 encoded image data\r\n\r\n  // Multiclass Support (new)\r\n  classes?: MulticlassInfo[]; // Array of classes for multiclass characters\r\n  totalLevel?: number; // Sum of all class levels\r\n  hitDicePools?: HitDicePools; // Hit dice pools by die type\r\n\r\n  // Backwards Compatibility (deprecated but maintained)\r\n  class: ClassInfo; // Single class info (for backwards compatibility)\r\n  level: number; // Total character level (for backwards compatibility)\r\n\r\n  experience: number;\r\n  background: string;\r\n  alignment: string;\r\n  playerName: string;\r\n\r\n  // Ability Scores\r\n  abilities: CharacterAbilities;\r\n\r\n  // Skills (all 18 D&D skills)\r\n  skills: {\r\n    acrobatics: SkillProficiency;\r\n    animalHandling: SkillProficiency;\r\n    arcana: SkillProficiency;\r\n    athletics: SkillProficiency;\r\n    deception: SkillProficiency;\r\n    history: SkillProficiency;\r\n    insight: SkillProficiency;\r\n    intimidation: SkillProficiency;\r\n    investigation: SkillProficiency;\r\n    medicine: SkillProficiency;\r\n    nature: SkillProficiency;\r\n    perception: SkillProficiency;\r\n    performance: SkillProficiency;\r\n    persuasion: SkillProficiency;\r\n    religion: SkillProficiency;\r\n    sleightOfHand: SkillProficiency;\r\n    stealth: SkillProficiency;\r\n    survival: SkillProficiency;\r\n  };\r\n\r\n  // Combat Stats\r\n  hitPoints: HitPoints;\r\n  armorClass: number;\r\n  tempArmorClass: number; // Temporary AC bonuses from spells, effects, etc.\r\n  isWearingShield: boolean; // Whether character is currently wearing/using a shield\r\n  shieldBonus: number; // AC bonus from shield (default +2, but can be +1, +3, etc.)\r\n  initiative: InitiativeData;\r\n  reaction: ReactionData;\r\n  speed: number;\r\n  hitDice: string; // e.g., \"1d8\", \"2d6\" (for backwards compatibility)\r\n\r\n  // Saving Throws\r\n  savingThrows: {\r\n    strength: SavingThrowProficiency;\r\n    dexterity: SavingThrowProficiency;\r\n    constitution: SavingThrowProficiency;\r\n    intelligence: SavingThrowProficiency;\r\n    wisdom: SavingThrowProficiency;\r\n    charisma: SavingThrowProficiency;\r\n  };\r\n\r\n  // Spell Slots\r\n  spellSlots: SpellSlots;\r\n  pactMagic?: PactMagic; // Only for warlocks\r\n\r\n  // Heroic Inspiration\r\n  heroicInspiration: HeroicInspiration;\r\n\r\n  // Trackable Traits\r\n  trackableTraits: TrackableTrait[];\r\n\r\n  // Extended Features (new system)\r\n  extendedFeatures: ExtendedFeature[];\r\n\r\n  // Rich Text Content\r\n  features: RichTextContent[];\r\n  traits: RichTextContent[];\r\n  notes: RichTextContent[];\r\n  characterBackground: CharacterBackground;\r\n\r\n  // Weapons and Equipment\r\n  weapons: Weapon[];\r\n  magicItems: MagicItem[];\r\n  armorItems: ArmorItem[];\r\n  inventoryItems: InventoryItem[];\r\n  currency: Currency;\r\n  attunementSlots: AttunementSlots;\r\n  weaponProficiencies: {\r\n    simpleWeapons: boolean;\r\n    martialWeapons: boolean;\r\n    specificWeapons: string[]; // Array of specific weapon names\r\n  };\r\n\r\n  // Spellcasting\r\n  spells: Spell[]; // All spells and cantrips known/prepared\r\n  spellcastingStats: SpellcastingStats;\r\n  concentration: ConcentrationState; // Active concentration tracking\r\n\r\n  // Death saving throws\r\n  deathSavingThrows: DeathSavingThrows;\r\n\r\n  // Spellbook and grimoire system\r\n  spellbook: SpellbookState;\r\n\r\n  // Conditions and diseases\r\n  conditionsAndDiseases: ConditionsDiseasesState;\r\n\r\n  // Class Features\r\n  jackOfAllTrades: boolean; // Bard feature: add half proficiency to non-proficient skills\r\n\r\n  // Languages and Tool Proficiencies\r\n  languages: Language[];\r\n  toolProficiencies: ToolProficiency[];\r\n\r\n  daysSpent: number; // Number of in-game days spent in the campaign\r\n\r\n  // Miscellaneous\r\n}\r\n\r\n// UI state for managing application state\r\nexport interface UIState {\r\n  activeTab: string;\r\n  saveStatus: 'saving' | 'saved' | 'error';\r\n  lastSaved: Date | null;\r\n}\r\n\r\n// Export/Import data structure\r\nexport interface CharacterExport {\r\n  version: string;\r\n  exportDate: string;\r\n  character: CharacterState;\r\n}\r\n\r\n// Save state type\r\nexport type SaveStatus = 'saving' | 'saved' | 'error';\r\n\r\n// Exhaustion variants (2014 vs 2024)\r\nexport type ExhaustionVariant = '2014' | '2024';\r\n\r\n// Active condition tracking\r\nexport interface ActiveCondition {\r\n  id: string;\r\n  name: string;\r\n  source: string; // PHB, XPHB, etc.\r\n  description: string;\r\n  stackable: boolean;\r\n  count: number; // For stackable conditions like exhaustion\r\n  appliedAt: string; // ISO date string\r\n  notes?: string; // Optional player notes\r\n}\r\n\r\n// Active disease tracking\r\nexport interface ActiveDisease {\r\n  id: string;\r\n  name: string;\r\n  source: string;\r\n  description: string;\r\n  onsetTime?: string; // When symptoms started\r\n  appliedAt: string; // ISO date string\r\n  notes?: string;\r\n}\r\n\r\n// Conditions and diseases state\r\nexport interface ConditionsDiseasesState {\r\n  activeConditions: ActiveCondition[];\r\n  activeDiseases: ActiveDisease[];\r\n  exhaustionVariant: ExhaustionVariant; // Player's preference for exhaustion rules\r\n}\r\n\r\n// Raw JSON data types for conditions/diseases\r\nexport interface RawConditionEntry {\r\n  type?: string;\r\n  name?: string;\r\n  entries?: (string | RawConditionEntry)[];\r\n  items?: (string | RawConditionEntry)[];\r\n  entry?: string; // Single entry field (used in item objects)\r\n}\r\n\r\nexport interface RawCondition {\r\n  name: string;\r\n  source: string;\r\n  page?: number;\r\n  srd?: boolean;\r\n  basicRules?: boolean;\r\n  srd52?: boolean;\r\n  basicRules2024?: boolean;\r\n  reprintedAs?: string[];\r\n  entries: (string | RawConditionEntry)[];\r\n  hasFluffImages?: boolean;\r\n}\r\n\r\nexport interface RawDisease {\r\n  name: string;\r\n  source: string;\r\n  page?: number;\r\n  type?: string;\r\n  entries: string[];\r\n}\r\n\r\nexport interface RawStatus {\r\n  name: string;\r\n  source: string;\r\n  page?: number;\r\n  srd?: boolean;\r\n  basicRules?: boolean;\r\n  srd52?: boolean;\r\n  basicRules2024?: boolean;\r\n  reprintedAs?: string[];\r\n  entries: (string | RawConditionEntry)[];\r\n}\r\n\r\nexport interface RawConditionsDiseasesData {\r\n  condition: RawCondition[];\r\n  disease: RawDisease[];\r\n  status: RawStatus[];\r\n}\r\n\r\n// Processed condition/disease data\r\nexport interface ProcessedCondition {\r\n  id: string;\r\n  name: string;\r\n  source: string;\r\n  description: string;\r\n  isExhaustion: boolean;\r\n  stackable: boolean;\r\n  variant?: '2014' | '2024'; // For conditions that have multiple versions\r\n}\r\n\r\nexport interface ProcessedDisease {\r\n  id: string;\r\n  name: string;\r\n  source: string;\r\n  description: string;\r\n  type?: string;\r\n}\r\n\r\nexport interface ProcessedStatus {\r\n  id: string;\r\n  name: string;\r\n  source: string;\r\n  description: string;\r\n}\r\n\r\n// Utility functions for extended features\r\nexport function migrateTraitToExtendedFeature(\r\n  trait: TrackableTrait,\r\n  index: number\r\n): ExtendedFeature {\r\n  return {\r\n    ...trait,\r\n    sourceType: 'other' as const,\r\n    sourceDetail: trait.source || undefined,\r\n    displayOrder: index,\r\n    isPassive: trait.maxUses === 0,\r\n  };\r\n}\r\n\r\nexport function groupFeaturesBySource(\r\n  features: ExtendedFeature[]\r\n): FeatureCategory[] {\r\n  const grouped = features.reduce(\r\n    (acc, feature) => {\r\n      if (!acc[feature.sourceType]) {\r\n        acc[feature.sourceType] = [];\r\n      }\r\n      acc[feature.sourceType].push(feature);\r\n      return acc;\r\n    },\r\n    {} as Record<FeatureSourceType, ExtendedFeature[]>\r\n  );\r\n\r\n  return Object.entries(grouped).map(([sourceType, features]) => ({\r\n    sourceType: sourceType as FeatureSourceType,\r\n    label: FEATURE_SOURCE_LABELS[sourceType as FeatureSourceType],\r\n    description: FEATURE_SOURCE_DESCRIPTIONS[sourceType as FeatureSourceType],\r\n    features: features.sort((a, b) => a.displayOrder - b.displayOrder),\r\n    isCollapsed: false,\r\n  }));\r\n}\r\n\r\nexport function createDefaultExtendedFeature(\r\n  sourceType: FeatureSourceType = 'other'\r\n): Omit<ExtendedFeature, 'id' | 'createdAt' | 'updatedAt'> {\r\n  return {\r\n    name: '',\r\n    description: '',\r\n    maxUses: 1,\r\n    usedUses: 0,\r\n    restType: 'long',\r\n    source: '',\r\n    sourceType,\r\n    sourceDetail: '',\r\n    category: '',\r\n    displayOrder: 0,\r\n    isPassive: false,\r\n    scaleWithProficiency: false,\r\n    proficiencyMultiplier: 1,\r\n  };\r\n}\r\n\r\n// Multiclassing types\r\nexport interface MulticlassInfo {\r\n  className: string;\r\n  level: number;\r\n  isCustom: boolean;\r\n  spellcaster?: 'full' | 'half' | 'third' | 'warlock' | 'none';\r\n  hitDie: number;\r\n  subclass?: string;\r\n}\r\n\r\nexport interface HitDicePools {\r\n  [key: string]: {\r\n    max: number;\r\n    used: number;\r\n  };\r\n}\r\n\r\nexport interface MulticlassValidation {\r\n  valid: boolean;\r\n  errors: string[];\r\n  warnings?: string[];\r\n}\r\n"],"names":[],"mappings":"AAAA,mDAAmD;;;;;;;;;;;;;AAkM5C,MAAM,wBAA2D;IACtE,OAAO;IACP,MAAM;IACN,MAAM;IACN,YAAY;IACZ,cAAc;IACd,OAAO;AACT;AAEO,MAAM,8BAAiE;IAC5E,OAAO;IACP,MAAM;IACN,MAAM;IACN,YAAY;IACZ,cAAc;IACd,OAAO;AACT;AAogBO,SAAS,8BACd,KAAqB,EACrB,KAAa;IAEb,OAAO;QACL,GAAG,KAAK;QACR,YAAY;QACZ,cAAc,MAAM,MAAM,IAAI;QAC9B,cAAc;QACd,WAAW,MAAM,OAAO,KAAK;IAC/B;AACF;AAEO,SAAS,sBACd,QAA2B;IAE3B,MAAM,UAAU,SAAS,MAAM,CAC7B,CAAC,KAAK;QACJ,IAAI,CAAC,GAAG,CAAC,QAAQ,UAAU,CAAC,EAAE;YAC5B,GAAG,CAAC,QAAQ,UAAU,CAAC,GAAG,EAAE;QAC9B;QACA,GAAG,CAAC,QAAQ,UAAU,CAAC,CAAC,IAAI,CAAC;QAC7B,OAAO;IACT,GACA,CAAC;IAGH,OAAO,OAAO,OAAO,CAAC,SAAS,GAAG,CAAC;YAAC,CAAC,YAAY,SAAS;eAAM;YAC9D,YAAY;YACZ,OAAO,qBAAqB,CAAC,WAAgC;YAC7D,aAAa,2BAA2B,CAAC,WAAgC;YACzE,UAAU,SAAS,IAAI,CAAC,CAAC,GAAG,IAAM,EAAE,YAAY,GAAG,EAAE,YAAY;YACjE,aAAa;QACf;;AACF;AAEO,SAAS;QACd,aAAA,iEAAgC;IAEhC,OAAO;QACL,MAAM;QACN,aAAa;QACb,SAAS;QACT,UAAU;QACV,UAAU;QACV,QAAQ;QACR;QACA,cAAc;QACd,UAAU;QACV,cAAc;QACd,WAAW;QACX,sBAAsB;QACtB,uBAAuB;IACzB;AACF","debugId":null}},
    {"offset": {"line": 1310, "column": 0}, "map": {"version":3,"sources":["file:///home/irakli/Projects/RollKeeper/apps/web/src/types/features.ts"],"sourcesContent":["/**\r\n * Feature Source Types\r\n * Unified types for all feature/trait sources (backgrounds, feats, class features)\r\n */\r\n\r\nimport { ClassFeature } from './classes';\r\nimport {\r\n  ProcessedBackground,\r\n  ProcessedBackgroundFeature,\r\n} from '../utils/backgroundDataLoader';\r\nimport { ProcessedFeat } from '../utils/featDataLoader';\r\n\r\n// Re-export class feature type\r\nexport type ProcessedClassFeature = ClassFeature;\r\n\r\n// Re-export for convenience\r\nexport type { ProcessedBackground, ProcessedBackgroundFeature, ProcessedFeat };\r\n\r\n// Union type for all feature sources\r\nexport type ProcessedFeatureSource =\r\n  | ProcessedBackgroundFeature\r\n  | ProcessedFeat\r\n  | ProcessedClassFeature;\r\n\r\n// Type guard functions\r\nexport function isBackgroundFeature(\r\n  feature: ProcessedFeatureSource\r\n): feature is ProcessedBackgroundFeature {\r\n  return 'backgroundName' in feature;\r\n}\r\n\r\nexport function isFeat(\r\n  feature: ProcessedFeatureSource\r\n): feature is ProcessedFeat {\r\n  return 'prerequisites' in feature && 'repeatable' in feature;\r\n}\r\n\r\nexport function isClassFeature(\r\n  feature: ProcessedFeatureSource\r\n): feature is ProcessedClassFeature {\r\n  return 'className' in feature && 'level' in feature;\r\n}\r\n\r\n// Feature source type for filtering\r\nexport type FeatureSourceFilter =\r\n  | 'class'\r\n  | 'subclass'\r\n  | 'background'\r\n  | 'feat'\r\n  | 'all';\r\n\r\n// Feature autocomplete item (unified interface for display)\r\nexport interface FeatureAutocompleteItem {\r\n  id: string;\r\n  name: string;\r\n  source: string;\r\n  sourceType: FeatureSourceFilter;\r\n  description: string;\r\n  metadata: {\r\n    // For backgrounds\r\n    backgroundName?: string;\r\n    skills?: string[];\r\n\r\n    // For feats\r\n    prerequisites?: string[];\r\n    abilityIncreases?: string;\r\n    repeatable?: boolean;\r\n\r\n    // For class features\r\n    className?: string;\r\n    level?: number;\r\n    isSubclassFeature?: boolean;\r\n    subclassShortName?: string;\r\n  };\r\n  tags: string[];\r\n}\r\n\r\n/**\r\n * Convert ProcessedBackgroundFeature to FeatureAutocompleteItem\r\n */\r\nexport function backgroundFeatureToAutocompleteItem(\r\n  feature: ProcessedBackgroundFeature\r\n): FeatureAutocompleteItem {\r\n  return {\r\n    id: feature.id,\r\n    name: feature.name,\r\n    source: feature.source,\r\n    sourceType: 'background',\r\n    description: feature.description,\r\n    metadata: {\r\n      backgroundName: feature.backgroundName,\r\n      skills: feature.skills,\r\n    },\r\n    tags: [feature.source, feature.backgroundName, 'background'],\r\n  };\r\n}\r\n\r\n/**\r\n * Convert ProcessedFeat to FeatureAutocompleteItem\r\n */\r\nexport function featToAutocompleteItem(\r\n  feat: ProcessedFeat\r\n): FeatureAutocompleteItem {\r\n  return {\r\n    id: feat.id,\r\n    name: feat.name,\r\n    source: feat.source,\r\n    sourceType: 'feat',\r\n    description: feat.description,\r\n    metadata: {\r\n      prerequisites: feat.prerequisites,\r\n      abilityIncreases: feat.abilityIncreases,\r\n      repeatable: feat.repeatable,\r\n    },\r\n    tags: feat.tags,\r\n  };\r\n}\r\n\r\n/**\r\n * Convert ClassFeature to FeatureAutocompleteItem\r\n */\r\nexport function classFeatureToAutocompleteItem(\r\n  feature: ClassFeature\r\n): FeatureAutocompleteItem {\r\n  // Create a unique ID that includes source and subclass (if applicable) to avoid collisions\r\n  const sourceKey = feature.source.toLowerCase().replace(/[^a-z0-9]/g, '-');\r\n  const subclassKey = feature.subclassShortName\r\n    ? `-${feature.subclassShortName.toLowerCase().replace(/[^a-z0-9]/g, '-')}`\r\n    : '';\r\n\r\n  // Use a counter or index to ensure uniqueness even within same class/level/source/subclass\r\n  const id = `${feature.className}-${feature.name}-${feature.level}-${sourceKey}${subclassKey}-${feature.original || ''}`;\r\n\r\n  return {\r\n    id,\r\n    name: feature.name,\r\n    source: feature.source,\r\n    sourceType: feature.isSubclassFeature ? 'subclass' : 'class',\r\n    description: feature.entries?.join('\\n\\n') || '',\r\n    metadata: {\r\n      className: feature.className,\r\n      level: feature.level,\r\n      isSubclassFeature: feature.isSubclassFeature,\r\n      subclassShortName: feature.subclassShortName,\r\n    },\r\n    tags: [\r\n      feature.source,\r\n      feature.className || '',\r\n      feature.isSubclassFeature ? 'subclass' : 'class',\r\n      ...(feature.subclassShortName ? [feature.subclassShortName] : []),\r\n    ].filter(Boolean),\r\n  };\r\n}\r\n"],"names":[],"mappings":"AAAA;;;CAGC;;;;;;;;;;;;;;AAsBM,SAAS,oBACd,OAA+B;IAE/B,OAAO,oBAAoB;AAC7B;AAEO,SAAS,OACd,OAA+B;IAE/B,OAAO,mBAAmB,WAAW,gBAAgB;AACvD;AAEO,SAAS,eACd,OAA+B;IAE/B,OAAO,eAAe,WAAW,WAAW;AAC9C;AAuCO,SAAS,oCACd,OAAmC;IAEnC,OAAO;QACL,IAAI,QAAQ,EAAE;QACd,MAAM,QAAQ,IAAI;QAClB,QAAQ,QAAQ,MAAM;QACtB,YAAY;QACZ,aAAa,QAAQ,WAAW;QAChC,UAAU;YACR,gBAAgB,QAAQ,cAAc;YACtC,QAAQ,QAAQ,MAAM;QACxB;QACA,MAAM;YAAC,QAAQ,MAAM;YAAE,QAAQ,cAAc;YAAE;SAAa;IAC9D;AACF;AAKO,SAAS,uBACd,IAAmB;IAEnB,OAAO;QACL,IAAI,KAAK,EAAE;QACX,MAAM,KAAK,IAAI;QACf,QAAQ,KAAK,MAAM;QACnB,YAAY;QACZ,aAAa,KAAK,WAAW;QAC7B,UAAU;YACR,eAAe,KAAK,aAAa;YACjC,kBAAkB,KAAK,gBAAgB;YACvC,YAAY,KAAK,UAAU;QAC7B;QACA,MAAM,KAAK,IAAI;IACjB;AACF;AAKO,SAAS,+BACd,OAAqB;QAgBN;IAdf,2FAA2F;IAC3F,MAAM,YAAY,QAAQ,MAAM,CAAC,WAAW,GAAG,OAAO,CAAC,cAAc;IACrE,MAAM,cAAc,QAAQ,iBAAiB,GACzC,AAAC,IAAsE,OAAnE,QAAQ,iBAAiB,CAAC,WAAW,GAAG,OAAO,CAAC,cAAc,QAClE;IAEJ,2FAA2F;IAC3F,MAAM,KAAK,AAAC,GAAuB,OAArB,QAAQ,SAAS,EAAC,KAAmB,OAAhB,QAAQ,IAAI,EAAC,KAAoB,OAAjB,QAAQ,KAAK,EAAC,KAAe,OAAZ,WAA2B,OAAf,aAAY,KAA0B,OAAvB,QAAQ,QAAQ,IAAI;IAEnH,OAAO;QACL;QACA,MAAM,QAAQ,IAAI;QAClB,QAAQ,QAAQ,MAAM;QACtB,YAAY,QAAQ,iBAAiB,GAAG,aAAa;QACrD,aAAa,EAAA,mBAAA,QAAQ,OAAO,cAAf,uCAAA,iBAAiB,IAAI,CAAC,YAAW;QAC9C,UAAU;YACR,WAAW,QAAQ,SAAS;YAC5B,OAAO,QAAQ,KAAK;YACpB,mBAAmB,QAAQ,iBAAiB;YAC5C,mBAAmB,QAAQ,iBAAiB;QAC9C;QACA,MAAM;YACJ,QAAQ,MAAM;YACd,QAAQ,SAAS,IAAI;YACrB,QAAQ,iBAAiB,GAAG,aAAa;eACrC,QAAQ,iBAAiB,GAAG;gBAAC,QAAQ,iBAAiB;aAAC,GAAG,EAAE;SACjE,CAAC,MAAM,CAAC;IACX;AACF","debugId":null}},
    {"offset": {"line": 1405, "column": 0}, "map": {"version":3,"sources":["file:///home/irakli/Projects/RollKeeper/apps/web/src/contexts/NavigationContext.tsx"],"sourcesContent":["'use client';\r\n\r\nimport { createContext, useContext } from 'react';\r\n\r\n// Navigation context for tab switching\r\ninterface NavigationContextType {\r\n  switchToTab: (tabId: string) => void;\r\n}\r\n\r\nexport const NavigationContext = createContext<NavigationContextType | null>(\r\n  null\r\n);\r\n\r\nexport const useNavigation = () => {\r\n  const context = useContext(NavigationContext);\r\n  if (!context) {\r\n    throw new Error('useNavigation must be used within NavigationContext');\r\n  }\r\n  return context;\r\n};\r\n"],"names":[],"mappings":";;;;;;AAEA;;AAFA;;AASO,MAAM,kCAAoB,IAAA,8KAAa,EAC5C;AAGK,MAAM,gBAAgB;;IAC3B,MAAM,UAAU,IAAA,2KAAU,EAAC;IAC3B,IAAI,CAAC,SAAS;QACZ,MAAM,IAAI,MAAM;IAClB;IACA,OAAO;AACT;GANa","debugId":null}}]
}