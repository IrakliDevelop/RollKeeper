{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 3, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"","debugId":null}},
    {"offset": {"line": 55, "column": 0}, "map": {"version":3,"sources":["file:///home/irakli/Projects/RollKeeper/apps/web/src/utils/backgroundDataLoader.ts"],"sourcesContent":["/**\r\n * Background Data Loader\r\n * Loads and processes background data from JSON files\r\n * Similar structure to spellDataLoader.ts\r\n */\r\n\r\nimport backgroundsData from '../../json/backgrounds.json';\r\n\r\n// Raw background data from JSON\r\ninterface RawBackgroundData {\r\n  name: string;\r\n  source: string;\r\n  page?: number;\r\n  srd?: boolean;\r\n  basicRules?: boolean;\r\n  reprintedAs?: string[];\r\n  skillProficiencies?: Array<Record<string, boolean | number>>;\r\n  languageProficiencies?: Array<Record<string, number>>;\r\n  startingEquipment?: unknown[];\r\n  entries?: Array<string | BackgroundEntry>; // Optional since some backgrounds may not have entries\r\n}\r\n\r\ninterface BackgroundEntry {\r\n  type: string;\r\n  name?: string;\r\n  entries?: Array<string | unknown>;\r\n  data?: {\r\n    isFeature?: boolean;\r\n  };\r\n  [key: string]: unknown;\r\n}\r\n\r\n// Processed background feature for our application\r\nexport interface ProcessedBackgroundFeature {\r\n  id: string;\r\n  name: string; // Feature name (e.g., \"Shelter of the Faithful\")\r\n  backgroundName: string; // Background name (e.g., \"Acolyte\")\r\n  source: string;\r\n  page?: number;\r\n  description: string; // Parsed and formatted description\r\n  skills?: string[]; // Skill proficiencies granted\r\n  languages?: number; // Number of languages granted\r\n  isSrd: boolean;\r\n}\r\n\r\n// Processed background with all features\r\nexport interface ProcessedBackground {\r\n  id: string;\r\n  name: string;\r\n  source: string;\r\n  page?: number;\r\n  features: ProcessedBackgroundFeature[];\r\n  skills: string[];\r\n  languages: number;\r\n  isSrd: boolean;\r\n  tags: string[];\r\n}\r\n\r\n// Cache for processed backgrounds\r\nlet cachedBackgrounds: ProcessedBackground[] | null = null;\r\nlet cachedFeatures: ProcessedBackgroundFeature[] | null = null;\r\n\r\n/**\r\n * Generate unique ID for background\r\n */\r\nfunction generateBackgroundId(name: string, source: string): string {\r\n  return `${name.toLowerCase().replace(/\\s+/g, '-')}-${source.toLowerCase()}`;\r\n}\r\n\r\n/**\r\n * Generate unique ID for background feature\r\n */\r\nfunction generateFeatureId(\r\n  featureName: string,\r\n  backgroundName: string,\r\n  source: string\r\n): string {\r\n  return `${featureName.toLowerCase().replace(/\\s+/g, '-')}-${backgroundName.toLowerCase().replace(/\\s+/g, '-')}-${source.toLowerCase()}`;\r\n}\r\n\r\n/**\r\n * Format source for display\r\n */\r\nfunction formatSourceForDisplay(source: string): string {\r\n  const sourceMap: Record<string, string> = {\r\n    PHB: \"Player's Handbook\",\r\n    XPHB: \"Player's Handbook (2024)\",\r\n    DMG: \"Dungeon Master's Guide\",\r\n    SCAG: \"Sword Coast Adventurer's Guide\",\r\n    XGTE: \"Xanathar's Guide to Everything\",\r\n    TCE: \"Tasha's Cauldron of Everything\",\r\n    VRGTR: \"Van Richten's Guide to Ravenloft\",\r\n    MPMM: 'Mordenkainen Presents: Monsters of the Multiverse',\r\n    ERLW: 'Eberron: Rising from the Last War',\r\n    GGTR: \"Guildmasters' Guide to Ravnica\",\r\n    MOT: 'Mythic Odysseys of Theros',\r\n    AI: 'Acquisitions Incorporated',\r\n  };\r\n\r\n  return sourceMap[source] || source;\r\n}\r\n\r\n/**\r\n * Parse background entries to extract feature descriptions\r\n */\r\nfunction parseFeatureEntries(entries: Array<string | unknown>): string {\r\n  return entries\r\n    .map(entry => {\r\n      if (typeof entry === 'string') {\r\n        return entry;\r\n      }\r\n\r\n      // Handle nested entry objects\r\n      if (entry && typeof entry === 'object') {\r\n        const obj = entry as Record<string, unknown>;\r\n\r\n        // Handle nested entries\r\n        if (obj.type === 'entries' && Array.isArray(obj.entries)) {\r\n          return parseFeatureEntries(obj.entries);\r\n        }\r\n\r\n        // Handle lists\r\n        if (obj.type === 'list' && Array.isArray(obj.items)) {\r\n          return obj.items\r\n            .map((item: unknown) => {\r\n              if (typeof item === 'string') return item;\r\n              if (item && typeof item === 'object') {\r\n                const itemObj = item as Record<string, unknown>;\r\n                if (itemObj.type === 'item' && itemObj.entry) {\r\n                  return `â€¢ ${itemObj.entry}`;\r\n                }\r\n              }\r\n              return '';\r\n            })\r\n            .filter(Boolean)\r\n            .join('\\n');\r\n        }\r\n\r\n        // Handle tables - provide simplified text representation\r\n        if (obj.type === 'table') {\r\n          return '_(See table in source material)_';\r\n        }\r\n      }\r\n\r\n      return '';\r\n    })\r\n    .filter(Boolean)\r\n    .join('\\n\\n');\r\n}\r\n\r\n/**\r\n * Extract skills from skill proficiencies\r\n */\r\nfunction extractSkills(\r\n  skillProficiencies?: Array<Record<string, boolean | number>>\r\n): string[] {\r\n  if (!skillProficiencies || skillProficiencies.length === 0) return [];\r\n\r\n  const skills: string[] = [];\r\n\r\n  skillProficiencies.forEach(prof => {\r\n    Object.keys(prof).forEach(key => {\r\n      if (prof[key] === true) {\r\n        // Convert to proper case\r\n        const skill = key.replace(/([A-Z])/g, ' $1').trim();\r\n        skills.push(skill.charAt(0).toUpperCase() + skill.slice(1));\r\n      }\r\n    });\r\n  });\r\n\r\n  return skills;\r\n}\r\n\r\n/**\r\n * Extract number of language proficiencies\r\n */\r\nfunction extractLanguages(\r\n  languageProficiencies?: Array<Record<string, number>>\r\n): number {\r\n  if (!languageProficiencies || languageProficiencies.length === 0) return 0;\r\n\r\n  let count = 0;\r\n  languageProficiencies.forEach(prof => {\r\n    if (prof.anyStandard) {\r\n      count += prof.anyStandard;\r\n    }\r\n    if (prof.any) {\r\n      count += prof.any;\r\n    }\r\n  });\r\n\r\n  return count;\r\n}\r\n\r\n/**\r\n * Process raw background data into our application format\r\n */\r\nfunction processBackground(\r\n  rawBackground: RawBackgroundData\r\n): ProcessedBackground {\r\n  const id = generateBackgroundId(rawBackground.name, rawBackground.source);\r\n  const skills = extractSkills(rawBackground.skillProficiencies);\r\n  const languages = extractLanguages(rawBackground.languageProficiencies);\r\n\r\n  // Extract features from entries (entries marked with data.isFeature: true)\r\n  const features: ProcessedBackgroundFeature[] = [];\r\n\r\n  // Check if entries exist before processing\r\n  if (rawBackground.entries && Array.isArray(rawBackground.entries)) {\r\n    rawBackground.entries.forEach(entry => {\r\n      if (entry && typeof entry === 'object') {\r\n        const entryObj = entry as BackgroundEntry;\r\n\r\n        // Check if this is a feature entry\r\n        if (entryObj.data?.isFeature && entryObj.name && entryObj.entries) {\r\n          // Remove \"Feature: \" prefix if present\r\n          const featureName = entryObj.name.replace(/^Feature:\\s*/i, '');\r\n\r\n          const featureDescription = parseFeatureEntries(entryObj.entries);\r\n\r\n          const feature: ProcessedBackgroundFeature = {\r\n            id: generateFeatureId(\r\n              featureName,\r\n              rawBackground.name,\r\n              rawBackground.source\r\n            ),\r\n            name: featureName,\r\n            backgroundName: rawBackground.name,\r\n            source: formatSourceForDisplay(rawBackground.source),\r\n            page: rawBackground.page,\r\n            description: featureDescription,\r\n            skills: skills,\r\n            languages: languages > 0 ? languages : undefined,\r\n            isSrd: rawBackground.srd || false,\r\n          };\r\n\r\n          features.push(feature);\r\n        }\r\n      }\r\n    });\r\n  }\r\n\r\n  return {\r\n    id,\r\n    name: rawBackground.name,\r\n    source: formatSourceForDisplay(rawBackground.source),\r\n    page: rawBackground.page,\r\n    features,\r\n    skills,\r\n    languages,\r\n    isSrd: rawBackground.srd || false,\r\n    tags: [rawBackground.source, ...skills.map(s => s.toLowerCase())],\r\n  };\r\n}\r\n\r\n/**\r\n * Load and process all backgrounds from JSON files\r\n */\r\nexport async function loadAllBackgrounds(): Promise<ProcessedBackground[]> {\r\n  // Return cached backgrounds if available\r\n  if (cachedBackgrounds) {\r\n    return cachedBackgrounds;\r\n  }\r\n\r\n  try {\r\n    const rawBackgrounds = backgroundsData.background as RawBackgroundData[];\r\n\r\n    const processedBackgrounds = rawBackgrounds.map(bg =>\r\n      processBackground(bg)\r\n    );\r\n\r\n    // Cache the processed backgrounds\r\n    cachedBackgrounds = processedBackgrounds;\r\n\r\n    console.log(`Loaded ${processedBackgrounds.length} backgrounds`);\r\n\r\n    return processedBackgrounds;\r\n  } catch (error) {\r\n    console.error('Error loading backgrounds:', error);\r\n    throw error;\r\n  }\r\n}\r\n\r\n/**\r\n * Load all background features (flat list)\r\n */\r\nexport async function loadAllBackgroundFeatures(): Promise<\r\n  ProcessedBackgroundFeature[]\r\n> {\r\n  // Return cached features if available\r\n  if (cachedFeatures) {\r\n    return cachedFeatures;\r\n  }\r\n\r\n  try {\r\n    const backgrounds = await loadAllBackgrounds();\r\n\r\n    // Flatten all features from all backgrounds\r\n    const allFeatures = backgrounds.flatMap(bg => bg.features);\r\n\r\n    // Cache the features\r\n    cachedFeatures = allFeatures;\r\n\r\n    console.log(\r\n      `Loaded ${allFeatures.length} background features from ${backgrounds.length} backgrounds`\r\n    );\r\n\r\n    return allFeatures;\r\n  } catch (error) {\r\n    console.error('Error loading background features:', error);\r\n    throw error;\r\n  }\r\n}\r\n\r\n/**\r\n * Clear the cache (useful for testing or forced reloads)\r\n */\r\nexport function clearBackgroundCache(): void {\r\n  cachedBackgrounds = null;\r\n  cachedFeatures = null;\r\n}\r\n\r\n/**\r\n * Get background by name\r\n */\r\nexport async function getBackgroundByName(\r\n  name: string\r\n): Promise<ProcessedBackground | undefined> {\r\n  const backgrounds = await loadAllBackgrounds();\r\n  return backgrounds.find(bg => bg.name.toLowerCase() === name.toLowerCase());\r\n}\r\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 269, "column": 0}, "map": {"version":3,"sources":["file:///home/irakli/Projects/RollKeeper/apps/web/src/app/api/backgrounds/route.ts"],"sourcesContent":["import { NextResponse } from 'next/server';\r\nimport {\r\n  loadAllBackgrounds,\r\n  loadAllBackgroundFeatures,\r\n} from '@/utils/backgroundDataLoader';\r\n\r\nexport async function GET() {\r\n  try {\r\n    const [backgrounds, features] = await Promise.all([\r\n      loadAllBackgrounds(),\r\n      loadAllBackgroundFeatures(),\r\n    ]);\r\n\r\n    return NextResponse.json({\r\n      backgrounds,\r\n      features,\r\n      total: backgrounds.length,\r\n    });\r\n  } catch (error) {\r\n    console.error('Error loading backgrounds:', error);\r\n    return NextResponse.json(\r\n      { error: 'Failed to load background data' },\r\n      { status: 500 }\r\n    );\r\n  }\r\n}\r\n"],"names":[],"mappings":";;;;AAAA;AACA;;;AAKO,eAAe;IACpB,IAAI;QACF,MAAM,CAAC,aAAa,SAAS,GAAG,MAAM,QAAQ,GAAG,CAAC;YAChD,IAAA,2KAAkB;YAClB,IAAA,kLAAyB;SAC1B;QAED,OAAO,gJAAY,CAAC,IAAI,CAAC;YACvB;YACA;YACA,OAAO,YAAY,MAAM;QAC3B;IACF,EAAE,OAAO,OAAO;QACd,QAAQ,KAAK,CAAC,8BAA8B;QAC5C,OAAO,gJAAY,CAAC,IAAI,CACtB;YAAE,OAAO;QAAiC,GAC1C;YAAE,QAAQ;QAAI;IAElB;AACF","debugId":null}}]
}