{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 3, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"","debugId":null}},
    {"offset": {"line": 55, "column": 0}, "map": {"version":3,"sources":["file:///home/irakli/Projects/RollKeeper/apps/web/src/utils/featDataLoader.ts"],"sourcesContent":["/**\r\n * Feat Data Loader\r\n * Loads and processes feat data from JSON files\r\n * Similar structure to backgroundDataLoader.ts\r\n */\r\n\r\nimport featsData from '../../json/feats.json';\r\n\r\n// Raw feat data from JSON\r\ninterface RawFeatData {\r\n  name: string;\r\n  source: string;\r\n  page?: number;\r\n  srd?: boolean;\r\n  srd52?: boolean;\r\n  basicRules?: boolean;\r\n  basicRules2024?: boolean;\r\n  category?: string; // e.g., \"G\" for general\r\n  prerequisite?: Array<{\r\n    level?: number;\r\n    ability?: Array<{ [key: string]: number }>;\r\n    spellcasting?: boolean;\r\n    proficiency?: Array<{ armor?: string; weapon?: string }>;\r\n    other?: string;\r\n    [key: string]: unknown;\r\n  }>;\r\n  ability?: Array<{\r\n    [key: string]: number | { choose?: { from: string[]; amount: number } };\r\n  }>;\r\n  repeatable?: boolean;\r\n  entries: Array<string | FeatEntry>;\r\n  additionalSpells?: unknown[];\r\n}\r\n\r\ninterface FeatEntry {\r\n  type: string;\r\n  name?: string;\r\n  entries?: Array<string | unknown>;\r\n  items?: Array<string | unknown>;\r\n  [key: string]: unknown;\r\n}\r\n\r\n// Processed feat for our application\r\nexport interface ProcessedFeat {\r\n  id: string;\r\n  name: string;\r\n  source: string;\r\n  page?: number;\r\n  description: string; // Parsed and formatted description\r\n  prerequisites: string[]; // Human-readable prerequisites\r\n  abilityIncreases: string; // Description of ability score increases\r\n  category?: string;\r\n  repeatable: boolean;\r\n  grantsSpells: boolean;\r\n  isSrd: boolean;\r\n  tags: string[];\r\n}\r\n\r\n// Cache for processed feats\r\nlet cachedFeats: ProcessedFeat[] | null = null;\r\n\r\n/**\r\n * Generate unique ID for feat\r\n */\r\nfunction generateFeatId(name: string, source: string): string {\r\n  return `${name.toLowerCase().replace(/\\s+/g, '-')}-${source.toLowerCase()}`;\r\n}\r\n\r\n/**\r\n * Format source for display\r\n */\r\nfunction formatSourceForDisplay(source: string): string {\r\n  const sourceMap: Record<string, string> = {\r\n    PHB: \"Player's Handbook\",\r\n    XPHB: \"Player's Handbook (2024)\",\r\n    DMG: \"Dungeon Master's Guide\",\r\n    XDMG: \"Dungeon Master's Guide (2024)\",\r\n    SCAG: \"Sword Coast Adventurer's Guide\",\r\n    XGTE: \"Xanathar's Guide to Everything\",\r\n    TCE: \"Tasha's Cauldron of Everything\",\r\n    VRGTR: \"Van Richten's Guide to Ravenloft\",\r\n    MPMM: 'Mordenkainen Presents: Monsters of the Multiverse',\r\n    ERLW: 'Eberron: Rising from the Last War',\r\n    GGTR: \"Guildmasters' Guide to Ravnica\",\r\n    MOT: 'Mythic Odysseys of Theros',\r\n    AI: 'Acquisitions Incorporated',\r\n    FTD: \"Fizban's Treasury of Dragons\",\r\n  };\r\n\r\n  return sourceMap[source] || source;\r\n}\r\n\r\n/**\r\n * Parse feat entries to extract descriptions\r\n */\r\nfunction parseFeatEntries(entries: Array<string | unknown>): string {\r\n  return entries\r\n    .map(entry => {\r\n      if (typeof entry === 'string') {\r\n        return entry;\r\n      }\r\n\r\n      // Handle nested entry objects\r\n      if (entry && typeof entry === 'object') {\r\n        const obj = entry as Record<string, unknown>;\r\n\r\n        // Handle nested entries\r\n        if (obj.type === 'entries' && Array.isArray(obj.entries)) {\r\n          let result = '';\r\n          if (obj.name) {\r\n            result += `**${obj.name}**\\n\\n`;\r\n          }\r\n          result += parseFeatEntries(obj.entries);\r\n          return result;\r\n        }\r\n\r\n        // Handle lists\r\n        if (obj.type === 'list' && Array.isArray(obj.items)) {\r\n          return obj.items\r\n            .map((item: unknown) => {\r\n              if (typeof item === 'string') return `• ${item}`;\r\n              if (item && typeof item === 'object') {\r\n                const itemObj = item as Record<string, unknown>;\r\n                if (itemObj.type === 'item') {\r\n                  const itemText = itemObj.entry || itemObj.name || '';\r\n                  return `• ${itemText}`;\r\n                }\r\n              }\r\n              return '';\r\n            })\r\n            .filter(Boolean)\r\n            .join('\\n');\r\n        }\r\n\r\n        // Handle tables\r\n        if (obj.type === 'table') {\r\n          return '_(See table in source material)_';\r\n        }\r\n\r\n        // Handle sections\r\n        if (obj.type === 'section' && Array.isArray(obj.entries)) {\r\n          return parseFeatEntries(obj.entries);\r\n        }\r\n      }\r\n\r\n      return '';\r\n    })\r\n    .filter(Boolean)\r\n    .join('\\n\\n');\r\n}\r\n\r\n/**\r\n * Parse prerequisites into human-readable format\r\n */\r\nfunction parsePrerequisites(\r\n  prerequisite?: RawFeatData['prerequisite']\r\n): string[] {\r\n  if (!prerequisite || prerequisite.length === 0) return [];\r\n\r\n  const prereqs: string[] = [];\r\n\r\n  prerequisite.forEach(prereq => {\r\n    if (prereq.level) {\r\n      prereqs.push(`Level ${prereq.level}+`);\r\n    }\r\n\r\n    if (prereq.ability) {\r\n      prereq.ability.forEach(abilityReq => {\r\n        Object.entries(abilityReq).forEach(([ability, value]) => {\r\n          const abilityName = ability.toUpperCase();\r\n          prereqs.push(`${abilityName} ${value}+`);\r\n        });\r\n      });\r\n    }\r\n\r\n    if (prereq.spellcasting) {\r\n      prereqs.push('Spellcasting or Pact Magic feature');\r\n    }\r\n\r\n    if (prereq.proficiency) {\r\n      prereq.proficiency.forEach(prof => {\r\n        if (prof.armor) {\r\n          prereqs.push(`Proficiency with ${prof.armor} armor`);\r\n        }\r\n        if (prof.weapon) {\r\n          prereqs.push(`Proficiency with ${prof.weapon}`);\r\n        }\r\n      });\r\n    }\r\n\r\n    if (prereq.other) {\r\n      prereqs.push(prereq.other);\r\n    }\r\n  });\r\n\r\n  return prereqs;\r\n}\r\n\r\n/**\r\n * Parse ability score increases\r\n */\r\nfunction parseAbilityIncreases(ability?: RawFeatData['ability']): string {\r\n  if (!ability || ability.length === 0) return '';\r\n\r\n  const increases: string[] = [];\r\n\r\n  ability.forEach(abilityObj => {\r\n    Object.entries(abilityObj).forEach(([key, value]) => {\r\n      if (key === 'choose' && typeof value === 'object' && value !== null) {\r\n        const choice = value as { from?: string[]; amount?: number };\r\n        if (choice.from && choice.amount) {\r\n          const abilities = choice.from.map(a => a.toUpperCase()).join(', ');\r\n          increases.push(\r\n            `Increase ${choice.amount} ability score${choice.amount > 1 ? 's' : ''} from: ${abilities}`\r\n          );\r\n        }\r\n      } else if (typeof value === 'number') {\r\n        increases.push(`+${value} ${key.toUpperCase()}`);\r\n      } else if (key === 'hidden') {\r\n        // Skip hidden entries\r\n      }\r\n    });\r\n  });\r\n\r\n  return increases.join('; ') || '';\r\n}\r\n\r\n/**\r\n * Check if feat grants spells\r\n */\r\nfunction grantsSpells(feat: RawFeatData): boolean {\r\n  return !!(feat.additionalSpells && feat.additionalSpells.length > 0);\r\n}\r\n\r\n/**\r\n * Process raw feat data into our application format\r\n */\r\nfunction processFeat(rawFeat: RawFeatData): ProcessedFeat {\r\n  const id = generateFeatId(rawFeat.name, rawFeat.source);\r\n  const description = parseFeatEntries(rawFeat.entries);\r\n  const prerequisites = parsePrerequisites(rawFeat.prerequisite);\r\n  const abilityIncreases = parseAbilityIncreases(rawFeat.ability);\r\n\r\n  return {\r\n    id,\r\n    name: rawFeat.name,\r\n    source: formatSourceForDisplay(rawFeat.source),\r\n    page: rawFeat.page,\r\n    description,\r\n    prerequisites,\r\n    abilityIncreases,\r\n    category: rawFeat.category,\r\n    repeatable: rawFeat.repeatable || false,\r\n    grantsSpells: grantsSpells(rawFeat),\r\n    isSrd:\r\n      rawFeat.srd ||\r\n      rawFeat.srd52 ||\r\n      rawFeat.basicRules ||\r\n      rawFeat.basicRules2024 ||\r\n      false,\r\n    tags: [\r\n      rawFeat.source,\r\n      ...(rawFeat.category ? [rawFeat.category] : []),\r\n      ...(prerequisites.length > 0 ? ['has-prerequisites'] : []),\r\n      ...(abilityIncreases ? ['ability-increase'] : []),\r\n      ...(grantsSpells(rawFeat) ? ['grants-spells'] : []),\r\n    ],\r\n  };\r\n}\r\n\r\n/**\r\n * Load and process all feats from JSON files\r\n */\r\nexport async function loadAllFeats(): Promise<ProcessedFeat[]> {\r\n  // Return cached feats if available\r\n  if (cachedFeats) {\r\n    return cachedFeats;\r\n  }\r\n\r\n  try {\r\n    const rawFeats = featsData.feat as RawFeatData[];\r\n\r\n    const processedFeats = rawFeats.map(feat => processFeat(feat));\r\n\r\n    // Cache the processed feats\r\n    cachedFeats = processedFeats;\r\n\r\n    console.log(`Loaded ${processedFeats.length} feats`);\r\n\r\n    return processedFeats;\r\n  } catch (error) {\r\n    console.error('Error loading feats:', error);\r\n    throw error;\r\n  }\r\n}\r\n\r\n/**\r\n * Clear the cache (useful for testing or forced reloads)\r\n */\r\nexport function clearFeatCache(): void {\r\n  cachedFeats = null;\r\n}\r\n\r\n/**\r\n * Get feat by name\r\n */\r\nexport async function getFeatByName(\r\n  name: string\r\n): Promise<ProcessedFeat | undefined> {\r\n  const feats = await loadAllFeats();\r\n  return feats.find(feat => feat.name.toLowerCase() === name.toLowerCase());\r\n}\r\n\r\n/**\r\n * Search feats by query\r\n */\r\nexport async function searchFeats(query: string): Promise<ProcessedFeat[]> {\r\n  if (!query.trim()) {\r\n    return loadAllFeats();\r\n  }\r\n\r\n  const feats = await loadAllFeats();\r\n  const queryLower = query.toLowerCase().trim();\r\n\r\n  return feats.filter(\r\n    feat =>\r\n      feat.name.toLowerCase().includes(queryLower) ||\r\n      feat.description.toLowerCase().includes(queryLower) ||\r\n      feat.prerequisites.some(p => p.toLowerCase().includes(queryLower)) ||\r\n      feat.tags.some(t => t.toLowerCase().includes(queryLower))\r\n  );\r\n}\r\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 283, "column": 0}, "map": {"version":3,"sources":["file:///home/irakli/Projects/RollKeeper/apps/web/src/app/api/feats/route.ts"],"sourcesContent":["import { NextResponse } from 'next/server';\r\nimport { loadAllFeats } from '@/utils/featDataLoader';\r\n\r\nexport async function GET() {\r\n  try {\r\n    const feats = await loadAllFeats();\r\n\r\n    return NextResponse.json({\r\n      feats,\r\n      total: feats.length,\r\n    });\r\n  } catch (error) {\r\n    console.error('Error loading feats:', error);\r\n    return NextResponse.json(\r\n      { error: 'Failed to load feat data' },\r\n      { status: 500 }\r\n    );\r\n  }\r\n}\r\n"],"names":[],"mappings":";;;;AAAA;AACA;;;AAEO,eAAe;IACpB,IAAI;QACF,MAAM,QAAQ,MAAM,IAAA,+JAAY;QAEhC,OAAO,gJAAY,CAAC,IAAI,CAAC;YACvB;YACA,OAAO,MAAM,MAAM;QACrB;IACF,EAAE,OAAO,OAAO;QACd,QAAQ,KAAK,CAAC,wBAAwB;QACtC,OAAO,gJAAY,CAAC,IAAI,CACtB;YAAE,OAAO;QAA2B,GACpC;YAAE,QAAQ;QAAI;IAElB;AACF","debugId":null}}]
}