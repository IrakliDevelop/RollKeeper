{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 3, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"","debugId":null}},
    {"offset": {"line": 67, "column": 0}, "map": {"version":3,"sources":["file:///home/irakli/Projects/RollKeeper/apps/web/src/utils/referenceParser.ts"],"sourcesContent":["export interface ParsedReference {\r\n  type:\r\n    | 'item'\r\n    | 'spell'\r\n    | 'filter'\r\n    | 'dice'\r\n    | 'creature'\r\n    | 'condition'\r\n    | 'action'\r\n    | 'skill'\r\n    | 'sense'\r\n    | 'damage'\r\n    | 'scaledamage'\r\n    | 'atk'\r\n    | 'atkr'\r\n    | 'hit'\r\n    | 'h'\r\n    | 'dc'\r\n    | 'actSave'\r\n    | 'actSaveFail'\r\n    | 'actSaveSuccess'\r\n    | 'actTrigger'\r\n    | 'actResponse'\r\n    | 'hitYourSpellAttack'\r\n    | 'unknown';\r\n  name: string;\r\n  source?: string;\r\n  displayText: string;\r\n  properties?: Record<string, string>;\r\n  isReference: boolean;\r\n}\r\n\r\nexport interface ParsedContent {\r\n  text: string;\r\n  references: ParsedReference[];\r\n  html: string;\r\n}\r\n\r\n/**\r\n * Parse 5etools-style references from text content\r\n * Formats: {@type name|source|extra}, {@type name|source}, {@type name}\r\n */\r\nexport function parseReferences(content: string): ParsedContent {\r\n  if (!content) {\r\n    return { text: content, references: [], html: content };\r\n  }\r\n\r\n  const references: ParsedReference[] = [];\r\n  let parsedHtml = content;\r\n\r\n  // Regex to match {@type content} patterns\r\n  const referenceRegex = /\\{@(\\w+)\\s+([^}]+)\\}/g;\r\n\r\n  let match;\r\n  while ((match = referenceRegex.exec(content)) !== null) {\r\n    const [fullMatch, type, content] = match;\r\n    const parts = content.split('|');\r\n\r\n    const name = parts[0]?.trim() || '';\r\n    const source = parts[1]?.trim();\r\n    const extra = parts.slice(2);\r\n\r\n    const reference: ParsedReference = {\r\n      type: normalizeReferenceType(type),\r\n      name,\r\n      source,\r\n      displayText: formatDisplayText(type, name, source, extra),\r\n      properties: parseExtraProperties(extra),\r\n      isReference: true,\r\n    };\r\n\r\n    references.push(reference);\r\n\r\n    // Replace in HTML with styled version\r\n    parsedHtml = parsedHtml.replace(fullMatch, formatReferenceHtml(reference));\r\n  }\r\n\r\n  // Clean up any remaining malformed references\r\n  parsedHtml = parsedHtml.replace(/\\{@\\w+[^}]*\\}/g, match => {\r\n    // If we couldn't parse it properly, just remove the {@...} wrapper\r\n    return match.replace(/\\{@\\w+\\s*/, '').replace(/\\}$/, '');\r\n  });\r\n\r\n  return {\r\n    text: content,\r\n    references,\r\n    html: parsedHtml,\r\n  };\r\n}\r\n\r\n/**\r\n * Normalize reference types to known categories\r\n */\r\nfunction normalizeReferenceType(type: string): ParsedReference['type'] {\r\n  const typeMap: Record<string, ParsedReference['type']> = {\r\n    item: 'item',\r\n    spell: 'spell',\r\n    filter: 'filter',\r\n    dice: 'dice',\r\n    creature: 'creature',\r\n    condition: 'condition',\r\n    action: 'action',\r\n    skill: 'skill',\r\n    sense: 'sense',\r\n    damage: 'damage',\r\n    scaledamage: 'scaledamage',\r\n    atk: 'atk',\r\n    atkr: 'atkr',\r\n    hit: 'hit',\r\n    h: 'h',\r\n    dc: 'dc',\r\n    actsave: 'actSave',\r\n    actsavefail: 'actSaveFail',\r\n    actsavesuccess: 'actSaveSuccess',\r\n    acttrigger: 'actTrigger',\r\n    actresponse: 'actResponse',\r\n    hityourspellattack: 'hitYourSpellAttack',\r\n    // Add more mappings as needed\r\n  };\r\n\r\n  return typeMap[type.toLowerCase()] || 'unknown';\r\n}\r\n\r\n/**\r\n * Parse scaled damage format: {@scaledamage baseDamage|levelRange|additionalPerLevel}\r\n * Example: {@scaledamage 8d6|3-9|1d6} -> \"8d6 (+ 1d6 per level above 3rd)\"\r\n */\r\nfunction parseScaledDamage(\r\n  baseDamage: string,\r\n  levelRange?: string,\r\n  extra?: string[]\r\n): string {\r\n  if (!levelRange || !extra || extra.length === 0) {\r\n    return baseDamage; // Fallback to base damage if parsing fails\r\n  }\r\n\r\n  const additionalPerLevel = extra[0];\r\n  const levelParts = levelRange.split('-');\r\n  const startLevel = levelParts[0];\r\n\r\n  if (!startLevel || !additionalPerLevel) {\r\n    return baseDamage;\r\n  }\r\n\r\n  // Format the level suffix (1st, 2nd, 3rd, 4th, etc.)\r\n  const levelSuffix = getLevelSuffix(parseInt(startLevel));\r\n\r\n  return `${baseDamage} (+ ${additionalPerLevel} per level above ${levelSuffix})`;\r\n}\r\n\r\n/**\r\n * Get the ordinal suffix for a level number\r\n */\r\nfunction getLevelSuffix(level: number): string {\r\n  if (level >= 11 && level <= 13) {\r\n    return `${level}th`;\r\n  }\r\n\r\n  const lastDigit = level % 10;\r\n  switch (lastDigit) {\r\n    case 1:\r\n      return `${level}st`;\r\n    case 2:\r\n      return `${level}nd`;\r\n    case 3:\r\n      return `${level}rd`;\r\n    default:\r\n      return `${level}th`;\r\n  }\r\n}\r\n\r\n/**\r\n * Format display text based on reference type and content\r\n */\r\nfunction formatDisplayText(\r\n  type: string,\r\n  name: string,\r\n  source?: string,\r\n  extra?: string[]\r\n): string {\r\n  switch (type.toLowerCase()) {\r\n    case 'item':\r\n      return name;\r\n\r\n    case 'filter':\r\n      return name;\r\n\r\n    case 'spell':\r\n      return name;\r\n\r\n    case 'dice':\r\n      return name;\r\n\r\n    case 'creature':\r\n      return name;\r\n\r\n    case 'condition':\r\n      return name;\r\n\r\n    case 'action':\r\n      return name;\r\n\r\n    case 'skill':\r\n      return name;\r\n\r\n    case 'sense':\r\n      return name;\r\n\r\n    case 'damage':\r\n      return name;\r\n\r\n    case 'scaledamage':\r\n      return parseScaledDamage(name, source, extra);\r\n\r\n    case 'atk':\r\n      // Handle attack types like \"mw\" (melee weapon), \"rw\" (ranged weapon)\r\n      switch (name.toLowerCase()) {\r\n        case 'm':\r\n        case 'mw':\r\n          return 'Melee Weapon Attack:';\r\n        case 'r':\r\n        case 'rw':\r\n          return 'Ranged Weapon Attack:';\r\n        case 'ms':\r\n          return 'Melee Spell Attack:';\r\n        case 'rs':\r\n          return 'Ranged Spell Attack:';\r\n        default:\r\n          return `${name} Attack:`;\r\n      }\r\n\r\n    case 'atkr':\r\n      // Handle ranged attack types\r\n      switch (name.toLowerCase()) {\r\n        case 'm':\r\n          return 'Melee Attack:';\r\n        case 'r':\r\n          return 'Ranged Attack:';\r\n        default:\r\n          return `${name} Attack:`;\r\n      }\r\n\r\n    case 'hit':\r\n      return `+${name}`;\r\n\r\n    case 'h':\r\n      return `Hit: ${name}`;\r\n\r\n    case 'dc':\r\n      return `DC ${name}`;\r\n\r\n    case 'actsave':\r\n      return `${name.toUpperCase()} save`;\r\n\r\n    case 'actsavefail':\r\n      return 'On a failed save:';\r\n\r\n    case 'actsavesuccess':\r\n      return 'On a successful save:';\r\n\r\n    case 'acttrigger':\r\n      return `Trigger: ${name}`;\r\n\r\n    case 'actresponse':\r\n      return `Response: ${name}`;\r\n\r\n    case 'hityourspellattack':\r\n      return name; // This typically contains the full text like \"Bonus equals your spell attack modifier\"\r\n\r\n    default:\r\n      return name;\r\n  }\r\n}\r\n\r\n/**\r\n * Parse extra properties from reference parts\r\n */\r\nfunction parseExtraProperties(extra: string[]): Record<string, string> {\r\n  const properties: Record<string, string> = {};\r\n\r\n  extra.forEach((prop, index) => {\r\n    if (prop.includes('=')) {\r\n      const [key, value] = prop.split('=', 2);\r\n      properties[key.trim()] = value.trim();\r\n    } else {\r\n      properties[`extra_${index}`] = prop.trim();\r\n    }\r\n  });\r\n\r\n  return properties;\r\n}\r\n\r\n/**\r\n * Format reference as HTML with appropriate styling\r\n */\r\nfunction formatReferenceHtml(reference: ParsedReference): string {\r\n  const baseClasses =\r\n    'inline-flex items-center gap-1 px-2 py-1 rounded text-sm font-medium transition-colors';\r\n\r\n  let typeClasses = '';\r\n  let icon = '';\r\n\r\n  switch (reference.type) {\r\n    case 'item':\r\n      typeClasses =\r\n        'bg-amber-500/10 text-amber-400 border border-amber-500/20 hover:bg-amber-500/20';\r\n      icon = '‚öîÔ∏è';\r\n      break;\r\n\r\n    case 'spell':\r\n      typeClasses =\r\n        'bg-purple-500/10 text-purple-400 border border-purple-500/20 hover:bg-purple-500/20';\r\n      icon = '‚ú®';\r\n      break;\r\n\r\n    case 'filter':\r\n      typeClasses =\r\n        'bg-blue-500/10 text-blue-400 border border-blue-500/20 hover:bg-blue-500/20';\r\n      icon = 'üîç';\r\n      break;\r\n\r\n    case 'dice':\r\n      typeClasses =\r\n        'bg-red-500/10 text-red-400 border border-red-500/20 hover:bg-red-500/20';\r\n      icon = 'üé≤';\r\n      break;\r\n\r\n    case 'creature':\r\n      typeClasses =\r\n        'bg-green-500/10 text-green-400 border border-green-500/20 hover:bg-green-500/20';\r\n      icon = 'üêâ';\r\n      break;\r\n\r\n    case 'condition':\r\n      typeClasses =\r\n        'bg-orange-500/10 text-orange-400 border border-orange-500/20 hover:bg-orange-500/20';\r\n      icon = 'üí´';\r\n      break;\r\n\r\n    case 'action':\r\n      typeClasses =\r\n        'bg-indigo-500/10 text-indigo-400 border border-indigo-500/20 hover:bg-indigo-500/20';\r\n      icon = '‚ö°';\r\n      break;\r\n\r\n    case 'skill':\r\n      typeClasses =\r\n        'bg-cyan-500/10 text-cyan-400 border border-cyan-500/20 hover:bg-cyan-500/20';\r\n      icon = 'üéØ';\r\n      break;\r\n\r\n    case 'sense':\r\n      typeClasses =\r\n        'bg-pink-500/10 text-pink-400 border border-pink-500/20 hover:bg-pink-500/20';\r\n      icon = 'üëÅÔ∏è';\r\n      break;\r\n\r\n    case 'damage':\r\n      typeClasses =\r\n        'bg-red-600/10 text-red-400 border border-red-600/20 hover:bg-red-600/20';\r\n      icon = 'üí•';\r\n      break;\r\n\r\n    case 'scaledamage':\r\n      typeClasses =\r\n        'bg-emerald-500/10 text-emerald-400 border border-emerald-500/20 hover:bg-emerald-500/20';\r\n      icon = 'üìà';\r\n      break;\r\n\r\n    case 'atk':\r\n      typeClasses =\r\n        'bg-violet-500/10 text-violet-400 border border-violet-500/20 hover:bg-violet-500/20';\r\n      icon = '‚öîÔ∏è';\r\n      break;\r\n\r\n    case 'atkr':\r\n      typeClasses =\r\n        'bg-violet-600/10 text-violet-400 border border-violet-600/20 hover:bg-violet-600/20';\r\n      icon = 'üèπ';\r\n      break;\r\n\r\n    case 'hit':\r\n      typeClasses =\r\n        'bg-emerald-600/10 text-emerald-400 border border-emerald-600/20 hover:bg-emerald-600/20';\r\n      icon = 'üéØ';\r\n      break;\r\n\r\n    case 'h':\r\n      typeClasses =\r\n        'bg-red-500/10 text-red-400 border border-red-500/20 hover:bg-red-500/20';\r\n      icon = 'üí•';\r\n      break;\r\n\r\n    case 'dc':\r\n      typeClasses =\r\n        'bg-blue-600/10 text-blue-400 border border-blue-600/20 hover:bg-blue-600/20';\r\n      icon = 'üî¢';\r\n      break;\r\n\r\n    case 'actSave':\r\n      typeClasses =\r\n        'bg-yellow-500/10 text-yellow-400 border border-yellow-500/20 hover:bg-yellow-500/20';\r\n      icon = 'üõ°Ô∏è';\r\n      break;\r\n\r\n    case 'actSaveFail':\r\n      typeClasses =\r\n        'bg-red-700/10 text-red-400 border border-red-700/20 hover:bg-red-700/20';\r\n      icon = '‚ùå';\r\n      break;\r\n\r\n    case 'actSaveSuccess':\r\n      typeClasses =\r\n        'bg-green-600/10 text-green-400 border border-green-600/20 hover:bg-green-600/20';\r\n      icon = '‚úÖ';\r\n      break;\r\n\r\n    case 'actTrigger':\r\n      typeClasses =\r\n        'bg-orange-600/10 text-orange-400 border border-orange-600/20 hover:bg-orange-600/20';\r\n      icon = '‚ö°';\r\n      break;\r\n\r\n    case 'actResponse':\r\n      typeClasses =\r\n        'bg-indigo-600/10 text-indigo-400 border border-indigo-600/20 hover:bg-indigo-600/20';\r\n      icon = '‚Ü©Ô∏è';\r\n      break;\r\n\r\n    case 'hitYourSpellAttack':\r\n      typeClasses =\r\n        'bg-purple-600/10 text-purple-400 border border-purple-600/20 hover:bg-purple-600/20';\r\n      icon = '‚ú®';\r\n      break;\r\n\r\n    default:\r\n      typeClasses =\r\n        'bg-slate-500/10 text-slate-400 border border-slate-500/20 hover:bg-slate-500/20';\r\n      icon = '‚ùì';\r\n  }\r\n\r\n  const title = reference.source\r\n    ? `${reference.displayText} (${reference.source})`\r\n    : reference.displayText;\r\n\r\n  return `<span class=\"${baseClasses} ${typeClasses}\" title=\"${title}\">${icon} ${reference.displayText}</span>`;\r\n}\r\n\r\n/**\r\n * Extract plain text from parsed content (removes all reference formatting)\r\n */\r\nexport function getPlainText(content: string): string {\r\n  return parseReferences(content).html.replace(/<[^>]*>/g, '');\r\n}\r\n\r\n/**\r\n * Get all references from content\r\n */\r\nexport function extractReferences(content: string): ParsedReference[] {\r\n  return parseReferences(content).references;\r\n}\r\n\r\n/**\r\n * Check if content contains references\r\n */\r\nexport function hasReferences(content: string): boolean {\r\n  return /\\{@\\w+\\s+[^}]+\\}/.test(content);\r\n}\r\n\r\n/**\r\n * Get formatted HTML for React components\r\n */\r\nexport function getFormattedHtml(content: string): string {\r\n  return parseReferences(content).html;\r\n}\r\n\r\n/**\r\n * Format reference as bold HTML for WYSIWYG editor\r\n * Used in spell edit modal to make important references stand out\r\n */\r\nfunction formatReferenceForEditor(reference: ParsedReference): string {\r\n  // For most references, just bold the display text\r\n  return `<strong>${reference.displayText}</strong>`;\r\n}\r\n\r\n/**\r\n * Parse references and format them for WYSIWYG editor\r\n * Converts {@...} tags to bold text for better editing experience\r\n */\r\nexport function formatSpellDescriptionForEditor(content: string): string {\r\n  if (!content) {\r\n    return '';\r\n  }\r\n\r\n  let formattedHtml = content;\r\n\r\n  // Regex to match {@type content} patterns\r\n  const referenceRegex = /\\{@(\\w+)\\s+([^}]+)\\}/g;\r\n\r\n  let match;\r\n  const replacements: Array<{ from: string; to: string }> = [];\r\n\r\n  while ((match = referenceRegex.exec(content)) !== null) {\r\n    const [fullMatch, type, content] = match;\r\n    const parts = content.split('|');\r\n\r\n    const name = parts[0]?.trim() || '';\r\n    const source = parts[1]?.trim();\r\n    const extra = parts.slice(2);\r\n\r\n    const reference: ParsedReference = {\r\n      type: normalizeReferenceType(type),\r\n      name,\r\n      source,\r\n      displayText: formatDisplayText(type, name, source, extra),\r\n      properties: parseExtraProperties(extra),\r\n      isReference: true,\r\n    };\r\n\r\n    // Replace with bold HTML for editor\r\n    replacements.push({\r\n      from: fullMatch,\r\n      to: formatReferenceForEditor(reference),\r\n    });\r\n  }\r\n\r\n  // Apply all replacements\r\n  replacements.forEach(({ from, to }) => {\r\n    formattedHtml = formattedHtml.replace(from, to);\r\n  });\r\n\r\n  // Clean up any remaining malformed references\r\n  formattedHtml = formattedHtml.replace(/\\{@\\w+[^}]*\\}/g, match => {\r\n    // If we couldn't parse it properly, just remove the {@...} wrapper\r\n    return match.replace(/\\{@\\w+\\s*/, '').replace(/\\}$/, '');\r\n  });\r\n\r\n  // Convert newlines to proper paragraph breaks for the editor\r\n  // Split by double newlines (paragraph breaks)\r\n  const paragraphs = formattedHtml.split('\\n\\n');\r\n\r\n  // Wrap each paragraph in <p> tags if not already wrapped\r\n  const wrappedParagraphs = paragraphs\r\n    .map(para => {\r\n      const trimmed = para.trim();\r\n      if (!trimmed) return '';\r\n      // If it already starts with an HTML tag, leave it as is\r\n      if (trimmed.startsWith('<')) return trimmed;\r\n      // Otherwise wrap in <p> tags\r\n      return `<p>${trimmed.replace(/\\n/g, '<br>')}</p>`;\r\n    })\r\n    .filter(Boolean);\r\n\r\n  return wrappedParagraphs.join('');\r\n}\r\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 452, "column": 0}, "map": {"version":3,"sources":["file:///home/irakli/Projects/RollKeeper/apps/web/src/utils/sourceUtils.ts"],"sourcesContent":["/**\r\n * Utilities for handling D&D source prioritization and display\r\n *\r\n * This handles the transition from D&D 5e (2014) to D&D 5e (2024) by:\r\n * - Prioritizing 2024 versions (XPHB) over 2014 versions (PHB)\r\n * - Converting XPHB source to \"PHB2024\" for display\r\n * - Providing consistent deduplication logic across content types\r\n */\r\n\r\n/**\r\n * Convert raw source to display source\r\n * XPHB (2024 Player's Handbook) -> PHB2024 for user-friendly display\r\n */\r\nexport function formatSourceForDisplay(rawSource: string): string {\r\n  return rawSource === 'XPHB' ? 'PHB2024' : rawSource;\r\n}\r\n\r\n/**\r\n * Check if a source should be prioritized over another\r\n * Priority order: PHB2024 (XPHB) > SRD > PHB > others\r\n */\r\nexport function shouldReplaceSource(\r\n  existingSource: string,\r\n  newSource: string,\r\n  existingIsSrd: boolean = false,\r\n  newIsSrd: boolean = false\r\n): boolean {\r\n  // Always prefer 2024 version\r\n  if (newSource === 'PHB2024') return true;\r\n\r\n  // Don't replace 2024 version with anything else\r\n  if (existingSource === 'PHB2024') return false;\r\n\r\n  // Prefer SRD if no 2024 version exists\r\n  if (!existingIsSrd && newIsSrd) return true;\r\n\r\n  // Don't replace SRD with non-SRD (unless it's 2024)\r\n  if (existingIsSrd && !newIsSrd) return false;\r\n\r\n  // Prefer PHB over other sources if no 2024/SRD exists\r\n  if (existingSource !== 'PHB' && !existingIsSrd && newSource === 'PHB')\r\n    return true;\r\n\r\n  return false;\r\n}\r\n\r\n/**\r\n * Generic deduplication function for D&D content with source prioritization\r\n * Can be used for spells, classes, feats, monsters, etc.\r\n */\r\nexport function deduplicateBySourcePriority<\r\n  T extends {\r\n    name: string;\r\n    source: string;\r\n    isSrd?: boolean;\r\n  },\r\n>(\r\n  items: T[],\r\n  getKey: (item: T) => string = item => item.name.toLowerCase()\r\n): T[] {\r\n  const uniqueItems = new Map<string, T>();\r\n\r\n  for (const item of items) {\r\n    const key = getKey(item);\r\n    const existingItem = uniqueItems.get(key);\r\n\r\n    if (!existingItem) {\r\n      // No existing item, add this one\r\n      uniqueItems.set(key, item);\r\n    } else {\r\n      // Check if we should replace the existing item\r\n      const shouldReplace = shouldReplaceSource(\r\n        existingItem.source,\r\n        item.source,\r\n        existingItem.isSrd || false,\r\n        item.isSrd || false\r\n      );\r\n\r\n      if (shouldReplace) {\r\n        uniqueItems.set(key, item);\r\n      }\r\n    }\r\n  }\r\n\r\n  return Array.from(uniqueItems.values());\r\n}\r\n\r\n/**\r\n * Get the edition year from a source\r\n * Useful for displaying edition information to users\r\n */\r\nexport function getSourceEdition(source: string): string {\r\n  switch (source) {\r\n    case 'PHB2024':\r\n    case 'XPHB':\r\n      return '2024';\r\n    case 'PHB':\r\n      return '2014';\r\n    case 'SRD':\r\n      return 'SRD';\r\n    default:\r\n      return 'Other';\r\n  }\r\n}\r\n\r\n/**\r\n * Check if a source is from the 2024 edition\r\n */\r\nexport function is2024Source(source: string): boolean {\r\n  return source === 'XPHB' || source === 'PHB2024';\r\n}\r\n\r\n/**\r\n * Check if a source is from the 2014 edition\r\n */\r\nexport function is2014Source(source: string): boolean {\r\n  return source === 'PHB';\r\n}\r\n\r\n/**\r\n * Compare two sources for sorting priority\r\n * Returns negative if first should come before second, positive if after, 0 if equal priority\r\n * Priority: PHB2024 > SRD > PHB > others (alphabetical)\r\n */\r\nexport function compareSourcePriority(\r\n  sourceA: string,\r\n  sourceB: string\r\n): number {\r\n  // PHB2024 always comes first\r\n  if (sourceA === 'PHB2024' && sourceB !== 'PHB2024') return -1;\r\n  if (sourceB === 'PHB2024' && sourceA !== 'PHB2024') return 1;\r\n\r\n  // If both or neither are PHB2024, check SRD\r\n  if (sourceA === 'SRD' && sourceB !== 'SRD' && sourceB !== 'PHB2024')\r\n    return -1;\r\n  if (sourceB === 'SRD' && sourceA !== 'SRD' && sourceA !== 'PHB2024') return 1;\r\n\r\n  // If both or neither are SRD/PHB2024, check PHB\r\n  if (\r\n    sourceA === 'PHB' &&\r\n    sourceB !== 'PHB' &&\r\n    sourceB !== 'SRD' &&\r\n    sourceB !== 'PHB2024'\r\n  )\r\n    return -1;\r\n  if (\r\n    sourceB === 'PHB' &&\r\n    sourceA !== 'PHB' &&\r\n    sourceA !== 'SRD' &&\r\n    sourceA !== 'PHB2024'\r\n  )\r\n    return 1;\r\n\r\n  // Equal priority, sort alphabetically\r\n  return sourceA.localeCompare(sourceB);\r\n}\r\n"],"names":[],"mappings":"AAAA;;;;;;;CAOC,GAED;;;CAGC;;;;;;;;;;;;;;;;AACM,SAAS,uBAAuB,SAAiB;IACtD,OAAO,cAAc,SAAS,YAAY;AAC5C;AAMO,SAAS,oBACd,cAAsB,EACtB,SAAiB,EACjB,gBAAyB,KAAK,EAC9B,WAAoB,KAAK;IAEzB,6BAA6B;IAC7B,IAAI,cAAc,WAAW,OAAO;IAEpC,gDAAgD;IAChD,IAAI,mBAAmB,WAAW,OAAO;IAEzC,uCAAuC;IACvC,IAAI,CAAC,iBAAiB,UAAU,OAAO;IAEvC,oDAAoD;IACpD,IAAI,iBAAiB,CAAC,UAAU,OAAO;IAEvC,sDAAsD;IACtD,IAAI,mBAAmB,SAAS,CAAC,iBAAiB,cAAc,OAC9D,OAAO;IAET,OAAO;AACT;AAMO,SAAS,4BAOd,KAAU,EACV,SAA8B,CAAA,OAAQ,KAAK,IAAI,CAAC,WAAW,EAAE;IAE7D,MAAM,cAAc,IAAI;IAExB,KAAK,MAAM,QAAQ,MAAO;QACxB,MAAM,MAAM,OAAO;QACnB,MAAM,eAAe,YAAY,GAAG,CAAC;QAErC,IAAI,CAAC,cAAc;YACjB,iCAAiC;YACjC,YAAY,GAAG,CAAC,KAAK;QACvB,OAAO;YACL,+CAA+C;YAC/C,MAAM,gBAAgB,oBACpB,aAAa,MAAM,EACnB,KAAK,MAAM,EACX,aAAa,KAAK,IAAI,OACtB,KAAK,KAAK,IAAI;YAGhB,IAAI,eAAe;gBACjB,YAAY,GAAG,CAAC,KAAK;YACvB;QACF;IACF;IAEA,OAAO,MAAM,IAAI,CAAC,YAAY,MAAM;AACtC;AAMO,SAAS,iBAAiB,MAAc;IAC7C,OAAQ;QACN,KAAK;QACL,KAAK;YACH,OAAO;QACT,KAAK;YACH,OAAO;QACT,KAAK;YACH,OAAO;QACT;YACE,OAAO;IACX;AACF;AAKO,SAAS,aAAa,MAAc;IACzC,OAAO,WAAW,UAAU,WAAW;AACzC;AAKO,SAAS,aAAa,MAAc;IACzC,OAAO,WAAW;AACpB;AAOO,SAAS,sBACd,OAAe,EACf,OAAe;IAEf,6BAA6B;IAC7B,IAAI,YAAY,aAAa,YAAY,WAAW,OAAO,CAAC;IAC5D,IAAI,YAAY,aAAa,YAAY,WAAW,OAAO;IAE3D,4CAA4C;IAC5C,IAAI,YAAY,SAAS,YAAY,SAAS,YAAY,WACxD,OAAO,CAAC;IACV,IAAI,YAAY,SAAS,YAAY,SAAS,YAAY,WAAW,OAAO;IAE5E,gDAAgD;IAChD,IACE,YAAY,SACZ,YAAY,SACZ,YAAY,SACZ,YAAY,WAEZ,OAAO,CAAC;IACV,IACE,YAAY,SACZ,YAAY,SACZ,YAAY,SACZ,YAAY,WAEZ,OAAO;IAET,sCAAsC;IACtC,OAAO,QAAQ,aAAa,CAAC;AAC/B","debugId":null}},
    {"offset": {"line": 548, "column": 0}, "map": {"version":3,"sources":["file:///home/irakli/Projects/RollKeeper/apps/web/src/utils/classDataLoader.ts"],"sourcesContent":["import { promises as fs } from 'fs';\r\nimport path from 'path';\r\nimport { parseReferences } from './referenceParser';\r\nimport { formatSourceForDisplay, compareSourcePriority } from './sourceUtils';\r\nimport {\r\n  ClassDataFile,\r\n  RawClassData,\r\n  RawSubclassData,\r\n  ProcessedClass,\r\n  ProcessedSubclass,\r\n  ClassFeature,\r\n  SubclassSpellList,\r\n  SpellcastingType,\r\n} from '@/types/classes';\r\n\r\n// Cache for loaded classes to avoid reprocessing\r\nlet cachedClasses: ProcessedClass[] | null = null;\r\n\r\n/**\r\n * Load all class JSON files from the json/class directory\r\n */\r\nasync function loadClassFiles(): Promise<ClassDataFile[]> {\r\n  const classDir = path.join(process.cwd(), 'json', 'class');\r\n  const files = await fs.readdir(classDir);\r\n  const classFiles = files.filter(file => file.endsWith('.json'));\r\n\r\n  const allClassData: ClassDataFile[] = [];\r\n\r\n  for (const file of classFiles) {\r\n    try {\r\n      const filePath = path.join(classDir, file);\r\n      const fileContent = await fs.readFile(filePath, 'utf-8');\r\n      const data: ClassDataFile = JSON.parse(fileContent);\r\n\r\n      if (data.class && Array.isArray(data.class)) {\r\n        allClassData.push(data);\r\n      }\r\n    } catch (error) {\r\n      console.error(`Error loading class file ${file}:`, error);\r\n    }\r\n  }\r\n\r\n  return allClassData;\r\n}\r\n\r\n/**\r\n * Generate a unique ID for a class based on name and source\r\n */\r\nfunction generateClassId(name: string, source: string): string {\r\n  return `${name.toLowerCase().replace(/[^a-z0-9]/g, '-')}-${source.toLowerCase()}`;\r\n}\r\n\r\n/**\r\n * Generate a unique ID for a subclass\r\n */\r\nfunction generateSubclassId(\r\n  name: string,\r\n  className: string,\r\n  source: string\r\n): string {\r\n  return `${className.toLowerCase().replace(/[^a-z0-9]/g, '-')}-${name.toLowerCase().replace(/[^a-z0-9]/g, '-')}-${source.toLowerCase()}`;\r\n}\r\n\r\n/**\r\n * Convert hit die data to readable string\r\n */\r\nfunction formatHitDie(\r\n  hd: { number: number; faces: number } | undefined\r\n): string {\r\n  if (!hd || !hd.faces) {\r\n    return 'd8'; // Default hit die if not specified\r\n  }\r\n  return `d${hd.faces}`;\r\n}\r\n\r\n/**\r\n * Determine spellcasting type from class data\r\n */\r\nfunction determineSpellcastingType(classData: RawClassData): SpellcastingType {\r\n  if (classData.casterProgression) {\r\n    return classData.casterProgression;\r\n  }\r\n\r\n  // Fallback logic based on class name\r\n  const className = classData.name.toLowerCase();\r\n  if (className.includes('warlock')) return 'warlock';\r\n  if (\r\n    ['wizard', 'sorcerer', 'bard', 'cleric', 'druid'].some(c =>\r\n      className.includes(c)\r\n    )\r\n  ) {\r\n    return 'full';\r\n  }\r\n  if (['paladin', 'ranger'].some(c => className.includes(c))) {\r\n    return 'half';\r\n  }\r\n  if (\r\n    ['eldritch knight', 'arcane trickster'].some(c => className.includes(c))\r\n  ) {\r\n    return 'third';\r\n  }\r\n\r\n  return 'none';\r\n}\r\n\r\n/**\r\n * Extract skill choices from starting proficiencies\r\n */\r\nfunction extractSkillChoices(\r\n  skills?: Array<{ choose?: { from: string[]; count: number } } | string>\r\n) {\r\n  if (!skills || skills.length === 0) return undefined;\r\n\r\n  for (const skill of skills) {\r\n    if (typeof skill === 'object' && skill.choose) {\r\n      return {\r\n        from: skill.choose.from,\r\n        count: skill.choose.count,\r\n      };\r\n    }\r\n  }\r\n\r\n  return undefined;\r\n}\r\n\r\n/**\r\n * Process multiclassing requirements to handle complex OR logic\r\n */\r\nfunction processMulticlassingRequirements(\r\n  requirements?: Record<string, unknown>\r\n): Record<string, number> {\r\n  if (!requirements) return {};\r\n\r\n  // Handle OR requirements (e.g., Fighter needs STR 13 OR DEX 13)\r\n  if (requirements.or && Array.isArray(requirements.or)) {\r\n    // For now, take the first option in OR requirements\r\n    const firstOption = requirements.or[0] as Record<string, number>;\r\n    if (firstOption && typeof firstOption === 'object') {\r\n      return firstOption;\r\n    }\r\n  }\r\n\r\n  // Handle direct requirements (e.g., Paladin needs STR 13 AND CHA 13)\r\n  const result: Record<string, number> = {};\r\n  for (const [key, value] of Object.entries(requirements)) {\r\n    if (key !== 'or' && typeof value === 'number') {\r\n      result[key] = value;\r\n    }\r\n  }\r\n\r\n  return result;\r\n}\r\n\r\n/**\r\n * Clean and format equipment strings\r\n */\r\nfunction formatEquipment(equipment?: string[]): string[] {\r\n  if (!equipment) return [];\r\n\r\n  return equipment.map(item => {\r\n    // Ensure item is a string before processing\r\n    const itemStr = typeof item === 'string' ? item : String(item);\r\n    // Parse references and return the HTML with proper styling\r\n    return parseReferences(itemStr).html;\r\n  });\r\n}\r\n\r\n/**\r\n * Process class features and extract descriptions\r\n */\r\nfunction processClassFeatures(\r\n  classFeatures: string[] | Record<string, unknown>[],\r\n  classFeatureDescriptions: Record<string, unknown>[],\r\n  className: string,\r\n  source: string\r\n): ClassFeature[] {\r\n  if (!classFeatures || !Array.isArray(classFeatures)) return [];\r\n\r\n  const features = classFeatures.map(feature => {\r\n    let featureName: string;\r\n    let level: number = 1;\r\n    let isSubclassFeature = false;\r\n    let original: string;\r\n\r\n    if (typeof feature === 'string') {\r\n      const parts = feature.split('|');\r\n      featureName = parts[0] || feature;\r\n      original = feature;\r\n\r\n      // Determine if this is a subclass feature based on format\r\n      // Subclass format: \"Feature Name|Class||Subclass||Level\"\r\n      // Class format: \"Feature Name|Class|Source|Level\"\r\n      if (parts.length >= 6 && parts[2] === '' && parts[4] === '') {\r\n        // Subclass feature format\r\n        level = parseInt(parts[5]) || 3; // Default to 3 for subclass features\r\n        isSubclassFeature = true;\r\n      } else {\r\n        // Class feature format\r\n        level = parseInt(parts[3]) || 1;\r\n        isSubclassFeature = false;\r\n      }\r\n    } else if (\r\n      feature &&\r\n      typeof feature === 'object' &&\r\n      'classFeature' in feature\r\n    ) {\r\n      const parts = String(feature.classFeature).split('|');\r\n      featureName = parts[0] || String(feature.classFeature);\r\n      original = String(feature.classFeature);\r\n      isSubclassFeature = Boolean(feature.gainSubclassFeature);\r\n\r\n      // Apply same logic for object format\r\n      if (parts.length >= 6 && parts[2] === '' && parts[4] === '') {\r\n        level = parseInt(parts[5]) || 3;\r\n      } else {\r\n        level = parseInt(parts[3]) || 1;\r\n      }\r\n    } else {\r\n      featureName = String(feature);\r\n      original = String(feature);\r\n    }\r\n\r\n    // Find the feature description in classFeatureDescriptions\r\n    const featureDesc = classFeatureDescriptions?.find(\r\n      desc =>\r\n        desc.name === featureName &&\r\n        desc.className === className &&\r\n        desc.level === level\r\n    );\r\n\r\n    let entries: string[] = [];\r\n    if (featureDesc?.entries && Array.isArray(featureDesc.entries)) {\r\n      entries = processFeatureEntries(featureDesc.entries);\r\n    }\r\n\r\n    return {\r\n      name: featureName,\r\n      level,\r\n      source: (featureDesc?.source as string) || source,\r\n      className,\r\n      entries,\r\n      isSubclassFeature,\r\n      original,\r\n      is2024Rules: Boolean(featureDesc?.basicRules2024),\r\n    };\r\n  });\r\n\r\n  // Prioritize 2024 features over 2014 features for the same level and name\r\n  return prioritize2024Features(features);\r\n}\r\n\r\n/**\r\n * Process subclass features specifically\r\n */\r\nfunction processSubclassFeatures(\r\n  subclassFeatures: string[] | Record<string, unknown>[],\r\n  subclassFeatureDescriptions: Record<string, unknown>[],\r\n  className: string,\r\n  source: string,\r\n  subclassShortName: string\r\n): ClassFeature[] {\r\n  if (\r\n    !subclassFeatureDescriptions ||\r\n    !Array.isArray(subclassFeatureDescriptions)\r\n  )\r\n    return [];\r\n\r\n  // Instead of processing subclassFeatures references, directly process all individual subclass features\r\n  // that belong to this specific subclass\r\n  const relevantFeatures = subclassFeatureDescriptions.filter(desc => {\r\n    const feature = desc as Record<string, unknown>;\r\n    return (\r\n      feature.className === className &&\r\n      feature.subclassShortName === subclassShortName &&\r\n      feature.name &&\r\n      feature.level\r\n    );\r\n  });\r\n\r\n  const features = relevantFeatures.map(featureDesc => {\r\n    const feature = featureDesc as Record<string, unknown>;\r\n    let entries: string[] = [];\r\n    if (feature.entries && Array.isArray(feature.entries)) {\r\n      entries = processFeatureEntries(feature.entries);\r\n    }\r\n\r\n    // Force 2024 D&D compliance: all subclass features start at level 3 minimum\r\n    const originalLevel = Number(feature.level) || 3;\r\n    const adjustedLevel = originalLevel < 3 ? 3 : originalLevel;\r\n\r\n    return {\r\n      name: String(feature.name || ''),\r\n      level: adjustedLevel,\r\n      source: String(feature.source || source),\r\n      className,\r\n      entries,\r\n      isSubclassFeature: true,\r\n      subclassShortName,\r\n      original: `${feature.name}|${className}||${subclassShortName}||${feature.level}`,\r\n      is2024Rules: Boolean(feature.basicRules2024),\r\n    };\r\n  });\r\n\r\n  // Prioritize 2024 features over 2014 features for the same level and name\r\n  return prioritize2024Features(features);\r\n}\r\n\r\n/**\r\n * Process feature entries and flatten nested structures\r\n */\r\nfunction processFeatureEntries(entries: unknown[]): string[] {\r\n  const result: string[] = [];\r\n\r\n  for (const entry of entries) {\r\n    if (typeof entry === 'string') {\r\n      result.push(parseReferences(entry).html);\r\n    } else if (entry && typeof entry === 'object') {\r\n      const entryObj = entry as Record<string, unknown>;\r\n      if (entryObj.type === 'entries' && Array.isArray(entryObj.entries)) {\r\n        // Nested entries\r\n        if (entryObj.name) {\r\n          result.push(`<strong>${entryObj.name}</strong>`);\r\n        }\r\n        result.push(...processFeatureEntries(entryObj.entries));\r\n      } else if (entryObj.type === 'inset' && Array.isArray(entryObj.entries)) {\r\n        // Inset boxes\r\n        if (entryObj.name) {\r\n          result.push(\r\n            `<div class=\"inset\"><strong>${entryObj.name}</strong></div>`\r\n          );\r\n        }\r\n        result.push(...processFeatureEntries(entryObj.entries));\r\n      } else if (entryObj.type === 'list' && Array.isArray(entryObj.items)) {\r\n        // Lists\r\n        result.push('<ul>');\r\n        for (const item of entryObj.items) {\r\n          if (typeof item === 'string') {\r\n            result.push(`<li>${parseReferences(item).html}</li>`);\r\n          }\r\n        }\r\n        result.push('</ul>');\r\n      } else if (Array.isArray(entryObj.entries)) {\r\n        // Generic nested entries\r\n        result.push(...processFeatureEntries(entryObj.entries));\r\n      }\r\n    }\r\n  }\r\n\r\n  return result;\r\n}\r\n\r\n/**\r\n * Extract spell slot progression from class table data\r\n */\r\nfunction extractSpellSlotProgression(\r\n  classData: RawClassData\r\n): Record<number, Record<number, number>> | undefined {\r\n  if (!classData.classTableGroups) return undefined;\r\n\r\n  for (const group of classData.classTableGroups) {\r\n    if (group.title?.includes('Spell Slots') && group.rowsSpellProgression) {\r\n      const progression: Record<number, Record<number, number>> = {};\r\n\r\n      group.rowsSpellProgression.forEach((row, levelIndex) => {\r\n        const level = levelIndex + 1;\r\n        progression[level] = {};\r\n\r\n        row.forEach((slots, spellLevelIndex) => {\r\n          const spellLevel = spellLevelIndex + 1;\r\n          if (slots > 0) {\r\n            progression[level][spellLevel] = slots;\r\n          }\r\n        });\r\n      });\r\n\r\n      return progression;\r\n    }\r\n  }\r\n\r\n  return undefined;\r\n}\r\n\r\n/**\r\n * Process raw class data into our application format\r\n */\r\nfunction processClass(\r\n  rawClass: RawClassData,\r\n  subclasses: RawSubclassData[],\r\n  fileData: ClassDataFile\r\n): ProcessedClass {\r\n  const id = generateClassId(rawClass.name, rawClass.source);\r\n  const spellcastingType = determineSpellcastingType(rawClass);\r\n\r\n  // Process subclasses for this class\r\n  // Match subclasses by className and classSource to ensure correct version pairing\r\n  const processedSubclasses = subclasses\r\n    .filter(\r\n      sub =>\r\n        sub.className === rawClass.name && sub.classSource === rawClass.source\r\n    )\r\n    .map(sub => processSubclass(sub, fileData))\r\n    .sort((a, b) => {\r\n      // First sort by source priority (PHB2024 > SRD > PHB > others)\r\n      const sourcePriority = compareSourcePriority(a.source, b.source);\r\n      if (sourcePriority !== 0) return sourcePriority;\r\n      // Then sort alphabetically by name\r\n      return a.name.localeCompare(b.name);\r\n    });\r\n\r\n  return {\r\n    id,\r\n    name: rawClass.name,\r\n    source: formatSourceForDisplay(rawClass.source),\r\n    page: rawClass.page,\r\n    hitDie: formatHitDie(rawClass.hd),\r\n    primaryAbilities: rawClass.proficiency || [],\r\n    spellcasting: {\r\n      type: spellcastingType,\r\n      ability: rawClass.spellcastingAbility,\r\n      preparedSpellsFormula: rawClass.preparedSpells,\r\n      cantripProgression: rawClass.cantripProgression,\r\n      spellsKnownProgression: rawClass.spellsKnownProgressionFixed,\r\n    },\r\n    proficiencies: {\r\n      armor: formatEquipment(rawClass.startingProficiencies?.armor),\r\n      weapons: formatEquipment(rawClass.startingProficiencies?.weapons),\r\n      tools: formatEquipment(rawClass.startingProficiencies?.tools),\r\n      savingThrows: rawClass.proficiency || [],\r\n      skillChoices: extractSkillChoices(rawClass.startingProficiencies?.skills),\r\n    },\r\n    startingEquipment: formatEquipment(rawClass.startingEquipment?.default),\r\n    multiclassing: rawClass.multiclassing\r\n      ? {\r\n          requirements: processMulticlassingRequirements(\r\n            rawClass.multiclassing.requirements\r\n          ),\r\n          proficienciesGained: {\r\n            armor: formatEquipment(\r\n              rawClass.multiclassing.proficienciesGained?.armor\r\n            ),\r\n            weapons: formatEquipment(\r\n              rawClass.multiclassing.proficienciesGained?.weapons\r\n            ),\r\n            tools: formatEquipment(\r\n              rawClass.multiclassing.proficienciesGained?.tools\r\n            ),\r\n          },\r\n        }\r\n      : undefined,\r\n    features: processClassFeatures(\r\n      rawClass.classFeatures || [],\r\n      (fileData.classFeature || []) as Record<string, unknown>[],\r\n      rawClass.name,\r\n      rawClass.source\r\n    ),\r\n    spellSlotProgression: extractSpellSlotProgression(rawClass),\r\n    subclasses: processedSubclasses,\r\n    isSrd: rawClass.srd || false,\r\n    tags: [\r\n      rawClass.source || 'unknown',\r\n      spellcastingType,\r\n      rawClass.spellcastingAbility || 'none',\r\n      formatHitDie(rawClass.hd),\r\n      ...(rawClass.edition ? [rawClass.edition] : []),\r\n    ],\r\n  };\r\n}\r\n\r\n/**\r\n * Prioritize 2024 features over 2014 features when both exist for the same level and name\r\n */\r\nfunction prioritize2024Features(features: ClassFeature[]): ClassFeature[] {\r\n  const featureMap = new Map<string, ClassFeature[]>();\r\n\r\n  // Group features by level and name\r\n  for (const feature of features) {\r\n    const key = `${feature.level}-${feature.name}`;\r\n    if (!featureMap.has(key)) {\r\n      featureMap.set(key, []);\r\n    }\r\n    featureMap.get(key)!.push(feature);\r\n  }\r\n\r\n  const prioritizedFeatures: ClassFeature[] = [];\r\n\r\n  // For each group, prioritize 2024 version if available\r\n  for (const [, featureGroup] of featureMap.entries()) {\r\n    if (featureGroup.length === 1) {\r\n      // Only one version, use it\r\n      prioritizedFeatures.push(featureGroup[0]);\r\n    } else {\r\n      // Multiple versions - find 2024 version\r\n      const rules2024Feature = featureGroup.find(f => f.is2024Rules);\r\n      if (rules2024Feature) {\r\n        prioritizedFeatures.push(rules2024Feature);\r\n      } else {\r\n        // No 2024 version found, use the first one (should be prioritized by source already)\r\n        prioritizedFeatures.push(featureGroup[0]);\r\n      }\r\n    }\r\n  }\r\n\r\n  return prioritizedFeatures.sort((a, b) => a.level - b.level);\r\n}\r\n\r\n/**\r\n * Clean spell name by removing source suffix (e.g., \"fireball|xphb\" -> \"fireball\")\r\n */\r\nfunction cleanSpellName(spellName: unknown): string {\r\n  try {\r\n    // Handle null/undefined\r\n    if (spellName == null) {\r\n      return '';\r\n    }\r\n\r\n    // Handle various input types\r\n    if (typeof spellName === 'string') {\r\n      // Remove source suffixes like \"|xphb\", \"|phb\", etc.\r\n      const cleaned = spellName.split('|')[0] || spellName;\r\n      return cleaned.trim();\r\n    } else if (typeof spellName === 'object') {\r\n      // Handle object format like { \"name\": \"fireball\", \"source\": \"xphb\" }\r\n      const spellObj = spellName as Record<string, unknown>;\r\n\r\n      // Try different object properties\r\n      if (spellObj.name && typeof spellObj.name === 'string') {\r\n        const cleaned = spellObj.name.split('|')[0] || spellObj.name;\r\n        return cleaned.trim();\r\n      }\r\n      if (spellObj.spell && typeof spellObj.spell === 'string') {\r\n        const cleaned = spellObj.spell.split('|')[0] || spellObj.spell;\r\n        return cleaned.trim();\r\n      }\r\n\r\n      // Skip logging for known spell selection rules (these are intentional)\r\n      if (spellObj.all || spellObj.choose || spellObj.daily || spellObj._) {\r\n        return ''; // These are spell selection rules, not actual spells\r\n      }\r\n\r\n      // Log truly unexpected objects for debugging\r\n      console.warn('Unexpected spell object format:', JSON.stringify(spellObj));\r\n      return '';\r\n    }\r\n\r\n    // Fallback for other types (numbers, etc.)\r\n    const fallbackStr = String(spellName);\r\n    const cleaned = fallbackStr.includes('|')\r\n      ? fallbackStr.split('|')[0]\r\n      : fallbackStr;\r\n    return cleaned.trim();\r\n  } catch (error) {\r\n    console.error(\r\n      'Error in cleanSpellName with input:',\r\n      spellName,\r\n      'Error:',\r\n      error\r\n    );\r\n    return '';\r\n  }\r\n}\r\n\r\n/**\r\n * Process additional spells for subclasses\r\n */\r\nfunction processSubclassSpells(\r\n  additionalSpells?: Array<{\r\n    prepared?: Record<string, unknown>;\r\n    known?: Record<string, unknown>;\r\n    expanded?: Record<string, unknown>;\r\n  }>\r\n): SubclassSpellList[] {\r\n  if (!additionalSpells || additionalSpells.length === 0) return [];\r\n\r\n  const spellList: SubclassSpellList[] = [];\r\n\r\n  additionalSpells.forEach(spellGroup => {\r\n    // Process prepared spells (most common for Domain, Oath, etc.)\r\n    if (spellGroup.prepared) {\r\n      Object.entries(spellGroup.prepared).forEach(([level, spells]) => {\r\n        // Handle various spell list formats\r\n        let cleanedSpells: string[] = [];\r\n\r\n        try {\r\n          if (Array.isArray(spells) && typeof spells.map === 'function') {\r\n            cleanedSpells = spells\r\n              .map(cleanSpellName)\r\n              .filter(\r\n                name => typeof name === 'string' && name.trim().length > 0\r\n              );\r\n          } else if (typeof spells === 'string') {\r\n            const cleaned = cleanSpellName(spells);\r\n            if (cleaned && cleaned.trim().length > 0) {\r\n              cleanedSpells = [cleaned];\r\n            }\r\n          } else if (spells && typeof spells === 'object') {\r\n            // Handle object format - might be a single spell object\r\n            const cleaned = cleanSpellName(spells);\r\n            if (cleaned && cleaned.trim().length > 0) {\r\n              cleanedSpells = [cleaned];\r\n            }\r\n          }\r\n\r\n          // Additional validation - ensure all entries are valid strings\r\n          cleanedSpells = cleanedSpells.filter(\r\n            spell =>\r\n              typeof spell === 'string' &&\r\n              spell.trim().length > 0 &&\r\n              !spell.includes('[object Object]')\r\n          );\r\n        } catch (error) {\r\n          console.error(\r\n            `Error processing prepared spells at level ${level}:`,\r\n            spells,\r\n            'Error:',\r\n            error\r\n          );\r\n        }\r\n\r\n        if (cleanedSpells.length > 0) {\r\n          spellList.push({\r\n            level: parseInt(level),\r\n            spells: cleanedSpells,\r\n          });\r\n        }\r\n      });\r\n    }\r\n\r\n    // Process known spells (some subclasses like Aberrant Mind Sorcerer)\r\n    if (spellGroup.known) {\r\n      Object.entries(spellGroup.known).forEach(([level, spells]) => {\r\n        // Handle various spell list formats\r\n        let cleanedSpells: string[] = [];\r\n\r\n        try {\r\n          if (Array.isArray(spells) && typeof spells.map === 'function') {\r\n            cleanedSpells = spells\r\n              .map(cleanSpellName)\r\n              .filter(\r\n                name => typeof name === 'string' && name.trim().length > 0\r\n              );\r\n          } else if (typeof spells === 'string') {\r\n            const cleaned = cleanSpellName(spells);\r\n            if (cleaned && cleaned.trim().length > 0) {\r\n              cleanedSpells = [cleaned];\r\n            }\r\n          } else if (spells && typeof spells === 'object') {\r\n            // Handle object format - might be a single spell object\r\n            const cleaned = cleanSpellName(spells);\r\n            if (cleaned && cleaned.trim().length > 0) {\r\n              cleanedSpells = [cleaned];\r\n            }\r\n          }\r\n\r\n          // Additional validation - ensure all entries are valid strings\r\n          cleanedSpells = cleanedSpells.filter(\r\n            spell =>\r\n              typeof spell === 'string' &&\r\n              spell.trim().length > 0 &&\r\n              !spell.includes('[object Object]')\r\n          );\r\n        } catch (error) {\r\n          console.error(\r\n            `Error processing known spells at level ${level}:`,\r\n            spells,\r\n            'Error:',\r\n            error\r\n          );\r\n        }\r\n\r\n        if (cleanedSpells.length > 0) {\r\n          spellList.push({\r\n            level: parseInt(level),\r\n            spells: cleanedSpells,\r\n          });\r\n        }\r\n      });\r\n    }\r\n\r\n    // Process expanded spells (Warlocks)\r\n    if (spellGroup.expanded) {\r\n      Object.entries(spellGroup.expanded).forEach(([level, spells]) => {\r\n        // Handle various spell list formats\r\n        let cleanedSpells: string[] = [];\r\n\r\n        try {\r\n          if (Array.isArray(spells) && typeof spells.map === 'function') {\r\n            cleanedSpells = spells\r\n              .map(cleanSpellName)\r\n              .filter(\r\n                name => typeof name === 'string' && name.trim().length > 0\r\n              );\r\n          } else if (typeof spells === 'string') {\r\n            const cleaned = cleanSpellName(spells);\r\n            if (cleaned && cleaned.trim().length > 0) {\r\n              cleanedSpells = [cleaned];\r\n            }\r\n          } else if (spells && typeof spells === 'object') {\r\n            // Handle object format - might be a single spell object\r\n            const cleaned = cleanSpellName(spells);\r\n            if (cleaned && cleaned.trim().length > 0) {\r\n              cleanedSpells = [cleaned];\r\n            }\r\n          }\r\n\r\n          // Additional validation - ensure all entries are valid strings\r\n          cleanedSpells = cleanedSpells.filter(\r\n            spell =>\r\n              typeof spell === 'string' &&\r\n              spell.trim().length > 0 &&\r\n              !spell.includes('[object Object]')\r\n          );\r\n        } catch (error) {\r\n          console.error(\r\n            `Error processing expanded spells at level ${level}:`,\r\n            spells,\r\n            'Error:',\r\n            error\r\n          );\r\n        }\r\n\r\n        if (cleanedSpells.length > 0) {\r\n          spellList.push({\r\n            level: parseInt(level),\r\n            spells: cleanedSpells,\r\n          });\r\n        }\r\n      });\r\n    }\r\n  });\r\n\r\n  return spellList.sort((a, b) => a.level - b.level);\r\n}\r\n\r\n/**\r\n * Process raw subclass data into our application format\r\n */\r\nfunction processSubclass(\r\n  rawSubclass: RawSubclassData,\r\n  fileData: ClassDataFile\r\n): ProcessedSubclass {\r\n  const id = generateSubclassId(\r\n    rawSubclass.name,\r\n    rawSubclass.className,\r\n    rawSubclass.source\r\n  );\r\n\r\n  return {\r\n    id,\r\n    name: rawSubclass.name,\r\n    shortName: rawSubclass.shortName,\r\n    source: formatSourceForDisplay(rawSubclass.source),\r\n    page: rawSubclass.page,\r\n    parentClassName: rawSubclass.className,\r\n    parentClassSource: rawSubclass.classSource,\r\n    features: processSubclassFeatures(\r\n      rawSubclass.subclassFeatures || [],\r\n      (fileData.subclassFeature || []) as Record<string, unknown>[],\r\n      rawSubclass.className,\r\n      rawSubclass.source,\r\n      rawSubclass.shortName || rawSubclass.name\r\n    ),\r\n    spellList: (() => {\r\n      try {\r\n        // Only process spell lists for classes that should have them\r\n        const classesWithSubclassSpells = [\r\n          'Cleric',\r\n          'Paladin',\r\n          'Warlock',\r\n          'Sorcerer',\r\n          'Ranger',\r\n        ];\r\n        if (!classesWithSubclassSpells.includes(rawSubclass.className)) {\r\n          return [];\r\n        }\r\n        return processSubclassSpells(rawSubclass.additionalSpells);\r\n      } catch (error) {\r\n        console.error(\r\n          `Error processing spell list for ${rawSubclass.name}:`,\r\n          error\r\n        );\r\n        return [];\r\n      }\r\n    })(),\r\n    tags: [\r\n      rawSubclass.source,\r\n      rawSubclass.className.toLowerCase(),\r\n      ...(rawSubclass.edition ? [rawSubclass.edition] : []),\r\n    ],\r\n  };\r\n}\r\n\r\n/**\r\n * Load and process all classes from JSON files\r\n */\r\nexport async function loadAllClasses(): Promise<ProcessedClass[]> {\r\n  // Return cached classes if available\r\n  if (cachedClasses) {\r\n    return cachedClasses;\r\n  }\r\n\r\n  try {\r\n    const classDataFiles = await loadClassFiles();\r\n    const processedClasses: ProcessedClass[] = [];\r\n\r\n    for (const classFile of classDataFiles) {\r\n      // Process each class in the file\r\n      for (const rawClass of classFile.class || []) {\r\n        try {\r\n          const processedClass = processClass(\r\n            rawClass,\r\n            classFile.subclass || [],\r\n            classFile\r\n          );\r\n          processedClasses.push(processedClass);\r\n        } catch (error) {\r\n          console.error(`Error processing class ${rawClass.name}:`, error);\r\n          // Log more details about the error for debugging\r\n          if (error instanceof Error) {\r\n            console.error(`Stack trace:`, error.stack);\r\n          }\r\n          // Continue with other classes instead of failing completely\r\n        }\r\n      }\r\n    }\r\n\r\n    // Sort classes: 2024 versions first, then 2014 versions, then alphabetically by name\r\n    processedClasses.sort((a, b) => {\r\n      // First, prioritize 2024 versions\r\n      const aIs2024 = a.source === 'PHB2024';\r\n      const bIs2024 = b.source === 'PHB2024';\r\n      \r\n      if (aIs2024 && !bIs2024) return -1;\r\n      if (!aIs2024 && bIs2024) return 1;\r\n      \r\n      // Then sort alphabetically by name\r\n      return a.name.localeCompare(b.name);\r\n    });\r\n\r\n    cachedClasses = processedClasses;\r\n\r\n    console.log(\r\n      `Loaded ${cachedClasses.length} classes (including both 2014 and 2024 versions)`\r\n    );\r\n\r\n    return cachedClasses;\r\n  } catch (error) {\r\n    console.error('Error loading classes:', error);\r\n    return [];\r\n  }\r\n}\r\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 1172, "column": 0}, "map": {"version":3,"sources":["file:///home/irakli/Projects/RollKeeper/apps/web/src/app/api/classes/route.ts"],"sourcesContent":["import { NextRequest, NextResponse } from 'next/server';\r\nimport { loadAllClasses } from '@/utils/classDataLoader';\r\n\r\nexport async function GET(request: NextRequest) {\r\n  try {\r\n    const { searchParams } = new URL(request.url);\r\n    const limit = searchParams.get('limit');\r\n    const offset = searchParams.get('offset');\r\n\r\n    // Load all class data\r\n    const classes = await loadAllClasses();\r\n\r\n    // Apply pagination if requested\r\n    if (limit && offset) {\r\n      const limitNum = parseInt(limit, 10);\r\n      const offsetNum = parseInt(offset, 10);\r\n      const paginatedClasses = classes.slice(offsetNum, offsetNum + limitNum);\r\n\r\n      return NextResponse.json({\r\n        classes: paginatedClasses,\r\n        total: classes.length,\r\n        hasMore: offsetNum + limitNum < classes.length,\r\n      });\r\n    }\r\n\r\n    // Return all classes\r\n    return NextResponse.json({\r\n      classes,\r\n      total: classes.length,\r\n      hasMore: false,\r\n    });\r\n  } catch (error) {\r\n    console.error('Error loading classes:', error);\r\n    return NextResponse.json(\r\n      { error: 'Failed to load class data' },\r\n      { status: 500 }\r\n    );\r\n  }\r\n}\r\n"],"names":[],"mappings":";;;;AAAA;AACA;;;AAEO,eAAe,IAAI,OAAoB;IAC5C,IAAI;QACF,MAAM,EAAE,YAAY,EAAE,GAAG,IAAI,IAAI,QAAQ,GAAG;QAC5C,MAAM,QAAQ,aAAa,GAAG,CAAC;QAC/B,MAAM,SAAS,aAAa,GAAG,CAAC;QAEhC,sBAAsB;QACtB,MAAM,UAAU,MAAM,IAAA,kKAAc;QAEpC,gCAAgC;QAChC,IAAI,SAAS,QAAQ;YACnB,MAAM,WAAW,SAAS,OAAO;YACjC,MAAM,YAAY,SAAS,QAAQ;YACnC,MAAM,mBAAmB,QAAQ,KAAK,CAAC,WAAW,YAAY;YAE9D,OAAO,gJAAY,CAAC,IAAI,CAAC;gBACvB,SAAS;gBACT,OAAO,QAAQ,MAAM;gBACrB,SAAS,YAAY,WAAW,QAAQ,MAAM;YAChD;QACF;QAEA,qBAAqB;QACrB,OAAO,gJAAY,CAAC,IAAI,CAAC;YACvB;YACA,OAAO,QAAQ,MAAM;YACrB,SAAS;QACX;IACF,EAAE,OAAO,OAAO;QACd,QAAQ,KAAK,CAAC,0BAA0B;QACxC,OAAO,gJAAY,CAAC,IAAI,CACtB;YAAE,OAAO;QAA4B,GACrC;YAAE,QAAQ;QAAI;IAElB;AACF","debugId":null}}]
}